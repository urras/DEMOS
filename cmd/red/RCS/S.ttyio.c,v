head     4.6;
access   ;
symbols  RED_4:3.1.2 RED_3_9:3.16 DEMOS_2:3.3 COMMON3:3.2 ES:3.1.1;
locks    ;
comment  @ * @;


4.6
date     89.02.20.22.48.12;  author alex;  state Exp;
branches ;
next     4.5;

4.5
date     88.04.07.12.19.20;  author alex;  state Exp;
branches ;
next     4.4;

4.4
date     88.04.07.12.02.13;  author alex;  state Exp;
branches ;
next     4.3;

4.3
date     88.04.04.22.16.14;  author alex;  state Exp;
branches ;
next     4.2;

4.2
date     88.03.31.22.50.29;  author alex;  state Exp;
branches ;
next     4.1;

4.1
date     88.03.31.22.06.09;  author alex;  state Exp;
branches ;
next     3.17;

3.17
date     88.03.30.17.25.07;  author alex;  state Exp;
branches ;
next     3.16;

3.16
date     87.06.12.18.07.21;  author alex;  state Exp;
branches ;
next     3.15;

3.15
date     87.06.08.20.01.08;  author alex;  state Exp;
branches ;
next     3.14;

3.14
date     87.06.05.23.48.29;  author alex;  state Exp;
branches ;
next     3.13;

3.13
date     87.06.04.23.41.52;  author alex;  state Exp;
branches ;
next     3.12;

3.12
date     87.04.21.22.46.30;  author alex;  state Stab;
branches ;
next     3.11;

3.11
date     87.04.21.22.28.57;  author alex;  state Exp;
branches ;
next     3.10;

3.10
date     87.04.02.18.29.44;  author alex;  state Exp;
branches ;
next     3.9;

3.9
date     87.02.17.06.49.40;  author alex;  state Exp;
branches ;
next     3.8;

3.8
date     86.11.25.08.06.26;  author alex;  state Exp;
branches ;
next     3.7;

3.7
date     86.10.29.02.46.37;  author root;  state Exp;
branches ;
next     3.6;

3.6
date     86.10.14.23.02.52;  author alex;  state Exp;
branches ;
next     3.5;

3.5
date     86.09.19.21.39.35;  author alex;  state Exp;
branches ;
next     3.4;

3.4
date     86.09.19.19.59.39;  author alex;  state Exp;
branches ;
next     3.3;

3.3
date     86.08.04.20.55.13;  author alex;  state Exp;
branches ;
next     3.2;

3.2
date     86.07.24.19.07.48;  author alex;  state Exp;
branches ;
next     3.1;

3.1
date     86.04.20.23.43.21;  author alex;  state Exp;
branches 3.1.2.1;
next     ;

3.1.2.1
date     87.06.19.16.56.43;  author alex;  state Exp;
branches ;
next     3.1.2.2;

3.1.2.2
date     87.06.23.18.55.33;  author alex;  state Stab;
branches ;
next     3.1.2.3;

3.1.2.3
date     87.06.24.22.36.46;  author alex;  state Stab;
branches ;
next     3.1.2.4;

3.1.2.4
date     87.07.03.22.03.56;  author alex;  state Exp;
branches ;
next     3.1.2.5;

3.1.2.5
date     87.07.09.20.44.11;  author alex;  state Exp;
branches ;
next     ;


desc
@  Полиэкранный редактор RED
  Версия 3.
  ИАЭ им. Курчатова, Москва.
@


4.6
log
@Исправлена ошибка в команде SUSPEND 
@
text
@/*
 *      Редактор RED.
 *       $Header: S.ttyio.c,v 4.5 88/04/07 12:19:20 alex Exp $
 *
 *      $Log:	S.ttyio.c,v $
 * Revision 4.5  88/04/07  12:19:20  alex
 * Очередная правка в роллировании.
 * 
 * Revision 4.4  88/04/07  12:02:13  alex
 * Исправили ошибку в работе setscroll.
 * 
 * Revision 4.3  88/04/04  22:16:14  alex
 * Исправлена ошибка в работе при расщеплении строки (режим CS).
 * 
 * Revision 4.2  88/03/31  22:50:29  alex
 * Исправлена ошибка при работе на терминале Электроника.
 * 
 * Revision 4.1  88/03/31  22:06:09  alex
 * Версия 4.1 - обкатка на UTEC, СМ
 * 
 * Revision 3.17  88/03/30  17:25:07  alex
 * Исправлена ошибка в readch. Введены функции для удаления/вставки
 * строк на экране через ChangeScroll/InsertLine-DeleteLine.
 * 
 * Revision 3.1.2.5  87/07/09  20:44:11  alex
 * REVISION
 * 
 * Revision 3.1.2.4  87/07/03  22:03:56  alex
 * Graph_characters used in margin
 * 
 * Revision 3.1.2.3  87/06/24  22:36:46  alex
 * New readch + gettc + tc table Tested
 * 
 * Revision 3.1.2.2  87/06/23  18:55:33  alex
 * Выкинута lread1 как класс.
 * 
 * Revision 3.1.2.1  87/06/19  16:56:43  alex
 * Start revision for red/4
 * 
 * Revision 3.16  87/06/12  18:07:21  alex
 * Исправлены ошибки в режиме vilcase и мелочи для vt-200
 * 
 * Revision 3.15  87/06/09  19:45:28  alex
 * Исправлена работа с tty ~ VT200 и 15-ИЭ-0013
 * 
 * Revision 3.14  87/06/05  23:48:29  alex
 * Добавлен roll для терминалов с sr/sf и отображение
 *  табуляций в режиме -t + всякая мелочь
 * 
 * Revision 3.13  87/06/04  23:41:52  alex
 * Scroll on -sr- or -al/dl- added
 * 
 * Revision 3.12  87/04/21  22:46:30  alex
 * Debug
 * 
 * Revision 3.11  87/04/21  22:28:57  alex
 * Исправлена ошибка в writefile.
 * 
 * Revision 3.10  87/04/02  18:29:44  alex
 * Версия для Utec слита с версией с выделением прописных букв
 * 
 * Revision 3.9  87/04/01  19:14:19  alex
 * Revision for Utec: Cs, Ce, Ct, hR
 * 
 * Revision 3.8  86/11/25  08:06:26  alex
 * Исправлено ioctl(..,TIOCFLUSH,&flag)
 * 
 * Revision 3.7  86/10/29  02:46:37  root
 * При неверной escape-последовательности сбратываем всю очередь ввода.
 * Сделано для борьбы с пропаданием символов.
 * 
 * Revision 3.6  86/10/14  23:02:52  alex
 * Исправлены ошибки с: RUSDIAG (не описан latdiag), и с LCASEO
 * (KI40BIT нужно задавать так, чтобы при lcasef была 1).
 * В СМ-1700 было 2 ошибки, в рез. все работало на LCASE правильно.
 * 
 * Revision 3.5  86/09/19  21:39:35  alex
 * 
 * 
 * Revision 3.4  86/09/19  19:59:39  alex
 * Версия для СМ-1700
 * 
 * Revision 3.3  86/08/04  20:55:13  alex
 * Bepqh dk LMNQ/DELNQ 2
 * 
 * Revision 3.2  86/07/24  19:07:48  alex
 * Об'единены версии текстов для ЕС и СМ
 *
 * Revision 3.1  86/04/20  23:43:21  alex
 * Базовая версия для ЕС.
 *
 * Revision 3.1  86/04/20  23:43:21  alex
 * *** empty log message ***
 *
 *      Работа с терминалом : установка/снятие режимов, ввод/вывод.
 *      Ввод управляющих клавиш.
 *      Физический уровень
 */

#include "r.defs.h"
#include "S.tele.h"
#include <sgtty.h>
#include <sys/types.h>
#include <sys/file.h>

#define NPUTCBUF 256   /* Размер буфера вывода */

#ifdef TIOCSETA
#define stty(des,fil) ioctl(des,TIOCSETA,fil)
#define gtty(des,fil) ioctl(des,TIOCGETA,fil)
#endif
#ifdef SGTTYB /* Признак ДЕМОС-2 */
#define sgttyb SGTTYB
#endif

#ifndef ANYP
#define ANYP (ODDP|EVENP)
#endif
struct sgttyb templ;
#ifdef TIOCGETC
struct tchars tchars0;
#endif
#ifdef TIOCSLTC
static struct ltchars tmpltc,oldltc;
#endif
int ospeed; /* Для termcap */
short cy40bit; /* Для переворота в упр. последовательностях */
short lcasef0; /* Внутренний признак lcase для вывода */
short latdiag;
short vilcasef;

/*
 * ttstartup()
 * Установить режимы терминала
 */
ttstartup()
{
    static struct sgttyb templw;
#ifdef TIOCGETC
    static struct tchars tcharsw;
#endif
#ifdef TIOCGETC
    ioctl(2,TIOCGETC, &tchars0);
    tcharsw=tchars0;
    if  (tcharsw.t_intrc=='\177')tcharsw.t_intrc=3; /* ETX - intrup of RE */
    tcharsw.t_quitc = -1;
    ioctl(2,TIOCSETC, &tcharsw);
#endif
#ifdef TIOCSLTC
    ioctl(2,TIOCGLTC,&tmpltc);
    oldltc = tmpltc;
    tmpltc.t_suspc = tmpltc.t_dsuspc = tmpltc.t_flushc = -1;
    ioctl(2,TIOCSLTC,&tmpltc);
#endif
    gtty(2,&templ);
/*  printf("GTTY %o\n", &templ);        */
    templw=templ;
    ospeed = templ.sg_ospeed;
    lcasef=lcasef0=LCFLG(templ.sg_flags);
    latf = LATFLG(templ.sg_flags);
    if ( latf ) latdiag = 1;
    if(lcasef) latf=0;
    kioutf = KIOFLG(templ.sg_flags);
#ifdef KI40BIT
    cy40bit = KI40BIT(templ.sg_flags);
#endif
    if(atcread)
    {   register int i;
	i=(*atcread)();
	atcread = (int (*)())NULL;
	if(i) {
	    printf1((i==1?
	    DIAG("unknown term capabilities\n please, type \n  TERM=<type>;export TERM \n and repeat red\n","Не задано описание возможностей терминала, \n наберите TERM=тип;export TERM и повторите вызов"):
	    DIAG("re can not work with this terminal\n","red не может работать с этим терминалом")));
	    exit(1);
	}
    }
    templw.sg_flags=REDFLG(templw.sg_flags);
    if(lcasef) templw.sg_flags =REDFLGL(templw.sg_flags);
     if(lcasef && cvtout[COVIOPE] ) {
       vilcasef = 1; lcasef = 0;
     }
#ifdef TIOCSETA
    templw.sg_length=0;
    templw.sg_width=0;
/*
#ifdef Y_SIGSTOP
    templw.sg_suspc = templw.sg_dsuspc = -1;
#endif
#ifdef TIOCSLTC
    templw.sg_flushc = -1;
#endif
 */
#endif
    stty(2,&templw);
}

/*
 * ttcleanup()
 * Восстановить режимы терминала
 */
ttcleanup()
{
    setscroll(&wholescreen,0);
    setatr(A_NORM);
    putcha(COFIN);
    dumpcbuf(0);
    printf("\n");
    stty(2,&templ);
#ifdef TIOCSLTC
    ioctl(2,TIOCSLTC, &oldltc);
#endif
#ifdef TIOCGETC
    ioctl(2,TIOCSETC, &tchars0);
#endif
}

/*
 * pcursor(col,lin) -
 * установить курсор в физические координаты на
 * экране. Ответ 0, если нет прямой адресации
 */
pcursor(col,lin)
int col,lin;
{ 
    register char *c,sy;
    if ((c=curspos)==NIL) return 0;
    if (agoto) c=(*agoto)(curspos,col,lin);
    if (*c=='O') return(0);
    while ((sy = *c++))
    {
        if(!agoto&&(sy&0200)){ 
            if (sy&0100) sy=(sy&077)+col;  /* 300 - col */
            else sy=(sy&077)+lin;
        }                        /* 200 - lin */
        putchb(sy);
    } 
    return (1);
}

/* ===================
 * Работа с буфером символов
 * ===================
 */

char putcbuf[NPUTCBUF];
int iputcbuf=0;

/*
 * putcha(c) - выдать символ "c".
 * "c" может быть кодом управления.
 * Возвращается 0, если запрошенная операция невозможна
 */
putcha(c)
register int c;
{
    register char cr, *s;
    static short vicase=0;
    static short graphcase = 0;
    short vineed, needgraph;
    c &= 0377;
    if (c>=0 && c<=COMCOD) {
	if( c == COSTART) n0scroll = n1scroll = -1;
	if(!(s=cvtout[c])) return(0);
        while ((cr = *s++) != 0) putchb(cr);
        goto e;
    }
    if ((char)c == (char)(esc2)) c='#';
    if(vilcasef) {
      vineed = 1;
      if( c>= 'A' && c<= 'Z' ) c= c+'a'-'A';
      else if( RLPRO(c))  c= c+'б'-'Б';
      else if( c=='`')  c='\'';
      else if( c=='|')  c='!';
      else if( c=='}')  c=')';
      else if( c=='{')  c='(';
      else if( c=='~')  c='^';
      else vineed = 0;
      if( vineed != vicase) putcha((vicase=vineed)?COVIOPE:COVICLO);
      }
      if ( c >= G_START && c <= G_END)
	{
	if( c < G_START + gchars ) { c = g_table[(c) - G_START];
		needgraph = 1;
		}
		else {
		c = g0table[c-G_START];
		needgraph = 0;
		}
	 } else needgraph = 0;
	 if ( needgraph != graphcase ) putcha(COGSTART + graphcase);
	  graphcase = needgraph;
#ifdef RED_CYRILL
    if( Rcyflag ) {
	if (iscyrill(c) ) {
		if(!Cyout) putcha(COCYON);
			   Cyout= 1;
			   c = OUTT(c);
		}
	else if( !isanychr(c) && Cyout) {
			   putcha(COCYOFF);
			   Cyout=0;
	       }
    }
#endif
#ifdef LCASEO
    if ( lcasef0 && !vilcasef ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
#endif
    putcbuf[iputcbuf++] = c;
    if (iputcbuf >= NPUTCBUF) dumpcbuf();
e:
    return(1);
}

/*
 * putchb(c) -
 * Вывод символа без в безусловном режиме
 */
putchb(c)
char c;
{
#ifdef LCASEO
    if ( lcasef0 ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
#endif
    putcbuf[iputcbuf++] = c;
    if (iputcbuf >= NPUTCBUF) dumpcbuf();
    return;
}

/*
 * putblanks(k) -
 * Вывод строки пробелов
 */
putblanks(k)
register int k;
{       cursorcol += k;
    setatr(A_NORM);
    while (k--) {
        putcbuf[iputcbuf++] = ' ';
        if(iputcbuf == NPUTCBUF)  dumpcbuf();
    }
    dumpcbuf(); return;
}

/*
 * dumpcbuf() -
 * выталкивание буфера вывода
 */
dumpcbuf()
{
	if (iputcbuf != 0) write(2,putcbuf,iputcbuf);
	iputcbuf = 0;
}

setatr(atr)
int atr;
{
 register int i = NUMA(atr);
 if ( i != cur_atr && i <= COAOUT ) putcha(i);
 cur_atr = atr;
}

/*
 * readch()
 * Чтение очередного символа с терминала.
 * Кроме того, здесь же разворачиваются макро и
 * происходит чтение из файла протокола.   Последние две
 * функции будут убраны повыше.
 * Переменные:
 * oldchar - символ, возвращенный для повторного чтения п/п unread1()
 * ps_inmac - указатель на читаемое макро
 * ps_exin - указатель на читаемое расширение символа
 * (*pf_wmac)() - текущая запись в макро, она же отрабатывает CCQUIT в конце
 * litchar - признак (след. символ - литерал)
 * rmacl(name) - дает макро по имени
 */
char *ps_inmac, *ps_exin;
int (*pf_wmac)();
char *rmacl();
static short litchar;
static int oldchar  = -1;
char *rmacl();

int readch()
{
#define GETSY1(c,g) if(read(inputfile,&c,1) != 1) goto g; else
	register int lc;
	char sy;
	if(oldchar != -1) { 
		lc = oldchar; 
		oldchar = -1; 
		return(lc); 
	}
	dumpcbuf();
rmacro:
    if( ps_inmac) {
	lc = (*ps_inmac++) &0377;
	if(*ps_inmac == 0) ps_inmac = NULL;
	goto w_macro;
	}
    if(inputfile && (lc = readfc()) != -1) goto w_macro;
r_exin:
    if( ps_exin) {
	lc = (*ps_exin++) &0377;
	if(*ps_exin == 0) ps_exin = NULL;
	goto w_proto;
	}
/*
 * Чтение очередного символа
 */
new:
#ifdef RED_CYRILL
    if (Rcyflag && Cyin != Cyout )
	{ putcha(COCYON + 1 - Cyin); Cyout = Cyin; dumpcbuf();}
#endif RED_CYRILL
    intrflag = 0;
    GETSY1(sy, readquit);
    lc = sy & 0377;
    if(litchar) {
	if( lc < 040)
		lc = (lc&037)|'@@';
	litchar = 0;
	goto w_proto;
	}
#ifdef RED_CYRILL
    if ( Rcyflag) {
	lc &= 0177;
	if( lc==CHA_RUS) {Cyin=1; goto new; }
	if( lc==CHA_LAT) {Cyin=0; goto new; }
	if( Cyin==1 && lc >= 040 && lc < 0177) lc = INTT(lc);
    }
#endif RED_CYRIILL
    if( ISCTRL(lc)) {
	int *i1,*i2, ts, k;
	i1=i2=0;
	ts=0;
	sy=lc;
	while ((k=findt(&i1,&i2,sy,ts++))== CONTF)
	{
	    GETSY1(sy,readquit);
	    if(sy&0200) sy = STASCII(cy40bit?(sy^040):sy);
	}
	if ( k== BADF) {
	    int flag=FREAD; putcha(COBELL); dumpcbuf();
	    ioctl(inputfile,TIOCFLUSH,&flag);goto new;
	}
	lc=k;
	if (lc == CCMAC) {
	    GETSY1(sy, readquit);
	    if(sy&0200) sy = STASCII(cy40bit?(sy^040):sy);
	    if(sy >= 'a' && sy <='z')
		{
		lc = (int)sy - 'a' + CCMAC+1;
		} else goto new;
	    }
	    goto w_proto;
    }
    /* ========================================================= */
    /* Преобразование символов при вводе в lcase */
    if((lcasef||latf) && (lc >= '@@'))
    {
#define LBUFWSY 5
	static char bufwsy[LBUFWSY+1];
        char bufr[2], *si=bufr, *so=bufwsy;
	int i;
#ifndef MNOS
#ifndef LCASEO
	if(lcasef&&(lc>=0300)) lc ^= 040; /* из?за драйвера*/
#endif
#endif
	i=1;
	bufr[0]=lc;
	exinss(&si, si+1, &so, &i, LBUFWSY-1);
	*so=0;
	lc=((int)bufwsy[0])&0377;
	if(so!= bufwsy+1) ps_exin = bufwsy+1;
    }
/*
 * Точки выхода из подпрограммы
 */
w_proto:
    if(ttyfile > 0) {
	sy = lc;
	write(ttyfile,&sy, 1);
	}
/*
 * Отработка некоторых кодов
 */
    if(lc > CCMAC && lc <= CCEMAC)
	{
	ps_inmac = rmacl(lc);
	if(ps_inmac) goto rmacro;
	else goto new;
	}
    if( lc == CCCTRLQUOTE) {
	litchar = 1;
	}
w_macro:
    if(pf_wmac) {
	if( ((*pf_wmac)(lc))  == 0) goto new; /* Символ с'ели */;
	}
    return(lc);
readquit:
    if(intrflag){
	lc=CCENTER;
	intrflag=0;
    }   else
	lc=CCQUIT;
    goto w_proto;
}

unread1(ch)
int ch;
{
oldchar = ch&0377;
}

static int isy0f = -1;
/*
 * readfc()
 * - получение символа из файла протокола
 *   возвращается 0, если файл кончился
 */
readfc()
{
    char sy1 = CCQUIT;
    register int lread1;
    do {
        lread1=isy0f;
        if ( intrflag || (read(inputfile,&sy1,1) !=1))
        {
            if(inputfile != ttyfile) close (inputfile);
            else  lseek(ttyfile,(long)(-1),1);
            inputfile=0;
            intrflag=0; 
            putcha(COBELL);
            dumpcbuf();
	    return (-1);
        }
        isy0f = ((int)sy1) & 0377;
    }
    while (lread1<0);
    return (lread1);
}

/*
 * intrup() -
 *       опрос, не было ли прерывания.
 */
intrup()
{       
    char sy1;
    if( inputfile ){
        if(isy0f == CCINTRUP ){
            isy0f= -1;
            return(1);
        }
        else return(0);
    }
    else
    {
        if(intrflag){
            intrflag=0;
            sy1=CCINTRUP;
            write(ttyfile,&sy1,1);
            return(1);
        }
        return(0);
    }
}

#define CCDEL 0177
/* read2() -
 *     функция, читающая входные символы
 *     без их анализа.  Используется при
 *     переопределении клавиш.
 */
read2()
{
    char c;
    register int lread1;
    if (inputfile && (lread1=readfc())!= -1) return(lread1);
    if (read(0,&c,1) != 1) {
        c=CCDEL;
        intrflag = 0;
    }
    c &= 0177;
    write(ttyfile,&c,1);
    return(c);
}

/*
 * writefile -
 * Записать команду с аргументами в файл протокола
 */

writefile(code1,str,code2)
int code1, code2;
char *str;
{
	char cd1=code1, cd2=code2;
	write(ttyfile,&cd1,1);
	for(;*str;str++) write(ttyfile,str,1);
	write(ttyfile,&cd2,1);
}

/*
 * findt (&fb,&fe,sy,ns) -
 * Поиск кода клавиши.
 * struct ex_int * (fb , fe) = NULL при подаче
 * первого символа с данной клавиши.
 * Дальше они используются при поиске кода.
 * Коды ответа:
 * CONTF - дай следующий символ,
 * BADF  - такой последовательности нет в таблице,
 * >=0   - код команды.
 */
short kioutf;
/*VARARGS*/
findt (fb,fe,sy,ns)
struct ex_int **fb, **fe; 
char sy; 
int ns;
{ 
    char sy1; 
    register struct ex_int  *fi;
    fi=( *fb? *fb:inctab);  
    *fb=0;
    if (sy==0) return BADF;
    if(kioutf&& (sy&0100)) sy |= 0240; /* Не различаем регистр букв */
    for (;(fi!= *fe); fi++ )
    {
        if (!(*fe) && !(fi->excc) ) goto exit;
        sy1=fi->excc[ns];
        if(kioutf&& (sy1&0100)) sy1 |= 0240; /* Не различаем регистр букв */
        if ( *fb) { 
            if (sy!=sy1) goto exit;
        }
        else { 
            if (sy==sy1) {  
                *fb=fi;
            }
        }
    }
exit: 
    *fe=fi; /* for "addkey" */
    if (! *fb) return BADF;
    fi= *fb;
    if(fi->excc[ns+1]) return CONTF;
    return ( fi->incc);
}

/* Тест findt
 main()
  { char *s = "\017abz"; int i,j,k,l,m,is;
	i=j=k=l=m=0;
	for(is=0;*s; is++)
	{ k=findt(&i,&j,*s++,l++); if(k!=CONTF) goto ex1; }
ex1:   printf(" k= %d is= %d pt %o %o ", k,is,i,j);
  }
 t(i) int i; {return;}
 */

/*
 * addkey(cmd,key) -
 * добавления новой управляющей клавиши
 *      в таблицу кодов
 */
extern int nfinc; /* число свободных мест в таблице */
addkey(cmd,key)
int cmd; 
char *key;
{ 
    struct ex_int *fb,*fe; 
    register struct ex_int *fw;
    register int ns,i;
    ns=0; 
    fb = fe = 0;
    while((i=findt(&fb,&fe,key[ns],ns))==CONTF && key[ns++]);
    if(i != BADF)
    {
        telluser(DIAG("key redefined","переопределение"),0);
        fw = fb; 
        goto retn;
    }
    /* Код новый = нужно расширить таблицу */
    if (!nfinc) {
        error(DIAG("too many key's","много определений"));
        return(0);
    }
    fw = fe;nfinc--;
    while((fw++)->excc);
    do{
        *fw = *(fw-1);
    } 
    while(--fw != fe);
retn:   
#ifdef TEST
test("addkey out");
#endif
	fw ->excc = key; 
	fw->incc = cmd;
	return(1);
}
#ifdef TEST
test(s) char *s;
{printf("test: %s\n",s); return(0);}
#endif

/*
 * scroll(n,bl) - прокрутить экран на n строк вверх (вниз), начиная со
 * строки bl. bl <0 == bl = -1-bl,но особый случай - не прокрутить, а удалить
 * выдается 0, если не сделано, иначе 1
 */
scroll(n,bl)
int n,bl;
{
	register int i;
	int dll,ill,nl;
	int no_sf;      /* Флаг - признак запрета сдвига по sf */
#define PUTCC(c,n) for(i= n;i>0;i--) putcha(c)
	if(!(curport->flags&WF_ROLL)) {
		/*
		 * Установить признак возможности roll
		 */
		i=WF_NROLL;
		if(!can_scroll) goto ex;
		if(curport->lmarg != 0 || curport->rmarg != wholescreen.rmarg) goto ex;
		if(can_scroll == ROLL_SF
		    && (curport->tmarg != 0
		    || curport->bmarg != wholescreen.bmarg - NPARAMLINES)) goto ex;
		i = WF_YROLL;
ex: 
		curport->flags |= i;
	}
	if(!(curport->flags & WF_YROLL) ) return(0);
	if ( n == 0 ) return(1);
	no_sf = 0;
	if (bl < 0 ) { no_sf = 1; bl = -bl -1; }
	if( n+bl>curport->btext-2 || -n+bl > curport->btext-2) return(0);
	switch(can_scroll) {
	case ROLL_CS:
		if(!setscroll(curport,bl))  return(0);
		if(n>0) {
			poscursor(0, curport->btext);
			PUTCC(COSRFWD,n);
		} 
		else {
			poscursor(0,bl);
			PUTCC(COSRBAK, -n);
		}
		if (bl) setscroll(curport,0);
		break;
	case ROLL_IL:
		if(n>0) {
			nl=n;
			dll=bl;
			ill=curport->btext - nl+1;
		}
		else
		{
			nl = -n;
			dll = curport->btext - nl+1;
			ill=bl;
		}
		poscursor(0,dll);
		PUTCC(CODELIN,nl);
		poscursor(0,ill);
		PUTCC(COILINE,nl);
		break;
	case ROLL_SF:
		if(no_sf) return(0);
		{
			register struct viewport *w;
			w = curport;
			if ( n > 0 )
			{
				switchport(&wholescreen);
				poscursor(0,wholescreen.bmarg);
				PUTCC(COSRFWD,n);
				switchport(w);
				if(need_box != 2 )
				{
					poscursor(-w->ltext, w->btext-n+1);
					putcha(COCLSCR);
				}
			} 
			else {
				if(need_box != 2 )
				{
					poscursor(-w->ltext,w->btext+n+1);
					putcha(COCLSCR);
				}
				switchport(&wholescreen);
				poscursor(0,0);
				for(i= -n; i; i--)
					putcha(COCLLIN), putcha(COSRBAK);
				switchport(w);
			}
			need_box = (n==1||n== -1)?1:2;
			new_info = 1;
			break;
		}
	default: 
		return(0);
	}
	shiftview(bl,n);
	return(1);
}

/*
 * setscroll(viewp,begl) - установка границ роллинга экрана
 * на область text данного окна
 * начиная со строки begl
 */
setscroll(viewp,begl)
register struct viewport *viewp;
{
	register char *c;
	extern char *tgoto();
	struct viewport *cp;
	register l0, l1;
	l0 = viewp->ttext;
	l1 = viewp->btext + l0;
	l0 += begl;
	if (l0 >= l1) return(0); /* Терминалы не допускают cs на 1 строку */
	if(n0scroll==l0 && n1scroll==l1)
		return(1);
	if( !ch_scroll) return(0);
	c= tgoto(ch_scroll,  l1, l0);
	if(!c) return(0);
	cp = curport;
	switchport(&wholescreen);
	while(*c) putchb(*c++);
	putcha(COHO);
	cursorcol = cursorline = 0;
	switchport(cp);
	n0scroll = l0;
	n1scroll = l1;
	return(1);
}
@


4.5
log
@Очередная правка в роллировании.
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 4.4 88/04/07 12:02:13 alex Exp $
d6 3
d821 1
d832 1
d837 1
a837 1
	switchport(viewp);
@


4.4
log
@Исправили ошибку в работе setscroll.
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 4.3 88/04/04 22:16:14 alex Exp $
d6 3
d717 1
d735 2
a739 1
		if(bl<0) bl = -1-bl;
a751 1
		if(bl<0) bl = -1-bl;
d769 1
a769 1
		if(bl != 0) return(0);
@


4.3
log
@Исправлена ошибка в работе при расщеплении строки (режим CS).
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 4.2 88/03/31 22:50:29 alex Exp $
d6 3
d818 1
@


4.2
log
@Исправлена ошибка при работе на терминале Электроника.
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 4.1 88/03/31 22:06:09 alex Exp $
d6 3
d301 1
a301 1
    if (iputcbuf == NPUTCBUF) dumpcbuf();
d317 1
a317 1
    if (iputcbuf == NPUTCBUF) dumpcbuf();
d732 1
a732 2
		if(n0scroll != curport->ttext || n1scroll != curport->btext)
			if(!setscroll(curport,bl))  return(0);
d741 1
d811 6
d818 1
a818 1
	c= tgoto(ch_scroll,  viewp->ttext + viewp->btext, viewp->ttext+begl);
d825 2
a828 1

@


4.1
log
@Версия 4.1 - обкатка на UTEC, СМ
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.17 88/03/30 17:25:07 alex Exp $
d6 3
d700 1
a700 1
 * строки bl
d728 1
d741 1
@


3.17
log
@Исправлена ошибка в readch. Введены функции для удаления/вставки
строк на экране через ChangeScroll/InsertLine-DeleteLine.
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.1.2.5 87/07/09 20:44:11 alex Exp $
d6 4
d714 1
a714 1
		    && (curport->tmarg != 0  || bl != 0
d754 1
@


3.16
log
@Исправлены ошибки в режиме vilcase и мелочи для vt-200
@
text
@d2 2
a3 2
 *      Редактор RED. ИАЭ им. И.В. Курчатова, ОС ДЕМОС
 *       $Header: S.ttyio.c,v 3.15 87/06/09 19:45:28 alex Exp $
d6 18
d124 1
a124 1
    ioctl(0,TIOCGETC, &tchars0);
d128 1
a128 1
    ioctl(0,TIOCSETC, &tcharsw);
d131 1
a131 1
    ioctl(0,TIOCGLTC,&tmpltc);
d134 1
a134 1
    ioctl(0,TIOCSLTC,&tmpltc);
d136 1
a136 1
    gtty(0,&templ);
d176 1
a176 1
    stty(0,&templw);
d185 6
a190 1
    stty(0,&templ);
d192 1
a192 1
    ioctl(0,TIOCSLTC, &oldltc);
d195 1
a195 1
    ioctl(0,TIOCSETC, &tchars0);
d236 1
a236 1
char c;
d240 6
a245 5
    short vineed;
    cr=c & 0177;
    if (cr>=0 && cr<=COMCOD) {
	if( cr == COSTART) n0scroll = n1scroll = -1;
        if(!(s=cvtout[cr])) return(0);
d262 12
d318 1
d336 7
d345 2
a346 2
 * read1()
 * Чтание очередного символа с терминала.
d350 7
a356 1
 * Ответ приходит в lread1.
d358 2
d361 5
a365 6
#define LBUFWSY 5
static char *sy0, knockdown=0, bufwsy[LBUFWSY];
extern char escch1, in0tab[];
int
read1()
#define GETSY1 if(read(inputfile,&sy1,1)!=1) goto readquit;
d367 25
a391 28
    char sy1;
    int i,cntf=0;
    register int *lr1 = &lread1;
#define lread1 (*lr1)   /* Для ускорения */
    dumpcbuf();
    /* Если остался неиспользованным символ */
    if (lread1 != -1) goto retnl;
    /* Если еще не кончилось макро-расширение */
rmac:
    if (symac) {
        lread1= *symac++;
        if(*symac==0) symac=0;
        goto retnl;
    }
    /* Если идет чтение из файла */
    if (inputfile!=0 && readfc())
        goto retnm;
    /*
     * Ниже - то, что относится к терминалу
     * =====================================
     */
    /* Было преобразование и символы не кончились */
    if (sy0!=0) {
        lread1= *sy0++;
        if(*sy0==0) sy0=0;
        goto retn;
    }
    /* Чтение с клавиатуры */
d397 9
a405 9
    intrflag=0;
    GETSY1;
    /* Если символ не управляющий */
    lread1=sy1;  
    if(lread1==0177) {
        lread1=CCBACKSPACE; 
        goto readycchr;
    }
    lread1 &= 0377;
d408 4
a411 4
	lread1 &= 0177;
	if( lread1==CHA_RUS) {Cyin=1; goto new; }
	if( lread1==CHA_LAT) {Cyin=0; goto new; }
	if( Cyin==1 && lread1 >= 040) lread1 = INTT(lread1);
d414 24
a437 4
    if ((lread1&0177) > 037) goto readychr;
    if (knockdown) {
        lread1 += 0100;
        goto readycchr;
a438 60
    /* Если символ - спец. признак? */
    if (lread1==escch1)
    {
        GETSY1;
        switch (sy1)
        {
        case '\177': 
            lread1=CCQUIT; 
            goto readycchr;
        case '+':;
        case ';':
            lread1=CCPLLINE;
            goto readycchr;
        case '-':;
        case '=':
            lread1=CCMILINE;
            goto readycchr;
        case '.':;
        case '>':
            lread1=CCGOTO;
            goto readycchr;
        case ' ':
            lread1=CCENTER;
            goto readycchr;
        case '$':
rmacname:               
            GETSY1; 
	    if(sy1&0200) sy1 = STASCII(cy40bit?(sy1^040):sy1);
            if(sy1 >= 'a' && sy1 <='z')
	    {
		lread1 = (int)sy1 - 'a' + CCMAC+1;
                goto readycchr;
            }
            goto new;
        default:
            ;
        }
        lread1=((int)sy1)&037;
        goto corrcntr;
    }
    /* Веден управляющий символ - ищем команду в таблице */
    {
        int *i1,*i2, ts, k;
        i1=i2=0;
        ts=0;
        sy1=lread1;
        while ((k=findt(&i1,&i2,sy1,ts++))== CONTF)
        {
            GETSY1;
	    if(sy1&0200) sy1 = STASCII(cy40bit?(sy1^040):sy1);
        }
        if ( k== BADF) {
            if (ts==1) goto corrcntr;
	    else { int flag=FREAD; putcha(COBELL); dumpcbuf();
		 ioctl(inputfile,TIOCFLUSH,&flag);goto new;}
        }
        lread1=k;  
        if (lread1 == CCMAC) goto rmacname;
        goto readycchr;
    }
d440 2
a441 11
corrcntr:
    if (lread1>0 && lread1<=BT) lread1=in0tab[lread1-1];
readycchr:
    cntf=1;
readychr:
    if (lread1==-1) goto new;
    if (lread1==0177) {
        cntf=1;
    }
    knockdown=0;
    if (lread1==CCCTRLQUOTE)
d443 2
a444 4
        knockdown=1;
    }
    if(!cntf && (lcasef||latf) && (lread1>='@@'))
    {
d446 1
d449 1
a449 1
        if(lcasef&&(lread1>=0300)) lread1 ^= 040; /* из?за драйвера*/
d452 6
a457 6
        i=1;
        bufr[0]=lread1;
        exinss(&si, si+1, &so, &i, LBUFWSY-1);
        *so=0;
        lread1=((int)bufwsy[0])&0377;
        if(so!= bufwsy+1) sy0=bufwsy+1;
d459 25
a483 12
retn:
    sy1=lread1;
    write (ttyfile,&sy1,1); /* ATTENSION - ONLY 8 BIT */
    /*
     * Конец того, что относится к терминалу (до quit).
     * ================================================
     */
retnm:
    if( lread1 >CCMAC && lread1 <= CCMAC+1+'z'-'a' && (symac=rmacl(lread1)))
        goto rmac;
retnl:
    return (lread1);
d486 5
a490 6
        lread1=CCENTER;
        intrflag=0;
        goto readycchr;
    }
    lread1=CCQUIT;
    goto readycchr;
a491 1
#undef lread1
d493 6
d508 1
d519 1
a519 1
            return 0;
d524 1
a524 1
    return (1);
d562 2
a563 1
    if (inputfile && readfc()) return(lread1);
d692 2
a693 1
 * scroll(n) - прокрутить экран на n строк вверх (вниз)
d696 2
a697 2
scroll(n)
int n;
d710 1
a710 1
		    && (curport->tmarg != 0
d718 1
a718 1
	if( n>curport->btext-2 || -n > curport->btext-2) return(0);
d722 1
a722 1
			if(!setscroll(curport))  return(0);
d728 1
a728 1
			poscursor(0,0);
d735 1
a735 1
			dll=0;
d742 1
a742 1
			ill=0;
d784 1
a784 1
	shiftview(0,n);
d789 1
a789 1
 * setscroll(viewp) - установка границ роллинга экрана
d791 1
d793 1
a793 1
setscroll(viewp)
d799 1
a799 1
	c= tgoto(ch_scroll,  viewp->ttext + viewp->btext, viewp->ttext);
@


3.15
log
@Добавлен roll для терминалов с sr/sf и отображение
 табуляций в режиме -t + всякая мелочь
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.14 87/06/05 23:48:29 alex Exp $
d6 3
d86 3
a106 1
/*  printf("TIOCGETC %o\n", &tchars0);  */
d109 1
a109 1
    tcharsw.t_eofc=tcharsw.t_quitc= -1;
a110 1
/*  printf("TIOCSETC %o\n", &tcharsw);  */
d112 6
d149 1
d153 1
a153 1
#ifdef LFLUSHO
d156 1
a158 1
/*  printf("STTY %o\n", &templw);       */
d168 3
d225 1
a225 1
    if(c == esc2) c = '#';
d252 1
a252 1
    if ( lcasef0 ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
d741 2
a742 1
				if(need_box != 2) {
d748 2
a749 1
				if(need_box != 2) {
@


3.14
log
@Добавлен roll для терминалов с sr/sf и отображение
 табуляций в режиме -t + всякая мелочь
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.13 87/06/04 23:41:52 alex Exp $
d6 4
d142 2
d145 1
d211 1
d727 4
a730 2
				poscursor(-w->ltext, w->btext-n+1);
				putcha(COCLSCR);
d733 4
a736 2
				poscursor(-w->ltext,w->btext+n+1);
				putcha(COCLSCR);
@


3.13
log
@Scroll on -sr- or -al/dl- added
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.12 87/04/21 22:46:30 alex Exp $
d6 3
d682 1
a682 1
		      if(!setscroll(curport))  return(0);
d709 26
@


3.12
log
@Debug
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.11 87/04/21 22:28:57 alex Exp $
d6 3
d10 1
a10 1
 * iSPRAWLENA O[IBKA W writefile.
d196 1
d648 85
@


3.11
log
@iSPRAWLENA O[IBKA W writefile.
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.10 87/04/02 18:29:44 alex Exp $
d6 3
a77 1
#undef printf
d91 1
a91 1
    printf("TIOCGETC %o\n", &tchars0);
d96 1
a96 1
    printf("TIOCSETC %o\n", &tcharsw);
d99 1
a99 1
    printf("GTTY %o\n", &templ);
d134 1
a134 1
    printf("STTY %o\n", &templw);
@


3.10
log
@Версия для Utec слита с версией с выделением прописных букв
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.9 87/04/01 19:14:19 alex Exp $
d6 3
d75 2
d83 1
a83 1
    struct sgttyb templw;
d85 1
a85 1
    struct tchars tcharsw;
d89 1
d94 1
d97 1
d132 1
d534 2
a535 1
	write(ttyfile,&code1,1);
d537 1
a537 1
	write(ttyfile,&code2,1);
@


3.9
log
@проведены правки для выделения заглавных букв по vs
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.8 86/11/25 08:06:26 alex Exp $
d6 3
a81 11
    if(atcread)
    {   register int i;
	i=(*atcread)();
	if(i) {
	    printf1((i==1?
	    DIAG("unknown term capabilities\n please, type \n  TERM=<type>;export TERM \n and repeat red\n","Не задано описание возможностей терминала, \n наберите TERM=тип;export TERM и повторите вызов"):
	    DIAG("re can not work with this terminal\n","red не может работать с этим терминалом")));
	    exit(1);
	}
    }
    atcread = (int (*)())NULL;
d100 11
d113 3
a115 3
    if(lcasef && cvtout[COVIOP] ) {
	vilcasef = 1; lcasef = 0;
    }
d187 24
a210 11
	vineed = 1;
	if( c>= 'A' && c<= 'Z' ) c= c+'a'-'A';
	else if( RLPRO(c))  c= c+'б'-'Б';
	else if( c=='`')  c='\'';
	else if( c=='|')  c='!';
	else if( c=='}')  c=')';
	else if( c=='{')  c='(';
	else if( c=='~')  c='^';
	else vineed = 0;
	if( vineed != vicase) putcha((vicase=vineed)?COVIOP:COVICL);
	}
d212 1
a212 2
    else
    if ( lcasef0  ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
d274 1
a274 1
#define GETSY1 if(read(inputfile,&sy1,1)!=1) goto readquit;if(rawf)sy1=sy1&0177;
d305 4
d318 8
d360 2
a361 2
            { 
                lread1 = (int)sy1 - 'a' + CCMAC+1;
d406 1
a406 1
    if(!cntf && !rawf && (lcasef||latf) && (lread1>='@@'))
d541 1
a541 1
char kioutf;
@


3.8
log
@Исправлено ioctl(..,TIOCFLUSH,&flag)
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.7 86/10/29 02:46:37 root Exp $
d6 3
d68 1
d110 3
d175 2
d183 12
d196 2
a197 1
    if ( lcasef0 ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
@


3.7
log
@При неверной escape-последовательности сбратываем всю очередь ввода.
Сделано для борьбы с пропаданием символов.
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.6 86/10/14 23:02:52 alex Exp $
d6 4
d335 2
a336 1
	    else { ioctl(inputfile,TIOCFLUSH,FREAD);goto new;}
@


3.6
log
@Исправлены ошибки с: RUSDIAG (не описан latdiag), и с LCASEO
(KI40BIT нужно задавать так, чтобы при lcasef была 1).
В СМ-1700 было 2 ошибки, в рез. все работало на LCASE правильно.
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.5 86/09/19 21:39:35 alex Exp $
d6 5
d37 2
d331 1
a331 1
            else goto new;
@


3.5
log
@
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.4 86/09/19 19:59:39 alex Exp $
d6 3
d51 3
a53 1

d85 1
a85 1
    lcasef=LCFLG(templ.sg_flags);
d90 3
d164 1
a164 1
    if ( lcasef ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
d180 1
a180 1
    if ( lcasef ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
d298 1
a298 1
            if(sy1&0200) sy1 = STASCII(sy1);
d320 1
a320 1
            if(sy1&0200) sy1= STASCII(sy1);
@


3.4
log
@Версия для СМ-1700
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.3 86/08/04 20:55:13 alex Exp $
d6 3
d69 1
d82 1
d90 3
@


3.3
log
@Bepqh dk LMNQ/DELNQ 2
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.2 86/07/24 19:07:48 alex Exp $
d5 4
a8 1
 *      $Log:   S.ttyio.c,v $
d33 2
a34 2
#ifdef TIOCSETB /* Признак ДЕМОС-2 */
#define sgttyb sgttyb1
d77 1
d147 4
a150 1
    putcbuf[iputcbuf++] =( rawf || latf || lcasef ? c&0177 : c );
d163 4
a166 1
    putcbuf[iputcbuf++] = c&0177;
d333 1
d335 1
@


3.2
log
@Об'единены версии текстов для ЕС и СМ
@
text
@d3 1
a3 1
 *       $Header: r.ttyio.c,v 3.1 86/04/20 23:43:21 alex Exp $
d5 4
a8 1
 *      $Log:	r.ttyio.c,v $
d11 1
a11 1
 * 
d14 1
a14 1
 * 
d30 4
a40 3
#ifdef TIOCGETC
struct tchars tchars0;
#endif
d52 1
d55 7
a61 7
        i=(*atcread)();
        if(i) {
            printf1((i==1?
            DIAG("unknown term capabilities\n please, type \n  TERM=<type>;export TERM \n and repeat red\n","Не задано описание возможностей терминала, \n наберите TERM=тип;export TERM и повторите вызов"):
            DIAG("re can not work with this terminal\n","red не может работать с этим терминалом")));
            exit(1);
        }
d63 1
@


3.1
log
@Базовая версия для ЕС.
@
text
@d7 3
d18 1
a18 1
#include "r.tele.h"
d48 10
d421 4
d426 8
@


3.1.2.1
log
@Start revision for red/4
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.16 87/06/12 18:07:21 alex Exp $
d5 1
a5 50
 *      $Log:	S.ttyio.c,v $
 * Revision 3.16  87/06/12  18:07:21  alex
 * Исправлены ошибки в режиме vilcase и мелочи для vt-200
 * 
 * Revision 3.15  87/06/09  19:45:28  alex
 * Исправлена работа с tty ~ VT200 и 15-ИЭ-0013
 * 
 * Revision 3.14  87/06/05  23:48:29  alex
 * Добавлен roll для терминалов с sr/sf и отображение
 *  табуляций в режиме -t + всякая мелочь
 * 
 * Revision 3.13  87/06/04  23:41:52  alex
 * Scroll on -sr- or -al/dl- added
 * 
 * Revision 3.12  87/04/21  22:46:30  alex
 * Debug
 * 
 * Revision 3.11  87/04/21  22:28:57  alex
 * Исправлена ошибка в writefile.
 * 
 * Revision 3.10  87/04/02  18:29:44  alex
 * Версия для Utec слита с версией с выделением прописных букв
 * 
 * Revision 3.9  87/04/01  19:14:19  alex
 * Revision for Utec: Cs, Ce, Ct, hR
 * 
 * Revision 3.8  86/11/25  08:06:26  alex
 * Исправлено ioctl(..,TIOCFLUSH,&flag)
 * 
 * Revision 3.7  86/10/29  02:46:37  root
 * При неверной escape-последовательности сбратываем всю очередь ввода.
 * Сделано для борьбы с пропаданием символов.
 * 
 * Revision 3.6  86/10/14  23:02:52  alex
 * Исправлены ошибки с: RUSDIAG (не описан latdiag), и с LCASEO
 * (KI40BIT нужно задавать так, чтобы при lcasef была 1).
 * В СМ-1700 было 2 ошибки, в рез. все работало на LCASE правильно.
 * 
 * Revision 3.5  86/09/19  21:39:35  alex
 * 
 * 
 * Revision 3.4  86/09/19  19:59:39  alex
 * Версия для СМ-1700
 * 
 * Revision 3.3  86/08/04  20:55:13  alex
 * Bepqh dk LMNQ/DELNQ 2
 * 
 * Revision 3.2  86/07/24  19:07:48  alex
 * Об'единены версии текстов для ЕС и СМ
 *
a6 3
 * Базовая версия для ЕС.
 *
 * Revision 3.1  86/04/20  23:43:21  alex
d8 1
a8 1
 *
d15 1
a15 1
#include "S.tele.h"
a16 2
#include <sys/types.h>
#include <sys/file.h>
a23 4
#ifdef SGTTYB /* Признак ДЕМОС-2 */
#define sgttyb SGTTYB
#endif

d31 2
a32 2
#ifdef TIOCSLTC
static struct ltchars tmpltc,oldltc;
a34 4
short cy40bit; /* Для переворота в упр. последовательностях */
short lcasef0; /* Внутренний признак lcase для вывода */
short latdiag;
short vilcasef;
d42 1
a42 1
    static struct sgttyb templw;
d44 1
a44 3
    static struct tchars tcharsw;
#endif
#ifdef TIOCGETC
d48 1
a48 1
    tcharsw.t_quitc = -1;
a50 6
#ifdef TIOCSLTC
    ioctl(0,TIOCGLTC,&tmpltc);
    oldltc = tmpltc;
    tmpltc.t_suspc = tmpltc.t_dsuspc = tmpltc.t_flushc = -1;
    ioctl(0,TIOCSLTC,&tmpltc);
#endif
a51 1
/*  printf("GTTY %o\n", &templ);        */
d54 1
a54 3
    lcasef=lcasef0=LCFLG(templ.sg_flags);
    latf = LATFLG(templ.sg_flags);
    if ( latf ) latdiag = 1;
a56 14
#ifdef KI40BIT
    cy40bit = KI40BIT(templ.sg_flags);
#endif
    if(atcread)
    {   register int i;
	i=(*atcread)();
	atcread = (int (*)())NULL;
	if(i) {
	    printf1((i==1?
	    DIAG("unknown term capabilities\n please, type \n  TERM=<type>;export TERM \n and repeat red\n","Не задано описание возможностей терминала, \n наберите TERM=тип;export TERM и повторите вызов"):
	    DIAG("re can not work with this terminal\n","red не может работать с этим терминалом")));
	    exit(1);
	}
    }
a58 3
     if(lcasef && cvtout[COVIOPE] ) {
       vilcasef = 1; lcasef = 0;
     }
a61 3
/*
#ifdef Y_SIGSTOP
    templw.sg_suspc = templw.sg_dsuspc = -1;
a62 5
#ifdef TIOCSLTC
    templw.sg_flushc = -1;
#endif
 */
#endif
a72 3
#ifdef TIOCSLTC
    ioctl(0,TIOCSLTC, &oldltc);
#endif
a117 2
    static short vicase=0;
    short vineed;
a119 1
	if( cr == COSTART) n0scroll = n1scroll = -1;
d124 1
a124 30
    if ((char)c == (char)(esc2)) c='#';
    if(vilcasef) {
      vineed = 1;
      if( c>= 'A' && c<= 'Z' ) c= c+'a'-'A';
      else if( RLPRO(c))  c= c+'б'-'Б';
      else if( c=='`')  c='\'';
      else if( c=='|')  c='!';
      else if( c=='}')  c=')';
      else if( c=='{')  c='(';
      else if( c=='~')  c='^';
      else vineed = 0;
      if( vineed != vicase) putcha((vicase=vineed)?COVIOPE:COVICLO);
      }
#ifdef RED_CYRILL
    if( Rcyflag ) {
	if (iscyrill(c) ) {
		if(!Cyout) putcha(COCYON);
			   Cyout= 1;
			   c = OUTT(c);
		}
	else if( !isanychr(c) && Cyout) {
			   putcha(COCYOFF);
			   Cyout=0;
	       }
    }
#endif
#ifdef LCASEO
    if ( lcasef0 && !vilcasef ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
#endif
    putcbuf[iputcbuf++] = c;
d137 1
a137 4
#ifdef LCASEO
    if ( lcasef0 ) c=(c>='A'&&c<='Z'?c+040:(c>= 0140 && c<= 0176?c+0140:c));
#endif
    putcbuf[iputcbuf++] = c;
d181 1
a181 1
#define GETSY1 if(read(inputfile,&sy1,1)!=1) goto readquit;
a211 4
#ifdef RED_CYRILL
    if (Rcyflag && Cyin != Cyout )
	{ putcha(COCYON + 1 - Cyin); Cyout = Cyin; dumpcbuf();}
#endif RED_CYRILL
a220 8
#ifdef RED_CYRILL
    if ( Rcyflag) {
	lread1 &= 0177;
	if( lread1==CHA_RUS) {Cyin=1; goto new; }
	if( lread1==CHA_LAT) {Cyin=0; goto new; }
	if( Cyin==1 && lread1 >= 040) lread1 = INTT(lread1);
    }
#endif RED_CYRIILL
d253 1
a253 1
	    if(sy1&0200) sy1 = STASCII(cy40bit?(sy1^040):sy1);
d255 2
a256 2
	    {
		lread1 = (int)sy1 - 'a' + CCMAC+1;
d275 1
a275 1
	    if(sy1&0200) sy1 = STASCII(cy40bit?(sy1^040):sy1);
d279 1
a279 2
	    else { int flag=FREAD; putcha(COBELL); dumpcbuf();
		 ioctl(inputfile,TIOCFLUSH,&flag);goto new;}
d300 1
a300 1
    if(!cntf && (lcasef||latf) && (lread1>='@@'))
a303 1
#ifndef LCASEO
a305 1
#endif
a407 4
/*
 * writefile -
 * Записать команду с аргументами в файл протокола
 */
a408 9
writefile(code1,str,code2)
int code1, code2;
char *str;
{
	char cd1=code1, cd2=code2;
	write(ttyfile,&cd1,1);
	for(;*str;str++) write(ttyfile,str,1);
	write(ttyfile,&cd2,1);
}
d421 1
a421 1
short kioutf;
a511 117

/*
 * scroll(n) - прокрутить экран на n строк вверх (вниз)
 * выдается 0, если не сделано, иначе 1
 */
scroll(n)
int n;
{
	register int i;
	int dll,ill,nl;
#define PUTCC(c,n) for(i= n;i>0;i--) putcha(c)
	if(!(curport->flags&WF_ROLL)) {
		/*
		 * Установить признак возможности roll
		 */
		i=WF_NROLL;
		if(!can_scroll) goto ex;
		if(curport->lmarg != 0 || curport->rmarg != wholescreen.rmarg) goto ex;
		if(can_scroll == ROLL_SF
		    && (curport->tmarg != 0
		    || curport->bmarg != wholescreen.bmarg - NPARAMLINES)) goto ex;
		i = WF_YROLL;
ex: 
		curport->flags |= i;
	}
	if(!(curport->flags & WF_YROLL) ) return(0);
	if ( n == 0 ) return(1);
	if( n>curport->btext-2 || -n > curport->btext-2) return(0);
	switch(can_scroll) {
	case ROLL_CS:
		if(n0scroll != curport->ttext || n1scroll != curport->btext)
			if(!setscroll(curport))  return(0);
		if(n>0) {
			poscursor(0, curport->btext);
			PUTCC(COSRFWD,n);
		} 
		else {
			poscursor(0,0);
			PUTCC(COSRBAK, -n);
		}
		break;
	case ROLL_IL:
		if(n>0) {
			nl=n;
			dll=0;
			ill=curport->btext - nl+1;
		}
		else
		{
			nl = -n;
			dll = curport->btext - nl+1;
			ill=0;
		}
		poscursor(0,dll);
		PUTCC(CODELIN,nl);
		poscursor(0,ill);
		PUTCC(COILINE,nl);
		break;
	case ROLL_SF:
		{
			register struct viewport *w;
			w = curport;
			if ( n > 0 )
			{
				switchport(&wholescreen);
				poscursor(0,wholescreen.bmarg);
				PUTCC(COSRFWD,n);
				switchport(w);
				if(need_box != 2 )
				{
					poscursor(-w->ltext, w->btext-n+1);
					putcha(COCLSCR);
				}
			} 
			else {
				if(need_box != 2 )
				{
					poscursor(-w->ltext,w->btext+n+1);
					putcha(COCLSCR);
				}
				switchport(&wholescreen);
				poscursor(0,0);
				for(i= -n; i; i--)
					putcha(COCLLIN), putcha(COSRBAK);
				switchport(w);
			}
			need_box = (n==1||n== -1)?1:2;
			new_info = 1;
			break;
		}
	default: 
		return(0);
	}
	shiftview(0,n);
	return(1);
}

/*
 * setscroll(viewp) - установка границ роллинга экрана
 * на область text данного окна
 */
setscroll(viewp)
register struct viewport *viewp;
{
	register char *c;
	extern char *tgoto();
	if( !ch_scroll) return(0);
	c= tgoto(ch_scroll,  viewp->ttext + viewp->btext, viewp->ttext);
	if(!c) return(0);
	switchport(&wholescreen);
	while(*c) putchb(*c++);
	putcha(COHO);
	cursorcol = cursorline = 0;
	switchport(viewp);
	return(1);
}

@


3.1.2.2
log
@wYNESENA PEREMENNAQ lread1 I \TO OTLAVENO
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.1.2.1 87/06/19 16:56:43 alex Exp $
a5 3
 * Revision 3.1.2.1  87/06/19  16:56:43  alex
 * Start revision for red/4
 * 
a302 6
static int oldchar  = -1;
unread1(ch)
int ch;
{
oldchar = ch&0377;
}
d304 1
a304 1
 * readch()
d309 1
d315 2
a316 1
int readch()
d321 2
a322 1
    register int lread1;
d325 1
a325 1
    if (oldchar != -1) { lread1 = oldchar; oldchar = -1; goto retnl;}
d334 1
a334 1
    if (inputfile!=0 && (lread1=readfc())!= -1)
a495 1
    register int lread1;
d506 1
a506 1
	    return (-1);
d511 1
a511 1
    return (lread1);
d549 1
a549 2
    register int lread1;
    if (inputfile && (lread1=readfc())!= -1) return(lread1);
@


3.1.2.3
log
@New readch + gettc + tc table Tested
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.1.2.2 87/06/23 18:55:33 alex Exp $
a5 3
 * Revision 3.1.2.2  87/06/23  18:55:33  alex
 * Выкинута lread1 как класс.
 * 
a172 4
    setscroll(&wholescreen);
    putcha(COFIN);
    dumpcbuf(0);
    printf("\n");
d306 6
a317 7
 * Переменные:
 * oldchar - символ, возвращенный для повторного чтения п/п unread1()
 * ps_inmac - указатель на читаемое макро
 * ps_exin - указатель на читаемое расширение символа
 * (*pf_wmac)() - текущая запись в макро, она же отрабатывает CCQUIT в конце
 * litchar - признак (след. символ - литерал)
 * rmacl(name) - дает макро по имени
a318 2
char *ps_inmac, *ps_exin;
int (*pf_wmac)();
d320 3
a322 4
static short litchar;
static int oldchar  = -1;
char *rmacl();

d324 1
d326 27
a352 25
#define GETSY1(c,g) if(read(inputfile,&c,1) != 1) goto g; else
	register int lc;
	char sy;
	if(oldchar != -1) { 
		lc = oldchar; 
		oldchar = -1; 
		return(lc); 
	}
	dumpcbuf();
rmacro:
    if( ps_inmac) {
	lc = (*ps_inmac++) &0377;
	if(*ps_inmac == 0) ps_inmac = NULL;
	goto w_macro;
	}
    if(inputfile && (lc = readfc()) != -1) goto w_macro;
r_exin:
    if( ps_exin) {
	lc = (*ps_exin++) &0377;
	if(*ps_exin == 0) ps_exin = NULL;
	goto w_proto;
	}
/*
 * Чтение очередного символа
 */
d358 9
a366 8
    intrflag = 0;
    GETSY1(sy, readquit);
    lc = sy & 0377;
    if(litchar) {
	lc = (lc&037)|'@@';
	litchar = 0;
	goto w_proto;
	}
d369 4
a372 4
	lc &= 0177;
	if( lc==CHA_RUS) {Cyin=1; goto new; }
	if( lc==CHA_LAT) {Cyin=0; goto new; }
	if( Cyin==1 && lc >= 040) lc = INTT(lc);
d375 4
a378 24
    if( ISCTRL(lc)) {
	int *i1,*i2, ts, k;
	i1=i2=0;
	ts=0;
	sy=lc;
	while ((k=findt(&i1,&i2,sy,ts++))== CONTF)
	{
	    GETSY1(sy,readquit);
	    if(sy&0200) sy = STASCII(cy40bit?(sy^040):sy);
	}
	if ( k== BADF) {
	    int flag=FREAD; putcha(COBELL); dumpcbuf();
	    ioctl(inputfile,TIOCFLUSH,&flag);goto new;
	}
	lc=k;
	if (lc == CCMAC) {
	    GETSY1(sy, readquit);
	    if(sy&0200) sy = STASCII(cy40bit?(sy^040):sy);
	    if(sy >= 'a' && sy <='z')
		{
		lc = (int)sy - 'a' + CCMAC+1;
		} else goto new;
	    }
	    goto w_proto;
d380 60
d441 11
a451 2
    /* Преобразование символов при вводе в lcase */
    if((lcasef||latf) && (lc >= '@@'))
d453 4
a456 2
#define LBUFWSY 5
	char bufwsy[LBUFWSY+1];
a457 1
	int i;
d460 1
a460 1
	if(lcasef&&(lc>=0300)) lc ^= 040; /* из?за драйвера*/
d463 6
a468 6
	i=1;
	bufr[0]=lc;
	exinss(&si, si+1, &so, &i, LBUFWSY-1);
	*so=0;
	lc=((int)bufwsy[0])&0377;
	if(so!= bufwsy+1) ps_exin = bufwsy+1;
d470 12
a481 25
/*
 * Точки выхода из подпрограммы
 */
w_proto:
    if(ttyfile > 0) {
	sy = lc;
	write(ttyfile,&sy, 1);
	}
/*
 * Отработка некоторых кодов
 */
    if(lc > CCMAC && lc <= CCEMAC)
	{
	ps_inmac = rmacl(lc);
	if(ps_inmac) goto rmacro;
	else goto new;
	}
    if( lc == CCCTRLQUOTE) {
	litchar = 1;
	}
w_macro:
    if(pf_wmac) {
	if( ((*pf_wmac)(lc))  == 0) goto new; /* Символ с'ели */;
	}
    return(lc);
d484 6
a489 5
	lc=CCENTER;
	intrflag=0;
    }   else
	lc=CCQUIT;
    goto w_proto;
d491 1
a491 6

unread1(ch)
int ch;
{
oldchar = ch&0377;
}
@


3.1.2.4
log
@Graph_characters used in margin
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.1.2.3 87/06/24 22:36:46 alex Stab $
a5 3
 * Revision 3.1.2.3  87/06/24  22:36:46  alex
 * New readch + gettc + tc table Tested
 * 
d115 1
a115 1
    ioctl(2,TIOCGETC, &tchars0);
d119 1
a119 1
    ioctl(2,TIOCSETC, &tcharsw);
d122 1
a122 1
    ioctl(2,TIOCGLTC,&tmpltc);
d125 1
a125 1
    ioctl(2,TIOCSLTC,&tmpltc);
d127 1
a127 1
    gtty(2,&templ);
d167 1
a167 1
    stty(2,&templw);
d180 1
a180 1
    stty(2,&templ);
d182 1
a182 1
    ioctl(2,TIOCSLTC, &oldltc);
d185 1
a185 1
    ioctl(2,TIOCSETC, &tchars0);
d226 1
a226 1
register int c;
d230 5
a234 6
    static short graphcase = 0;
    short vineed, needgraph;
    c &= 0377;
    if (c>=0 && c<=COMCOD) {
	if( c == COSTART) n0scroll = n1scroll = -1;
	if(!(s=cvtout[c])) return(0);
a250 12
      if ( c >= G_START && c <= G_END)
	{
	if( c < G_START + gchars ) { c = g_table[(c) - G_START];
		needgraph = 1;
		}
		else {
		c = g0table[c-G_START];
		needgraph = 0;
		}
	 } else needgraph = 0;
	 if ( needgraph != graphcase ) putcha(COGSTART + graphcase);
	  graphcase = needgraph;
a311 7
setatr(atr)
int atr;
{
 register int i = NUMA(atr);
 if ( i != cur_atr && i <= COAOUT ) putcha(i);
 cur_atr = atr;
}
@


3.1.2.5
log
@REVISION
@
text
@d3 1
a3 1
 *       $Header: S.ttyio.c,v 3.1.2.4 87/07/03 22:03:56 alex Exp $
a5 3
 * Revision 3.1.2.4  87/07/03  22:03:56  alex
 * Graph_characters used in margin
 * 
a179 1
    setatr(A_NORM);
a310 1
    setatr(A_NORM);
d338 1
a338 1
 * Чтение очередного символа с терминала.
d393 1
a393 2
	if( lc < 040)
		lc = (lc&037)|'@@';
d402 1
a402 1
	if( Cyin==1 && lc >= 040 && lc < 0177) lc = INTT(lc);
@
