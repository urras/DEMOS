head     4.1;
access   ;
symbols  RED_4:3.1.2 RED_3_9:3.8 DEMOS_2:3.3 COMMON3:3.2 ES:3.1.1;
locks    ;
comment  @ * @;


4.1
date     88.03.31.22.04.50;  author alex;  state Exp;
branches ;
next     3.9;

3.9
date     88.03.30.17.26.53;  author alex;  state Exp;
branches ;
next     3.8;

3.8
date     87.06.12.18.11.27;  author alex;  state Exp;
branches ;
next     3.7;

3.7
date     87.06.06.16.49.42;  author alex;  state Exp;
branches ;
next     3.6;

3.6
date     87.06.05.23.51.24;  author alex;  state Exp;
branches ;
next     3.5;

3.5
date     87.06.04.23.44.33;  author alex;  state Exp;
branches ;
next     3.4;

3.4
date     86.09.19.19.55.47;  author alex;  state Stab;
branches ;
next     3.3;

3.3
date     86.08.04.20.52.54;  author alex;  state Exp;
branches ;
next     3.2;

3.2
date     86.07.24.19.05.13;  author alex;  state Exp;
branches ;
next     3.1;

3.1
date     86.04.20.23.42.39;  author alex;  state Exp;
branches 3.1.1.1 3.1.2.1;
next     ;

3.1.1.1
date     86.06.05.00.06.18;  author alex;  state Exp;
branches ;
next     3.1.1.2;

3.1.1.2
date     86.06.05.18.54.17;  author alex;  state Exp;
branches ;
next     3.1.1.3;

3.1.1.3
date     86.06.16.21.54.17;  author alex;  state Stab;
branches ;
next     3.1.1.4;

3.1.1.4
date     86.06.16.22.19.58;  author alex;  state Exp;
branches ;
next     3.1.1.5;

3.1.1.5
date     86.06.20.23.35.44;  author alex;  state Exp;
branches ;
next     3.1.1.6;

3.1.1.6
date     86.07.15.22.13.45;  author alex;  state Stab;
branches ;
next     ;

3.1.2.1
date     87.06.19.17.02.06;  author alex;  state Exp;
branches ;
next     3.1.2.2;

3.1.2.2
date     87.06.23.18.53.01;  author alex;  state Stab;
branches ;
next     3.1.2.3;

3.1.2.3
date     87.06.24.22.35.47;  author alex;  state Stab;
branches ;
next     3.1.2.4;

3.1.2.4
date     87.06.29.17.56.51;  author alex;  state Exp;
branches ;
next     3.1.2.5;

3.1.2.5
date     87.07.03.22.03.22;  author alex;  state Exp;
branches ;
next     3.1.2.6;

3.1.2.6
date     87.07.09.20.43.27;  author alex;  state Exp;
branches ;
next     ;


desc
@  Полиэкранный редактор RED
  Версия 3.
  ИАЭ им. Курчатова, Москва.
@


4.1
log
@Версия 4.1 - обкатка на UTEC, СМ
@
text
@/*
 *      Редактор RED.
 *
 *      $Header: r.tele.c,v 3.9 88/03/30 17:26:53 alex Exp $
 *      $Log:	r.tele.c,v $
 * Revision 3.9  88/03/30  17:26:53  alex
 * Исправлена ошибка в readch. Введены функции для удаления/вставки
 * строк на экране через ChangeScroll/InsertLine-DeleteLine.
 * 
 * Revision 3.1.2.6  87/07/09  20:43:27  alex
 * REVISION
 * 
 * Revision 3.1.2.5  87/07/03  22:03:22  alex
 * Graph_characters used in margin
 * 
 * Revision 3.1.2.4  87/06/29  17:56:51  alex
 * Commans set to 0200-0277
 * 
 * Revision 3.1.2.3  87/06/24  22:35:47  alex
 * New readch + gettc + tc table Tested
 * 
 * Revision 3.1.2.2  87/06/23  18:53:01  alex
 * wYNESENA PEREMENNAQ lread1 I \TO OTLAVENO
 * 
 * Revision 3.1.2.1  87/06/19  17:02:06  alex
 * Start revision for red/4
 * 
 * Revision 3.8  87/06/12  18:11:27  alex
 * Исправлены ошибки в режиме vilcase и мелочи для vt-200
 * 
 * Revision 3.7  87/06/06  16:49:42  alex
 * Добавлен roll для терминалов с sr/sf и отображение
 *  табуляций в режиме -t + всякая мелочь
 * 
 * Revision 3.6  87/06/05  23:51:24  alex
 * Добавлен roll для терминалов с sr/sf и отображение
 *  табуляций в режиме -t + всякая мелочь
 * 
 * Revision 3.5  87/06/04  23:44:33  alex
 * Scroll on -sr- or -al/dl- added
 * 
 * Revision 3.4  86/09/19  19:55:47  alex
 * Версия для СМ-1700
 * 
 * Revision 3.3  86/08/04  20:52:54  alex
 * Bepqh dk LMNQ/DELNQ 2
 * 
 * Revision 3.2  86/07/24  19:05:13  alex
 * Об'единены версии текстов для ЕС и СМ
 * 
 * Revision 3.1.1.6  86/07/15  22:13:45  alex
 * RED 3.3/EC.
 * 
 * Revision 3.1.1.5  86/06/20  23:35:44  alex
 * 
 * Revision 3.1.1.4  86/06/16  22:19:58  alex
 * Первая версия с повтором сеанса (пока грязная)
 * 
 * Revision 3.1.1.2  86/06/05  18:54:17  alex
 * Отлажено_на_модели
 * 
 * Revision 3.1.1.1  86/06/05  00:06:18  alex
 * Отлажено_на_модели
 * 
 * Revision 3.1  86/04/20  23:42:39  alex
 * Базовая версия для ЕС.
 * 
 * Revision 3.1  86/04/20  23:42:39  alex
 * *** empty log message ***
 * 
 * Revision 1.5  86/04/13  22:01:59  alex
 *
 * r.tele.c - Работа с терминалом - логический уровень
 *
 *
 */

#include "r.defs.h"

#ifdef DEMOSES
#define fixcurs() /* */
#endif

/*   putup(l0,lf) - выдать строки с l0 до lf
 *      Особый случай - если l0 отрицательно, то выдать только строку lf.
 *      При этом строка берется из cline, и выдавать только с колонки -l0.
 */
putup(lo,lf)
int lo,lf;
{
    register int i, l0, fc;
    int j,k,l1;
    char lmc,*cp,rmargflg;
    l0 = lo;
    lo += 2;
    if (lo > 0) lo = 0; /* Нач. колонка */
    l1 = lo;
    lmc = (curport->lmarg == curport->ltext ? 0 :
    curwksp->ulhccno == 0 ? LMCH : MLMCH);
    rmargflg = (curport->ltext + curport->rtext < curport->rmarg);
    if ( l0 >= 0 && fcline ) putline(0);
    while (l0 <= lf)
    {
        lo = l1;
        if (l0 < 0)
        {
            l0 = lf;
            lf = -1;
            i = 0;
        }
        else
        {
            if (l0 != lf && intrup())  return;
            if (i = wseek(curwksp,curwksp->ulhclno + l0)
                && lmc != 0) lmc = ELMCH;
        }
        if (lmc == curport->lmchars[l0] || lmc == 0 || lo < 0) poscursor(0,l0);
        else
        {
	    poscursor(-LMARG,l0);
	    putch(lmc,A_MARG);
        }
        curport->lmchars[l0] = lmc;
        if (rmargflg != 0) rmargflg = RMCH;
        if (i != 0) i = 0;
        else
        {
	    if (lf >= 0) chars(1);
            i = (ncline - 1) - curwksp->ulhccno;
            if (i < 0) i = 0;
            else if (i > curport->rtext)
            {
                if (i > 1 + curport->rtext && rmargflg)
                    rmargflg = MRMCH;
                i = 1 + curport->rtext;
            }
        }
        /*
	 * Вывод символов.
	 * Пытаемся пропустить начальные пробелы
	 */
	if (lo == 0  )
        {
            for (fc=0;cline[curwksp->ulhccno + fc]==' ';fc++);
            j=curport->rtext+1; 
            if(fc>j) fc=j; 
            if(fc>127) fc=127;
            lo = (curport->firstcol)[l0] > fc ?
            - fc : - (curport->firstcol)[l0];
            if (i+lo<=0) lo = 0;
            else curport->firstcol[l0] = fc;
        }
	poscursor(-lo,l0);
        j = i + lo;
        cp = cline + curwksp->ulhccno - lo;
	setatr(0);
        while(j--) putcha(*cp++);
        cursorcol += (i + lo);
        if (curport->lastcol[l0] < cursorcol)
            curport->lastcol[l0] = cursorcol;
        /* Хвост строки заполняем пробелами */
        k = (j = curport->lastcol[l0]) - i;
        if (k > 0)
        {
            putblanks(k);
        }
        fixcurs();
        if (rmargflg && rmargflg != curport->rmchars[l0])
        {
            poscursor(curport->rmarg - curport->ltext, l0);
	    putch(rmargflg,A_MARG);
        }
        else movecursor(0);
        curport->rmchars[l0] = rmargflg;
        curport->lastcol[l0] = (k > 0 ? i : j);
        ++l0;
    }
}

/*
 * poscursor(col,lin) -
 * Позиционирование курсора в текущем окне
 */
poscursor(col,lin)
int col,lin;
#ifndef DEMOSES
{ 
    register int scol,dcol,dlin;
    int slin;
    if (cursorline == lin)
    {
        if (cursorcol == col) return;
        if ((cursorcol == col-1)&&(putcha(CORT)) )
        {
            ++cursorcol;
            return;
        }
        if ((cursorcol == col+1)&&(putcha(COLT)) )
        {
            --cursorcol;
            return;
        }
    }
    if (cursorcol == col)
    {
        if ((cursorline == lin-1)&&(putcha(CODN)))
        {
            ++cursorline;
            return;
        }
        if ((cursorline == lin+1)&&(putcha(COUP)) )
        {
            --cursorline;
            return;
        }
    }
    scol=col+curport->ltext; 
    slin=lin+curport->ttext; /* screen col, lin */
    dcol=col-cursorcol; 
    dlin=lin-cursorline;           /* delta col,lin   */
    cursorcol=col; 
    cursorline=lin;
    if (pcursor(scol,slin)) return; /* direct positioning */
    if ( (( abs(scol)+abs(slin)) < (abs(dcol)+abs(dlin))))
    { 
        putcha(COHO); 
        dcol=scol; 
        dlin=slin;
    }
    if (dcol>0) { 
        while (dcol--) putcha(CORT); 
    }
    else if (dcol<0) { 
        while (dcol++) putcha(COLT); 
    }
    if (dlin>0) { 
        while (dlin--) putcha(CODN); 
    }
    else if (dlin<0) { 
        while (dlin++) putcha(COUP); 
    }
    return;
}
#else +DEMOSES
{ 
    register int scol, slin;
    if (cursorline == lin && cursorcol == col ) return;
    scol=col+curport->ltext; 
    slin=lin+curport->ttext; /* screen col, lin */
    cursorcol=col;cursorline=lin;
    pcursor(scol,slin);
    return;
}
#endif +DEMOSES

/*
 *      Движение курсора в границах окна "curscreen"
 *      Значение аргумента:
 *     UP - Вверх
 *     CR - переход на начало строки
 *     DN - вниз на строку
 *     RT - вправо на колонку
 *     LT - влево на колонку
 *     TB - прямая табуляция
 *     BT - табуляция назад
 *     Большая часть этих команд используется на ЕС тольо в макро.
 *      0 - не операции (только проверить)
 */
movecursor(arg)
int arg;
{
    register int lin,col,i;
    int nofix,ko;
    nofix = (arg&MOVE_NOFIX) != 0;
    arg &= MOVE_MASK;
    ko = -1;
    lin=cursorline;
    col=cursorcol;
    switch (arg)
    {
    case 0: 
        break;
    case HO:
        col = lin = 0;
        break;
    case UP:
        --lin;
        break;
    case RN:
        col = curport->ledit;       /* break не нужен */
	if(on_autoi) col = autoindent;
    case DN:
        ++lin;
        break;
    case RT:
        ++col;
        break;
    case LT:
        --col;
        break;
    case TB:
        i=0;
        col = col + curwksp->ulhccno;
        while (col >= tabstops[i]) i++;
        col = tabstops[i] - curwksp->ulhccno;
	goto fix;
    case BT:
        i=0;
        col = col + curwksp->ulhccno;
        while (col >  tabstops[i]) i++;
        col = (i ? tabstops[i-1] - curwksp->ulhccno : -1);
	goto fix;
    }
    if(nofix ) {
	if (col > curport->redit) col = curport->redit, ko=CCRPORT;
	else if (col < curport->ledit)  col = curport->ledit, ko=CCLPORT;
	if (lin < curport->tedit) lin = curport->tedit, ko = CCMILINE;
	else if (lin > curport->bedit) lin = curport->bedit, ko = CCPLLINE;
    } else {
fix:
	if (col > curport->redit) col = curport->ledit;
	else if (col < curport->ledit) col = curport->redit;
	if (lin < curport->tedit) lin = curport->bedit;
	else if (lin > curport->bedit) lin = curport->tedit;
    }
    poscursor(col,lin);
    return(ko);
}

/*
 * putch(c,flag) -
 *      поместить символ в текущую позицию.
 *      если установлен flag=1, то учесть его
 *      в размерах строки
 */
putch(j,flg)
int flg;
char j;
{   int atr;
    extern short cur_atr;
    atr = flg & (~0377);
    flg &= 0377;
    if ( atr != cur_atr) setatr(atr);
    if (flg && j != ' ')
    {
        if ((curport->firstcol)[cursorline] > cursorcol)
            (curport->firstcol)[cursorline] = cursorcol;
        if ((curport->lastcol)[cursorline] <= cursorcol)
            (curport->lastcol)[cursorline] = cursorcol+1;
    }
#ifdef DEMOSES
    putcha(j);
    ++cursorcol;
#else -DEMOSES
    ++cursorcol;
    if (fixcurs() == 0) putcha(j);
    if (cursorcol <= 0) poscursor(curport->ledit,
    cursorline < curport->tedit ? curport->tedit :
    cursorline > curport->bedit ? curport->tedit :
    cursorline);
    movecursor(0);
#endif -DEMOSES
}

#ifndef DEMOSES
/*
 * fixcurs() -
 * Обработка граничных эффектов на экране.
 * Устанавливает cursorcol, cursorline равными корректным значениям
 * Управляется через eolflag (=1 - курсор фиксируется на границе экрана)
 * При достижении правой граници фиксируется cursorcol, если есть eolflag.
 * Правильная последовательность:
 * 1) Увеличить cursorcol; 2) Вызвать fixcurs; 3) Вывести символ;
 * 4) Если cursorcol <= 0, спозиционировать курсор. fixcurs возвращает 1,
 *    если курсор переместился на следующую строку.
 */

fixcurs()
{
    if (eolflag && curport->ltext+cursorcol>=LINEL)    /* for VT-52 */
    { 
        cursorcol=LINEL-curport->ltext; 
        return 0;
    }
    if (curport->ltext + cursorcol >= LINEL) {
        cursorcol = - curport->ltext;
        if (curport->ttext + ++cursorline >= NLINES) {
            cursorline = - curport->ttext;
            putcha(COHO);
            return (1);
        }
    }
    return (0);
}


/*
 *  param() - Запрос параметра
 *      Три типа параметров.
 *              paramtype = -1 -- определение области
 *              paramtype = 0  -- пустой аргумент
 *              paramtype = 1  -- строка.
 *              при использовании макро бывает paramtype = -2 - tag defined
 *      Возвращается код введенной команды, в paramv - указ. на строку.
 *      Возвращается указатель на введенную строку (paramv).
 *      Длина возвращается в переменной paraml.
 *      Если при очередном вызове paraml не 0, старый paramv
 *      освобождается, так что если старый параметр нужен,
 *      нужно обнулить paraml.
 *      Вариант "param" для ЕС записан в отдельном файле
 */
#define LPARAM 20       /* Длина приращения длины */
int param(macro)
int macro;
{
    register char *c1;
    char *cp,*c2;
    register int i,pn;
    int lread1;
    struct viewport *w;
    int chr;
    if (paraml != 0 && paramv != 0) free(paramv);
    paramc1 = paramc0 = cursorcol;
    paramr1 = paramr0 = cursorline;
    putch(COCURS,1);
    poscursor(cursorcol,cursorline);
    w = curport;
back:
    telluser(macro?"mac: ":"arg: ",0);
    switchport(&paramport);
    poscursor(5,0);
    do
        {
	lread1=readch();
    }
    while (lread1 == CCBACKSPACE);
    if(macro) goto rmac;
    if (ISACMD(lread1) && lread1>= CC && (lread1<=BT+CC))
    {
        telluser(DIAG("arg: *** cursor defined ***",
        "arg: *** указание курсором ***"),0);
        switchport(w);
        poscursor(paramc0,paramr0);
t0:
	while (ISACMD(lread1) && (i=((lread1-CC<=BT)?lread1-CC:0)))
        {
            movecursor(i);
            if (cursorline == paramr0 &&
                cursorcol  == paramc0)  goto back;
	    lread1 = readch();
        }
	if (ISACMD(lread1) && lread1 != CCBACKSPACE)
        {
            if(cursorcol > paramc0)paramc1 = cursorcol;
            else paramc0 = cursorcol;
            if(cursorline > paramr0)paramr1 = cursorline;
            else paramr0 = cursorline;
            paraml = 0; 
            paramv = NULL;
            paramtype = -1;
        }
        else
        {
            error(DIAG("Printing character illegal here","Этот символ здесь недопустим"));
	    lread1 = readch();
            goto t0;
        }
    }
    else if (ISACMD(lread1))
    {
        paraml = 0; 
        paramv = NULL;
        paramtype=0;
    }
    else
    {
rmac:           
	unread1(lread1);
        paraml = pn = 0;
loop:
	chr= lread1 = readch();
        if (pn >= paraml)
        {
            cp = paramv;
            paramv = salloc(paraml + LPARAM+1); /* 1 for dechars */
            c1 = paramv;
            c2 = cp;
            for (i=0; i<paraml; ++i) *c1++ = *c2++;
            if (paraml) free(cp);
            paraml += LPARAM;
        }
        /* Конец ввода параметра */
	if ((!macro && ISACMD(lread1))|| lread1==CCBACKSPACE || lread1==CCQUIT)
        {
	    if (lread1 == CCBACKSPACE &&  cursorcol != curport->ledit)
                /* backspace */
            {
                if (pn == 0)
                {
                    goto loop;
                }
                movecursor(LT);
                --pn;
                if((paramv[pn]&0340) ==0)
                {
                    putch(' ',0); 
                    movecursor(LT);
                    movecursor(LT);
                }
                paramv[pn] = 0;
                putch(' ',0);
                movecursor(LT);
                if (pn == 0) goto back;
                goto loop;
            }
	    else chr = 0;
        }
	if (chr == 0177) chr = 0;    /* del is a contol code  */
	paramv[pn++] = chr;
	if (chr)
        {
	    if((chr&0140)==0){
                putch('^',0); 
		chr = chr | 0100;
            }
	    putch(chr,0);
            goto loop;
        }
        paramtype = 1;
    }
    switchport(w);
    putup(paramr0,paramr0);
    poscursor(paramc0,paramr0);
    return (lread1);
}
#endif DEMOSES

/*
 * drawport(newp,vertf) -
 * Рисовать окно newp (рамки). vertf говорит, нужно ли
 * рисовать верт. рамку
 */
drawport(newp,vertf)
struct viewport *newp;
int vertf;
{
    register struct viewport *newport;
    register int i;
    register char c;
    int j;
    int cc,cl;
    int lu,ld,ru,rd;
    newport = newp;
    switchport(&wholescreen);
    cc = cursorcol; cl = cursorline;
    setscroll(&wholescreen,0);
    if(newport->tmarg == 0 ) { lu = G_LU; ru = G_RU; }
    else { lu = (newport->lmarg?G_LU:G_LM);
	   ru = (newport->rmarg!=wholescreen.rmarg?G_RU:G_RM);
	 }
    if(newport->bmarg == wholescreen.bmarg-NPARAMLINES ) {
	 ld = G_LD; rd = G_RD; }
    else { ld = (newport->lmarg?G_LD:G_LM);
	   rd = (newport->rmarg!=wholescreen.rmarg?G_RD:G_RM);
	 }
    if(newport->tmarg != newport->ttext) {
        poscursor(newport->lmarg,newport->tmarg);
	putch(lu,A_MARG);
	for (i = newport->lmarg+1;i <= newport->rmarg-1;i++) putch(TMCH,A_MARG);
	putch(ru,A_MARG);
    }
    if ( vertf )
        for (j = newport->tmarg + 1;j <= newport->bmarg - 1;j++)
        {
            if (c = newport->lmchars[j - newport->tmarg - 1])
	    {
                poscursor(newport->lmarg,j);
		putch(c,A_MARG);
                poscursor(newport->rmarg,j);
		putch(newport->rmchars[j - newport->tmarg - 1],A_MARG);
            }
        }
    if(newport->bmarg != newport->ttext+newport->btext) {
        poscursor(newport->lmarg,newport->bmarg);
	putch(ld,A_MARG);
	for (i = newport->lmarg+1;i <= newport->rmarg-1;i++) putch(BMCH,A_MARG);
	putch(rd,A_MARG);
    }
    poscursor(cc, cl);
    switchport(newport);
    need_box = 0;
}

static tellatr = A_INFO;
/*
 * error(msg) -
 * Выдать сообщение об ошибке
 */
error(msg)
char *msg;
{
	ps_inmac = (char *)0;
	putcha(COBELL); 
	putcha(COBELL); 
	putcha(COBELL);
	tellatr = A_ERROR;
	telluser("**** ",0);
	telluser(msg,5);
	tellatr = A_INFO;
	errsw = 1;
}

/*
 * telluser(msg,col) -
 * Выдать сообщение с колонки  col. Если col =0 -
 * очистить окно параметров
 */
telluser(msg,col)
char *msg;
int col;
{
    struct viewport *oldport;
    register int c,l;
    int oldledit;
    oldport = curport;
    c = cursorcol;
    l = cursorline;
    switchport(&paramport);
    oldledit=paramport.ledit;
    paramport.ledit = 0;
    if (col == 0)
    {
        poscursor(0,0);
        putblanks(paramport.redit);
    }
/*  putcha(COOPEN);     */
    poscursor(col,0);
    /*      while (*msg) putch(*msg++,0);   */
    info(msg, PARAMREDIT);
/*  putcha(COCLOSE);    */
    paramport.ledit=oldledit;
    switchport(oldport);
    poscursor(c,l);
    dumpcbuf(0);
}


/*
 * rescreen(nom) -
 * Восстановление сбитого окна
 * ( nom - пока не используется)
 */
/*ARGSUSED*/
rescreen(nom)int nom;
{       
    register int i;
    int j;
    register struct viewport *curp,*curp0 = curport;
    int col=cursorcol, lin=cursorline;
    extern int clrsw;
    switchport(&wholescreen);
    setscroll(&wholescreen,0);
    cursorcol = cursorline =0;
    putcha(COFIN);
    new_info = 1;
    putcha(COSTART);
    putcha(COHO);
    for ( j=0; j<nportlist; j++) {
        switchport(portlist[j]); 
        curp = curport;
        for (i=0;i<curport->btext+1;i++)
        {
            curp->firstcol[i]=0; 
            curp->lastcol[i]= 0; /* curport->rtext;*/
            curp->lmchars[i] = curp->rmchars[i] =' ';
        }
        drawport(curp,0);
	if ( nom != -1 || curp != curp0 )
        putup(0,curp->btext); 
    }
    switchport(curp0);
    poscursor(col,lin);
    clrsw = 1;
}

/*
 * info(ss,ml)
 * - выдать (с преобразованием во внешнюю форму) строку
 * ss в окно параметров, макс. длина "ml"
 */
info(ss,ml)
char *ss;
int ml;
{ 
    register char *s=ss;
      char putbuf[PARAMRINFO+5], *si, *so;
      so = putbuf;
    if( lcasef )
    { 
        int no=1;
        si=s; 
        while(*s++); /* na{li konec */
        exinss(&si, --s, &so, &no, PARAMRINFO);
        *so =0;
        s=putbuf;
    }
    while (*s && cursorcol < ml) putch( ( latf? *s++ &0177 : *s++ ),tellatr);
    setatr(A_NORM);
}

#ifndef DEMOSES
/*
 * shiftview(n0, nl) - пересчитать описатель окна после сдвига
 * строк после n0-й на nl строк вверх (вниз, если <0)
 */
shiftview(n0,nl)
int n0,nl;
{
	register int i,j;
	register struct viewport *cp;
	cp=curport;
	if(nl>0) {
		for(i=n0,j=n0+nl;j<=cp->btext;i++,j++) {
			cp->lmchars[i] = cp->lmchars[j];
			cp->rmchars[i] = cp->rmchars[j];
			cp->firstcol[i] = cp->firstcol[j];
			cp->lastcol[i] = cp->lastcol[j];
		}
		for(;i<= cp->btext;i++){
			cp->lmchars[i] = cp->rmchars[i] = ' ';
			cp->firstcol[i] = cp->lastcol[i] = 0;
		}
		return(1);
	} 
	else {
		for(i=cp->btext,j=cp->btext+nl;j>=n0;i--,j--) {
			cp->lmchars[i] = cp->lmchars[j];
			cp->rmchars[i] = cp->rmchars[j];
			cp->firstcol[i] = cp->firstcol[j];
			cp->lastcol[i] = cp->lastcol[j];
		}
		for(;i>= n0;i--){
			cp->lmchars[i] = cp->rmchars[i] = ' ';
			cp->firstcol[i] = cp->lastcol[i] = 0;
		}
		return(1);
	}
}
/*   Руднев А.П. Москва, ИАЭ им. Курчатова, 1984 */
#endif
@


3.9
log
@Исправлена ошибка в readch. Введены функции для удаления/вставки
строк на экране через ChangeScroll/InsertLine-DeleteLine.
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.1.2.6 87/07/09 20:43:27 alex Exp $
d6 4
@


3.8
log
@Исправлены ошибки в режиме vilcase и мелочи для vt-200
@
text
@d2 1
a2 1
 *      Редактор RED. ИАЭ им. И.В. Курчатова, ОС ДЕМОС
d4 1
a4 1
 *      $Header: r.tele.c,v 3.7 87/06/06 16:49:42 alex Exp $
d6 21
d117 1
a117 1
            putch(lmc,0);
d152 1
d167 1
a167 1
            putch(rmargflg,0);
d335 6
a340 2
{
    if (flg && lread1 != ' ')
d400 1
d409 1
a409 1
char *param(macro)
a413 1
    int c;
d415 1
d417 1
d430 1
a430 2
        lread1 = -1;
        read1();
d434 1
a434 1
    if (CONTROLCHAR && lread1 && (lread1<=BT))
d441 1
a441 1
        while (CONTROLCHAR && (i=((lread1<=BT)?lread1:0)))
d446 1
a446 2
            lread1 = -1;
            read1();
d448 1
a448 1
        if (CTRLCHAR && lread1 != CCBACKSPACE)
d461 1
a461 2
            lread1 = -1;
            read1();
d465 1
a465 1
    else if (CTRLCHAR)
d474 1
d477 1
a477 1
        c = read1();
d489 1
a489 1
        if ((!macro && CONTROLCHAR)|| c==CCBACKSPACE || c==CCQUIT)
d491 1
a491 1
            if (c == CCBACKSPACE &&  cursorcol != curport->ledit)
a495 1
                    lread1 = -1;
a508 1
                lread1 = -1;
d512 1
a512 1
            else c = 0;
d514 3
a516 3
        if (c == 0177) c = 0;    /* del is a contol code  */
        paramv[pn++] = c;
        if (c != 0)
d518 1
a518 1
            if((c&0140)==0){
d520 1
a520 1
                c = c | 0100;
d522 1
a522 2
            putch(c,0);
            lread1 = -1;
d530 1
a530 1
    return (paramv);
d548 1
d552 10
a561 1
    setscroll(&wholescreen);
d564 3
a566 1
        for (i = newport->lmarg;i <= newport->rmarg;i++) putch(TMCH,0); 
d572 1
a572 1
            {
d574 1
a574 1
                putch(c,0);
d576 1
a576 1
                putch(newport->rmchars[j - newport->tmarg - 1],0);
d581 3
a583 1
        for (i = newport->lmarg;i <= newport->rmarg;i++) putch(BMCH,0);
d590 1
d598 1
d602 1
d605 1
d632 1
a632 1
    putcha(COOPEN);
d636 1
a636 1
    putcha(COCLOSE);
d658 1
a658 1
    setscroll(&wholescreen);
d703 2
a704 1
    while (*s && cursorcol < ml) putch( ( latf? *s++ &0177 : *s++ ),0);
@


3.7
log
@Добавлен roll для терминалов с sr/sf и отображение
 табуляций в режиме -t + всякая мелочь
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.6 87/06/05 23:51:24 alex Exp $
d6 4
d704 1
@


3.6
log
@Добавлен roll для терминалов с sr/sf и отображение
 табуляций в режиме -t + всякая мелочь
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.5 87/06/04 23:44:33 alex Exp $
d6 4
d261 1
@


3.5
log
@Scroll on -sr- or -al/dl- added
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.4 86/09/19 19:55:47 alex Exp $
d6 3
d515 1
d518 1
d535 1
a535 1
    if(newport->tmarg != newport->ttext) {
d539 1
a539 1
    /*   poscursor(newport->lmarg + 1,newport->tmarg + 1);     */
d541 1
@


3.4
log
@Версия для СМ-1700
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.3 86/08/04 20:52:54 alex Exp $
d6 3
d236 4
d268 1
a268 1
        break;
d274 1
a274 1
        break;
d276 12
a287 4
    if (col > curport->redit) col = curport->ledit;
    else if (col < curport->ledit) col = curport->redit;
    if (lin < curport->tedit) lin = curport->bedit;
    else if (lin > curport->bedit) lin = curport->tedit;
d289 1
a289 1
    return;
d514 1
d602 1
d605 1
d650 38
@


3.3
log
@Bepqh dk LMNQ/DELNQ 2
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.2 86/07/24 19:05:13 alex Exp $
d6 3
@


3.2
log
@Об'единены версии текстов для ЕС и СМ
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.1.1.6 86/07/15 22:13:45 alex Exp $
d6 3
d557 1
d561 1
@


3.1
log
@Базовая версия для ЕС.
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.1 86/04/20 23:42:39 alex Exp $
d6 14
d21 3
d35 4
d48 1
a48 1
    char lmc,*cp,c,rmargflg;
d56 1
d75 1
a75 1
            poscursor(-1,l0);
d83 1
a83 1
            if (lf >= 0) c = chars(1);
d97 1
a97 1
        if (lo == 0)
d108 1
a108 1
        if (lo) poscursor(-lo,l0);
d140 1
d198 11
d220 1
d288 2
d291 2
d299 1
d302 1
d346 1
d476 1
d542 1
d547 2
d557 1
d560 1
a560 1
    dumpcbuf();
d576 1
d592 1
d597 1
d610 2
a613 1
        char putbuf[PARAMRINFO+1], *si, *so=putbuf;
@


3.1.2.1
log
@Start revision for red/4
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.8 87/06/12 18:11:27 alex Exp $
a5 37
 * Revision 3.8  87/06/12  18:11:27  alex
 * Исправлены ошибки в режиме vilcase и мелочи для vt-200
 * 
 * Revision 3.7  87/06/06  16:49:42  alex
 * Добавлен roll для терминалов с sr/sf и отображение
 *  табуляций в режиме -t + всякая мелочь
 * 
 * Revision 3.6  87/06/05  23:51:24  alex
 * Добавлен roll для терминалов с sr/sf и отображение
 *  табуляций в режиме -t + всякая мелочь
 * 
 * Revision 3.5  87/06/04  23:44:33  alex
 * Scroll on -sr- or -al/dl- added
 * 
 * Revision 3.4  86/09/19  19:55:47  alex
 * Версия для СМ-1700
 * 
 * Revision 3.3  86/08/04  20:52:54  alex
 * Bepqh dk LMNQ/DELNQ 2
 * 
 * Revision 3.2  86/07/24  19:05:13  alex
 * Об'единены версии текстов для ЕС и СМ
 * 
 * Revision 3.1.1.6  86/07/15  22:13:45  alex
 * RED 3.3/EC.
 * 
 * Revision 3.1.1.5  86/06/20  23:35:44  alex
 * 
 * Revision 3.1.1.4  86/06/16  22:19:58  alex
 * Первая версия с повтором сеанса (пока грязная)
 * 
 * Revision 3.1.1.2  86/06/05  18:54:17  alex
 * Отлажено_на_модели
 * 
 * Revision 3.1.1.1  86/06/05  00:06:18  alex
 * Отлажено_на_модели
 * 
a6 3
 * Базовая версия для ЕС.
 * 
 * Revision 3.1  86/04/20  23:42:39  alex
a17 4
#ifdef DEMOSES
#define fixcurs() /* */
#endif

d27 1
a27 1
    char lmc,*cp,rmargflg;
a34 1
    if ( l0 >= 0 && fcline ) putline(0);
d53 1
a53 1
	    poscursor(-LMARG,l0);
d61 1
a61 1
	    if (lf >= 0) chars(1);
d75 1
a75 1
	if (lo == 0  )
d86 1
a86 1
	poscursor(-lo,l0);
a117 1
#ifndef DEMOSES
a174 11
#else +DEMOSES
{ 
    register int scol, slin;
    if (cursorline == lin && cursorcol == col ) return;
    scol=col+curport->ltext; 
    slin=lin+curport->ttext; /* screen col, lin */
    cursorcol=col;cursorline=lin;
    pcursor(scol,slin);
    return;
}
#endif +DEMOSES
a185 1
 *     Большая часть этих команд используется на ЕС тольо в макро.
a191 4
    int nofix,ko;
    nofix = (arg&MOVE_NOFIX) != 0;
    arg &= MOVE_MASK;
    ko = -1;
a205 1
	if(on_autoi) col = autoindent;
d220 1
a220 1
	goto fix;
d226 1
a226 1
	goto fix;
d228 4
a231 12
    if(nofix ) {
	if (col > curport->redit) col = curport->redit, ko=CCRPORT;
	else if (col < curport->ledit)  col = curport->ledit, ko=CCLPORT;
	if (lin < curport->tedit) lin = curport->tedit, ko = CCMILINE;
	else if (lin > curport->bedit) lin = curport->bedit, ko = CCPLLINE;
    } else {
fix:
	if (col > curport->redit) col = curport->ledit;
	else if (col < curport->ledit) col = curport->redit;
	if (lin < curport->tedit) lin = curport->bedit;
	else if (lin > curport->bedit) lin = curport->tedit;
    }
d233 1
a233 1
    return(ko);
a252 2
#ifdef DEMOSES
    putcha(j);
a253 2
#else -DEMOSES
    ++cursorcol;
a259 1
#endif -DEMOSES
a261 1
#ifndef DEMOSES
a304 1
 *      Вариант "param" для ЕС записан в отдельном файле
a433 1
#endif DEMOSES
a447 1
    int cc,cl;
a449 2
    cc = cursorcol; cl = cursorline;
    setscroll(&wholescreen);
d465 1
a465 1
    if(newport->bmarg != newport->ttext+newport->btext) {
d469 1
a469 1
    poscursor(cc, cl);
a470 1
    need_box = 0;
a498 1
    int oldledit;
a502 2
    oldledit=paramport.ledit;
    paramport.ledit = 0;
a507 1
    putcha(COOPEN);
a510 2
    putcha(COCLOSE);
    paramport.ledit=oldledit;
d513 1
a513 1
    dumpcbuf(0);
a528 1
    extern int clrsw;
a529 1
    setscroll(&wholescreen);
a531 1
    new_info = 1;
a543 1
	if ( nom != -1 || curp != curp0 )
a547 1
    clrsw = 1;
a559 2
      char putbuf[PARAMRINFO+5], *si, *so;
      so = putbuf;
d562 1
a572 38
#ifndef DEMOSES
/*
 * shiftview(n0, nl) - пересчитать описатель окна после сдвига
 * строк после n0-й на nl строк вверх (вниз, если <0)
 */
shiftview(n0,nl)
int n0,nl;
{
	register int i,j;
	register struct viewport *cp;
	cp=curport;
	if(nl>0) {
		for(i=n0,j=n0+nl;j<=cp->btext;i++,j++) {
			cp->lmchars[i] = cp->lmchars[j];
			cp->rmchars[i] = cp->rmchars[j];
			cp->firstcol[i] = cp->firstcol[j];
			cp->lastcol[i] = cp->lastcol[j];
		}
		for(;i<= cp->btext;i++){
			cp->lmchars[i] = cp->rmchars[i] = ' ';
			cp->firstcol[i] = cp->lastcol[i] = 0;
		}
		return(1);
	} 
	else {
		for(i=cp->btext,j=cp->btext+nl;j>=n0;i--,j--) {
			cp->lmchars[i] = cp->lmchars[j];
			cp->rmchars[i] = cp->rmchars[j];
			cp->firstcol[i] = cp->firstcol[j];
			cp->lastcol[i] = cp->lastcol[j];
		}
		for(;i>= n0;i--){
			cp->lmchars[i] = cp->rmchars[i] = ' ';
			cp->firstcol[i] = cp->lastcol[i] = 0;
		}
		return(1);
	}
}
a573 1
#endif
@


3.1.2.2
log
@wYNESENA PEREMENNAQ lread1 I \TO OTLAVENO
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.1.2.1 87/06/19 17:02:06 alex Exp $
a5 3
 * Revision 3.1.2.1  87/06/19  17:02:06  alex
 * Start revision for red/4
 * 
d317 1
a317 1
    if (flg && j != ' ')
a376 1
 *      Возвращается код введенной команды, в paramv - указ. на строку.
d385 1
a385 1
int param(macro)
d390 1
a391 1
    int lread1;
a392 1
    int chr;
d405 2
a406 1
	lread1=readch();
d410 1
a410 1
    if (ISACMD(lread1) && lread1>= 0 && (lread1<=BT))
d417 1
a417 1
	while (ISACMD(lread1) && (i=((lread1<=BT)?lread1:0)))
d422 2
a423 1
	    lread1 = readch();
d425 1
a425 1
	if (ISACMD(lread1) && lread1 != CCBACKSPACE)
d438 2
a439 1
	    lread1 = readch();
d443 1
a443 1
    else if (ISACMD(lread1))
a451 1
	unread1(lread1);
d454 1
a454 1
	chr= lread1 = readch();
d466 1
a466 1
	if ((!macro && ISACMD(lread1))|| lread1==CCBACKSPACE || lread1==CCQUIT)
d468 1
a468 1
	    if (lread1 == CCBACKSPACE &&  cursorcol != curport->ledit)
d473 1
d487 1
d491 1
a491 1
	    else chr = 0;
d493 3
a495 3
	if (chr == 0177) chr = 0;    /* del is a contol code  */
	paramv[pn++] = chr;
	if (chr)
d497 1
a497 1
	    if((chr&0140)==0){
d499 1
a499 1
		chr = chr | 0100;
d501 2
a502 1
	    putch(chr,0);
d510 1
a510 1
    return (lread1);
@


3.1.2.3
log
@New readch + gettc + tc table Tested
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.1.2.2 87/06/23 18:53:01 alex Exp $
a5 3
 * Revision 3.1.2.2  87/06/23  18:53:01  alex
 * wYNESENA PEREMENNAQ lread1 I \TO OTLAVENO
 * 
a562 1
	ps_inmac = (char *)0;
@


3.1.2.4
log
@Commans set to 0200-0277
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.1.2.3 87/06/24 22:35:47 alex Stab $
a5 3
 * Revision 3.1.2.3  87/06/24  22:35:47  alex
 * New readch + gettc + tc table Tested
 * 
d417 1
a417 1
    if (ISACMD(lread1) && lread1>= CC && (lread1<=BT+CC))
d424 1
a424 1
	while (ISACMD(lread1) && (i=((lread1-CC<=BT)?lread1-CC:0)))
@


3.1.2.5
log
@Graph_characters used in margin
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.1.2.4 87/06/29 17:56:51 alex Exp $
a5 3
 * Revision 3.1.2.4  87/06/29  17:56:51  alex
 * Commans set to 0200-0277
 * 
d108 1
a108 1
	    putch(lmc,A_MARG);
a142 1
	setatr(0);
d157 1
a157 1
	    putch(rmargflg,A_MARG);
d325 1
a325 5
{   int atr;
    extern short cur_atr;
    atr = flg & (~0377);
    flg &= 0377;
    if ( atr != cur_atr) setatr(atr);
a533 1
    int lu,ld,ru,rd;
a537 9
    if(newport->tmarg == 0 ) { lu = G_LU; ru = G_RU; }
    else { lu = (newport->lmarg?G_LU:G_LM);
	   ru = (newport->rmarg!=wholescreen.rmarg?G_RU:G_RM);
	 }
    if(newport->bmarg == wholescreen.bmarg-NPARAMLINES ) {
	 ld = G_LD; rd = G_RD; }
    else { ld = (newport->lmarg?G_LD:G_LM);
	   rd = (newport->rmarg!=wholescreen.rmarg?G_RD:G_RM);
	 }
d540 1
a540 3
	putch(lu,A_MARG);
	for (i = newport->lmarg+1;i <= newport->rmarg-1;i++) putch(TMCH,A_MARG);
	putch(ru,A_MARG);
d546 1
a546 1
	    {
d548 1
a548 1
		putch(c,A_MARG);
d550 1
a550 1
		putch(newport->rmchars[j - newport->tmarg - 1],A_MARG);
d555 1
a555 3
	putch(ld,A_MARG);
	for (i = newport->lmarg+1;i <= newport->rmarg-1;i++) putch(BMCH,A_MARG);
	putch(rd,A_MARG);
a561 1
static tellatr = A_INFO;
a572 1
	tellatr = A_ERROR;
a574 1
	tellatr = A_INFO;
d601 1
a601 1
/*  putcha(COOPEN);     */
d605 1
a605 1
/*  putcha(COCLOSE);    */
d672 1
a672 1
    while (*s && cursorcol < ml) putch( ( latf? *s++ &0177 : *s++ ),tellatr);
@


3.1.2.6
log
@REVISION
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.1.2.5 87/07/03 22:03:22 alex Exp $
a5 3
 * Revision 3.1.2.5  87/07/03  22:03:22  alex
 * Graph_characters used in margin
 * 
a697 1
    setatr(A_NORM);
@


3.1.1.1
log
@Отлажено_на_модели
@
text
@a6 3
 * Базовая версия для ЕС.
 * 
 * Revision 3.1  86/04/20  23:42:39  alex
d53 1
a53 1
	    poscursor(-LMARG,l0);
d99 1
d102 1
a102 1
	    poscursor(curport->rmarg - curport->ltext, l0);
d121 27
a147 1
    if (cursorline == lin && cursorcol == col ) return;
d150 2
d154 19
a172 1
    pcursor(scol,slin);
a185 1
 *     Большая часть этих команд используется на ЕС тольо в макро.
d266 2
d273 1
d276 5
d292 1
d294 142
a498 1
    int oldledit;
a502 2
    oldledit=paramport.ledit;
    paramport.ledit = 0;
a510 1
    paramport.ledit=oldledit;
d513 1
a513 1
    dumpcbuf(0);
a528 1
    extern int clrsw;
a547 1
    clrsw = 1;
@


3.1.1.2
log
@Отлажено_на_модели
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.1.1.1 86/06/05 00:06:18 alex Exp $
a5 3
 * Revision 3.1.1.1  86/06/05  00:06:18  alex
 * Отлажено_на_модели
 * 
d121 1
a121 1
    register int scol;
@


3.1.1.3
log
@Отлажено на ЕС без режима восстановления и без макро
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.1.1.2 86/06/05 18:54:17 alex Exp $
a5 3
 * Revision 3.1.1.2  86/06/05  18:54:17  alex
 * Отлажено_на_модели
 * 
a40 1
    if ( l0 >= 0 && fcline ) putline(0);
d92 1
a92 1
	poscursor(-lo,l0);
a212 1
    putcha(j);
d214 6
d223 22
a357 1
	if ( nom != -1 || curp != curp0 )
d374 2
a375 4
      register char *s=ss;
      char putbuf[PARAMRINFO+5], *si, *so;
      so = putbuf;
     if( lcasef )
d377 1
@


3.1.1.4
log
@Первая версия с повтором сеанса (пока грязная)
@
text
@@


3.1.1.5
log
@
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.1.1.4 86/06/16 22:19:58 alex Exp $
a5 3
 * Revision 3.1.1.4  86/06/16  22:19:58  alex
 * Первая версия с повтором сеанса (пока грязная)
 * 
d85 1
a85 1
	if (lo == 0  )
d128 2
a129 1
    register int scol, slin;
a367 1

@


3.1.1.6
log
@RED 3.3/EC.
@
text
@d4 1
a4 1
 *      $Header: r.tele.c,v 3.1.1.5 86/06/20 23:35:44 alex Exp $
a5 2
 * Revision 3.1.1.5  86/06/20  23:35:44  alex
 * 
d39 1
a39 1
    char lmc,*cp,rmargflg;
d74 1
a74 1
	    if (lf >= 0) chars(1);
@
