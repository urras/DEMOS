head     4.1;
access   ;
symbols  RED_4:3.1.2 RED_3_9:3.12 DEMOS_2:3.4 COMMON3:3.2 ES:3.1.1;
locks    ;
comment  @ * @;


4.1
date     88.03.31.22.00.36;  author alex;  state Exp;
branches ;
next     3.13;

3.13
date     88.03.30.17.27.41;  author alex;  state Exp;
branches ;
next     3.12;

3.12
date     87.06.12.18.08.21;  author alex;  state Exp;
branches ;
next     3.11;

3.11
date     87.06.08.20.01.56;  author alex;  state Exp;
branches ;
next     3.10;

3.10
date     87.06.06.16.48.07;  author alex;  state Exp;
branches ;
next     3.9;

3.9
date     87.06.05.23.49.03;  author alex;  state Exp;
branches ;
next     3.8;

3.8
date     87.06.04.23.42.15;  author alex;  state Exp;
branches ;
next     3.7;

3.7
date     87.04.02.18.35.04;  author alex;  state Stab;
branches ;
next     3.6;

3.6
date     86.09.19.21.37.19;  author alex;  state Exp;
branches ;
next     3.5;

3.5
date     86.09.19.19.49.42;  author alex;  state Exp;
branches ;
next     3.4;

3.4
date     86.08.04.20.50.21;  author alex;  state Exp;
branches ;
next     3.3;

3.3
date     86.07.24.21.07.54;  author alex;  state Exp;
branches ;
next     3.2;

3.2
date     86.07.24.00.22.11;  author alex;  state Exp;
branches ;
next     3.1;

3.1
date     86.04.20.23.40.29;  author alex;  state Exp;
branches 3.1.1.1 3.1.2.1;
next     ;

3.1.1.1
date     86.06.05.00.03.11;  author alex;  state Exp;
branches ;
next     3.1.1.2;

3.1.1.2
date     86.06.05.18.52.38;  author alex;  state Exp;
branches ;
next     3.1.1.3;

3.1.1.3
date     86.06.06.00.12.49;  author alex;  state Exp;
branches ;
next     3.1.1.4;

3.1.1.4
date     86.06.16.21.50.50;  author alex;  state Stab;
branches ;
next     3.1.1.5;

3.1.1.5
date     86.06.16.22.15.50;  author alex;  state Exp;
branches ;
next     3.1.1.6;

3.1.1.6
date     86.06.19.00.09.42;  author alex;  state Exp;
branches ;
next     3.1.1.7;

3.1.1.7
date     86.06.20.23.30.50;  author alex;  state Exp;
branches ;
next     3.1.1.8;

3.1.1.8
date     86.06.25.19.40.32;  author alex;  state Exp;
branches ;
next     3.1.1.9;

3.1.1.9
date     86.07.15.22.11.18;  author alex;  state Stab;
branches ;
next     ;

3.1.2.1
date     87.06.19.16.57.34;  author alex;  state Exp;
branches ;
next     3.1.2.2;

3.1.2.2
date     87.06.23.18.48.22;  author alex;  state Stab;
branches ;
next     3.1.2.3;

3.1.2.3
date     87.06.24.22.33.07;  author alex;  state Stab;
branches ;
next     3.1.2.4;

3.1.2.4
date     87.06.29.17.55.11;  author alex;  state Exp;
branches ;
next     3.1.2.5;

3.1.2.5
date     87.07.03.22.01.30;  author alex;  state Exp;
branches ;
next     3.1.2.6;

3.1.2.6
date     87.07.09.20.41.20;  author alex;  state Exp;
branches ;
next     ;


desc
@  Полиэкранный редактор RED
  Версия 3.
  ИАЭ им. Курчатова, Москва.
@


4.1
log
@Версия 4.1 - обкатка на UTEC, СМ
@
text
@/*
 *      Редактор RED.
 *      файл r.cmd.c - основной цикл редактора RED.
 *      $Header: r.cmd.c,v 3.13 88/03/30 17:27:41 alex Exp $
 *      $Log:	r.cmd.c,v $
 * Revision 3.13  88/03/30  17:27:41  alex
 * Исправлена ошибка в readch. Введены функции для удаления/вставки
 * строк на экране через ChangeScroll/InsertLine-DeleteLine.
 * 
 * Revision 3.1.2.6  87/07/09  20:41:20  alex
 * REVISION
 * 
 * Revision 3.1.2.5  87/07/03  22:01:30  alex
 * Graph_characters used in margin
 * 
 * Revision 3.1.2.4  87/06/29  17:55:11  alex
 * Commans set to 0200-0277
 * 
 * Revision 3.1.2.3  87/06/24  22:33:07  alex
 * New readch + gettc + tc table Tested
 * 
 * Revision 3.1.2.2  87/06/23  18:48:22  alex
 * wYNESENA PEREMENNAQ lread1 I \TO OTLAVENO
 * 
 * Revision 3.1.2.1  87/06/19  16:57:34  alex
 * Start revision for red/4
 * 
 * Revision 3.12  87/06/12  18:08:21  alex
 * Исправлены ошибки в режиме vilcase и мелочи для vt-200
 * 
 * Revision 3.11  87/06/09  19:45:45  alex
 * Исправлена работа с tty ~ VT200 и 15-ИЭ-0013
 * 
 * Revision 3.10  87/06/06  16:48:07  alex
 * Добавлен roll для терминалов с sr/sf и отображение
 *  табуляций в режиме -t + всякая мелочь
 * 
 * Revision 3.9  87/06/05  23:49:03  alex
 * Добавлен roll для терминалов с sr/sf и отображение
 *  табуляций в режиме -t + всякая мелочь
 * 
 * Revision 3.8  87/06/04  23:42:15  alex
 * Scroll on -sr- or -al/dl- added
 * 
 * Revision 3.7  87/04/02  18:35:04  alex
 * Версия для Utec слита с версией с выделением прописных букв
 *
 * Revision 3.7  87/04/01  19:13:17  alex
 * Revision for Utec: Cs, Ce, Ct, hR
 *
 * Revision 3.6  86/09/19  21:37:19  alex
 *
 *
 * Revision 3.5  86/09/19  19:49:42  alex
 * Версия для СМ-1700
 *
 * Revision 3.4  86/08/04  20:50:21  alex
 * Bepqh dk LMNQ/DELNQ 2
 *
 * Revision 3.3  86/07/24  21:07:54  alex
 * Исправлена ошибка в автоматическом сдвиге
 * (привнесена при об'единении).
 *
 * Revision 3.2  86/07/24  00:22:11  alex
 * Об'единены версии текстов для ЕС и СМ
 *
 * Revision 3.1.1.9  86/07/15  22:11:18  alex
 * RED 3.3/EC.
 *
 * Revision 3.1.1.8  86/06/25  19:40:32  alex
 * Введено автоматическое смещение экрана
 *
 * Revision 3.1.1.7  86/06/20  23:30:50  alex
 * Улучшен "editline"".
 *
 * Revision 3.1.1.6  86/06/19  00:09:42  alex
 * Отлажен на модели повтор сеанса
 *
 * Revision 3.1.1.5  86/06/16  22:15:50  alex
 * Первая версия с повтором сеанса (пока грязная)
 *
 * Revision 3.1.1.3  86/06/06  00:12:49  alex
 * Введена установка ключей
 *
 * Revision 3.1.1.2  86/06/05  18:52:38  alex
 * Отлажено_на_модели
 *
 * Revision 3.1.1.1  86/06/05  00:03:11  alex
 * Отлажено_на_модели
 *
 * Revision 3.1  86/04/20  23:40:29  alex
 * Базовая версия для ЕС.
 *
 * Revision 3.1  86/04/20  23:40:29  alex
 * *** empty log message ***
 *
 * Revision 1.4  86/04/13  21:59:31  alex
 */


#include "r.defs.h"

char use0flg; /* используется для блокировки преобразования первого имени файла при "lcase" и "red - */
int clrsw;  /* 1 - чистить окно параметров */
int csrsw;  /* 1 - показать текущую позицию меткой  */
#ifndef DEMOSES
#define NEWEDIT new_info = 1
int imodesw;/* 1 - режим вставки  */
#else DEMOSES
/* int imodesw;/* 1 - режим вставки  */
extern short zerowsflag;
static editline();
#define NEWEDIT newedit = 1
#endif DEMOSES
int oldccol;           /* используется для отметки положения курсора */
int oldcline;          /* - - / / - - */

/*
 * mainloop() -
 * основной цикл работы редактора
 */
mainloop()
{
    int i,m,first=1;
    register int j;
    int clsave,ccsave;
    int inf_wfile= -1, inf_iline= -1;
    int inf_cmark = -1, inf_lmark= -1;
    int oldautoi = -1;
    int k;
    register int lread1;
    char ich[8], *cp;
    /* Для команд с тремя вариантами аргументов */
    int (*lnfun)(),(*spfun)();
    int openlines(), openspaces(), closelines(),closespaces(),picklines(),
    pickspaces();
    /* === */
    extern int templ[4];
    struct viewport *oport;
    NEWEDIT;
    new_info = 1;
    /*
     * Обработка одного символа или команды
     * ====================================
     */
    if (cursorline== 0) oldcline = 1;
    if (cursorcol == 0) oldccol  = 1;
#ifndef lint
    goto funcdone;
#endif
    FOREVER
	{
	lread1=readch();
	if (errsw)
	{
	    errsw = 0;
	    clrsw = 1;
	    unread1(lread1);
	    goto errclear;
	}
	if (lread1 == CCQUIT)
	{
	    putline(0);
	    if (endit() == 0) goto funcdone;
	    return;
	}
	/* Обработка RETURN  */
	if (lread1 == CCRETURN )
	{
#ifdef DEMOSES
	    if ( cursorcol < 0 && curwksp->ulhccno != 0 )
		lread1 = CCLPORT;
	    else if ( cursorcol > curport->rtext)
		lread1 = CCRPORT;
	    else if ( cursorline < 0 )
		lread1 = CCMILINE;
	    else if ( cursorline > curport->btext)
		lread1 = CCPLLINE;
	    else
#endif DEMOSES
	    {
	    putline(0);
	    if(!fix_screen && (i=curwksp->ulhccno) !=0) movep(-i);
	    if ( cursorline == curport->btext)
		movew( defreturn?defreturn:defplline,1);
	    movecursor(lread1);
	    lread1= -1;
	    goto errclear;
	    }
	}
	/*
	 * Редактирование в строке. Обычные символы на ЕС
	 * могут прийти из макро.
	 */
#ifndef DEMOSES
	if ((! ISACMD(lread1)) || lread1 == CCCTRLQUOTE || lread1 == CCBACKSPACE || lread1 == CCDELCH)
#else DEMOSES
	if ((! ISACMD(lread1)) || lread1 == CCCTRLQUOTE || lread1 == CCINSERT || lread1 == CCDELCH)
#endif DEMOSES
	{
		if ( lineop(lread1)) goto contin;
		goto newnumber;
	}
	/*
	 * Если команда перемещения
	 */
	if (ISACMD(lread1) && lread1<=CCBACKTAB) {
	    i=movecursor(fix_screen?lread1:lread1|MOVE_NOFIX);
	    if(i != -1 ) lread1 = i; else {
		if ((lread1) <= VMOTCODE+CC ) {
		    putline(0);
		    goto newnumber;
		}
		autoindent = cursorcol;
		goto newnumber;
	    }
	}
	/* Если граница поля */
	if (cursorcol > curport->rtext) poscursor(curport->rtext,cursorline);
	putline(0);
	switch (lread1)
	{
	case CCENTER:
	    if(need_box) drawport(curport,0);
	    goto gotarg;
	case CCLPORT:
	    movep(- deflport);
	    goto newnumber;
	case CCSETFILE:
	    switchfile(); NEWEDIT;
	    goto funcdone;
	case CCCHPORT:
	    chgport(-1);NEWEDIT;
	    goto newnumber;
	case CCOPEN:
	    if (openwrite[curfile]==0)  goto nowriterr;
	    openlines(curwksp->ulhclno + cursorline,definsert);
	    goto newnumber;
	case CCMISRCH:
	    search(-1);
	    goto funcdone;
	case CCCLOSE:
	    if (openwrite[curfile]==0)
		goto nowriterr;
	    closelines(curwksp->ulhclno + cursorline, defdelete);
	    goto newnumber;
	case CCPUT:
	    if (openwrite[curfile]==0)
		goto nowriterr;
	    if (pickbuf->nrows == 0) goto nopickerr;
	    put(pickbuf,curwksp->ulhclno+cursorline,
	    curwksp->ulhccno+cursorcol);
	    goto newnumber;
	case CCPICK:
	    picklines(curwksp->ulhclno + cursorline, defpick);
	    goto newnumber;
#ifndef DEMOSES
	case CCINSMODE:
	    imodesw = 1 - imodesw;  /* change it */
	    goto funcdone;
#endif DEMOSES
	case CCGOTO:
	    gtfcn(0);
	    goto newnumber;
	case CCMIPAGE:
	    movew(- defmipage * (1+curport->btext),0);
	    goto newnumber;
	case CCPLSRCH:
	    search(1);
	    goto funcdone;
	case CCRPORT:
	    movep(defrport);
	    goto newnumber;
	case CCPLLINE:
	    movew(PL1MOVEW,fix_screen);
	    goto newnumber;
	case CCDELCH:
	    goto notimperr;
	case CCSAVEFILE:
	    savefile(NULL,curfile);
	    goto funcdone;
	case CCMILINE:
	    movew(MI1MOVEW,fix_screen);
	    goto newnumber;
	case CCDOCMD:
	    goto notstrerr;
	case CCPLPAGE:
	    movew(defplpage * (1+curport->btext),0);
	    goto newnumber;
	case CCMAKEPORT:
	    if(need_box) drawport(curport,0);
	    makeport(deffile); NEWEDIT;
	    goto funcdone;
	case CCTABS:
	    settab(curwksp->ulhccno + cursorcol);
	    goto newnumber;
	case CCRESCREEN:
	    rescreen(0);
	    goto funcdone;
	    /*    case CCMOVELEFT:        */
	    /*    case CCTAB:             */
	    /*    case CCMOVEDOWN:        */
	    /*    case CCHOME:            */
	    /*    case CCRETURN:  */
	    /*    case CCMOVEUP:  */
	    /*    case CCINSERT:  */
	default:
	    goto badkeyerr;
	}
	/* Повтор ввода аргумента */
reparg:
	lread1=readch();
	if(ISACMD(lread1)) goto yesarg;
	else goto noargerr;
	/*
	 * Дай аргумент!
	 */
gotarg:
	lread1=param(0);
yesarg:
	if (lread1 == CCQUIT )
	{
	    if (paraml>0 && (dechars(paramv,paraml),*paramv) == 'a')
	    {
		if (*(paramv+1) != 'd') return;
		cleanup();
		inputfile = -1; /* to force a dump */
		fatal("ABORTED");
	    }
	    if (endit() == 0) goto funcdone;
	    return;
	}
	switch (lread1)
	{
	case CCENTER:
	    goto funcdone;
	case CCLPORT:
	    if (paramtype <= 0)  goto notstrerr;
	    if (s2i(paramv,&i)) goto notinterr;
	    movep(-i);
	    goto funcdone;
	case CCSETFILE:
	    if (paramtype <=  0)  goto notstrerr;
	    if (paramv == 0) goto noargerr;
	    if ( use0flg || !inputfile)
		dechars(paramv,paraml);
	    use0flg=1;NEWEDIT;
	    editfile(paramv,0,0,1,1);
	    goto funcdone;
	case CCCHPORT:
	    if (paramtype <= 0)  goto notstrerr;
	    if (s2i(paramv,&i)) goto notinterr;
	    if (i <= 0) goto notposerr;
	    chgport(i-1); NEWEDIT;
	    goto funcdone;
	case CCOPEN:
	    if (openwrite[curfile]==0)  goto nowriterr;
	    if (paramtype == 0) {
		splitline(curwksp->ulhclno + paramr0,
		paramc0 + curwksp->ulhccno);
		goto funcdone;
	    }
	    else {
		lnfun = openlines;
		spfun = openspaces;
		goto spdir;
	    };
	case CCMISRCH:
	case CCPLSRCH:
	    if (paramtype <= 0)  goto notstrerr;
	    if (paramv == 0) goto noargerr;
	    if (searchkey) free((char *)searchkey);
	    searchkey = paramv;
	    paraml = 0;
	    search(lread1==CCPLSRCH?1:-1);
	    goto funcdone;
	case CCCLOSE:
	    if (openwrite[curfile]==0)  goto nowriterr;
	    if (paramtype == 0) combineline(curwksp->ulhclno + paramr0,
	    paramc0 + curwksp->ulhccno);
	    else {
		if(paramtype > 0 && paramv && paramv[0]=='>')
		{
		    msrbuf(deletebuf,paramv+1,0);
		    goto funcdone;
		}
		lnfun = closelines;
		spfun = closespaces;
		goto spdir;
	    }
	    goto funcdone;
	case CCPUT:
	    if (paramtype >  0 && paramv && paramv[0]=='$' )
	    {
		if (msrbuf(pickbuf,paramv+1,1))goto errclear;
		goto funcdone;
	    }
	    if (paramtype != 0)  goto notstrerr;
	    if (openwrite[curfile]==0)
		goto nowriterr;
	    if (deletebuf->nrows == 0) goto nodelerr;
	    put(deletebuf,curwksp->ulhclno+cursorline,
	    curwksp->ulhccno+cursorcol);
	    goto funcdone;
	case CCTAB:
	case CCMOVELEFT:
	case CCMOVEDOWN:
	case CCHOME:
	case CCMOVEUP:
	case CCMOVERIGHT:
	case CCBACKTAB:
	    if (s2i(paramv,&i)) goto notinterr;
	    if (i <= 0) goto notposerr;
	    m = ((lread1<=BT) ? lread1:0);
	    while (--i >= 0) movecursor(m);
	    goto funcdone;
	case CCRETURN:
	    if(paramtype <=0|| !paramv) goto notimperr;
	    dechars(paramv,paraml);
	    switch (paramv[0])
	    {
	    case '-': case '+':
		lread1 = -1;
		new_info = 1;
		if ( !(lread1=setkeys(paramv))) goto noargerr;
		if(lread1 != -1) rescreen(0);
		goto funcdone;
	    case '>':
		msvtag(paramv+1);
		goto funcdone;
	    case '$':
		if(mdeftag(paramv+1)){
		    lread1= -1;
		    goto reparg;
		}
		else goto funcdone;
	    case 'k':
		defkey();
		goto funcdone;
	    case 's':
		tostop();
	    case 'r':
		rescreen(0); goto funcdone;
	    case 'd':
		if(paramv[1]==' ') defmac(&paramv[2]);
		goto funcdone;
	    case 'q':
		lread1=CCQUIT;
		if(paramv[1]=='a') {
		    return;
		}
		unread1(lread1);
		goto contin;
	    default:
		goto noargerr;
	    }
	case CCPICK:
	    if (paramtype == 0) goto notimperr;
	    if (paramtype > 0 && paramv && paramv[0]=='>')
	    {
		msrbuf(pickbuf,paramv+1,0);
		goto funcdone;
	    }
	    lnfun = picklines;
	    spfun = pickspaces;
	    goto spdir;
#ifndef DEMOSES
	case CCINSMODE:
	    imodesw = 1 - imodesw;  /* Щелкнем!! */
#else DEMOSES
	case CCINSERT:
	    if (paramtype > 0)
	    {
		if (s2i(paramv,&i)) goto notinterr;
		dflinsert = i;
	    }
	    else dflinsert = 1;
#endif DEMOSES
	    goto funcdone;
	case CCGOTO:
	    if (paramtype == 0) gtfcn(nlines[curfile]);
	    else if (paramtype > 0)
	    {
		if(paramv && paramv[0]=='$') {
		    mgotag(paramv+1);
		    goto funcdone;
		}
		if (s2i(paramv,&i)) goto notinterr;
		gtfcn(i-1);
	    }
	    else goto noargerr;
	    goto funcdone;
	case CCMIPAGE:
	    if (paramtype <= 0)  movew(cursorline - curport->btext,0);
	    if (s2i(paramv,&i)) goto notinterr;
	    movew(- i * (1 + curport->btext),0);
	    goto funcdone;
	case CCRPORT:
	    if (paramtype <= 0)  goto notstrerr;
	    if (s2i(paramv,&i)) goto notinterr;
	    movep(i);
	    goto funcdone;
	case CCPLLINE:
	    if (paramtype < 0)  goto notstrerr;
	    else if (paramtype == 0)  movew(cursorline,1);
	    else if (paramtype > 0)
	    {
		if (s2i(paramv,&i)) goto notinterr;
		movew(i,1);
	    }
	    goto funcdone;
	case CCDELCH:
	    lineop(CCTRUNCATE);
	    goto funcdone;
	case CCSAVEFILE:
	    if (paramtype <=  0)  goto notstrerr;
	    if (paramv == 0) goto noargerr;
	    dechars(paramv,paraml);
	    savefile(paramv,curfile);
	    goto funcdone;
	case CCMILINE:
	    if (paramtype < 0)  goto notstrerr;
	    else if (paramtype == 0)  movew(cursorline - curport->btext,1);
	    else if (paramtype > 0)
	    {
		if (s2i(paramv,&i)) goto notinterr;
		movew(-i,1);
	    }
	    goto funcdone;
	case CCDOCMD:
	    if(paramtype<=0) goto notstrerr;
	    dechars(paramv,paraml);
	    if (openwrite[curfile] == 0) goto nowriterr;
	    callexec();
	    goto funcdone;
	case CCPLPAGE:
	    if (paramtype <= 0)  movew(cursorline,0);
	    if (s2i(paramv,&i)) goto notinterr;
	    movew(i * (1 + curport->btext),1);
	    goto funcdone;
	case CCMAKEPORT:
	    if (paramtype == 0)  removeport();
	    else if (paramtype <  0)  goto notstrerr;
	    else {
		dechars(paramv,paraml);
		makeport(paramv);
	    }
	    NEWEDIT;
	    goto funcdone;
	case CCTABS:
	    clrtab(curwksp->ulhccno + cursorcol);
	    goto funcdone;
	case CCRESCREEN:
	    rescreen(0);
	    goto funcdone;
	default:
	    goto badkeyerr;
	}
spdir:
	if (paramtype > 0)
	{
	    if(paramv[0] == '$')
	    {
		if(mdeftag(paramv+1)) goto spdir;
		else goto funcdone;
	    }
	    if (s2i(paramv,&i)) goto notinterr;
	    if (i <= 0) goto notposerr;
	    (*lnfun)(curwksp->ulhclno + cursorline, i);
	}
	else
	{
	    if (paramc1 == paramc0)
	    {
		(*lnfun)(curwksp->ulhclno+paramr0,
		(paramr1-paramr0)+1);
	    }
	    else (*spfun)(curwksp->ulhclno + paramr0,
	    curwksp->ulhccno + paramc0,
	    (paramc1-paramc0),
	    (paramr1-paramr0) + 1);
	}
	goto funcdone;
badkeyerr:
	error(DIAG("Illegal key or unnown macro","Неизвестная клавиша или макро"));
	goto funcdone;
notstrerr:
	error(DIAG("Argument must be a string.","Аргумент должен быть строкой"));
	goto funcdone;
noargerr:
	error(DIAG("Invalid argument.","Плохой аргумент"));
	goto funcdone;
notinterr:
	error(DIAG("Argument must be numerik.","Аргумент должен быть числом"));
	goto funcdone;
notposerr:
	error(DIAG("Argument must be positive.","Аргумент должен быть положительным"));
	goto funcdone;
nopickerr:
	error(DIAG("Nothing in the pick buffer.","Буфер вставок пуст"));
	goto funcdone;
nodelerr:
	error (DIAG("Nothing in the close buffer.","Буфер убранных строк пуст"));
	goto funcdone;
notimperr:
	error(DIAG("Feature not implemented yet.","Еще не определено."));
	goto funcdone;
nowriterr:
	error(DIAG("You cannot modify this file!","Вы не можете изменить этот файл."));
	goto funcdone;
funcdone:
	clrsw = 1;
newnumber:
	lread1 = -1;        /* signify char read was used */
errclear:
	oport = curport;
	k = cursorline;
#ifdef DEMOSES
	if ( newedit ) {
		newedit = 0;
		if ( openwrite[curfile] ) editwind(curport,editline,zerowsflag);
		else editwind((struct viewport *)0,(int (*)())0,0);
		}
#endif DEMOSES
/*
 * Алгоритм для перерисования рамок и номера -
 * если только что был сдвиг, то блокируем
 */
	if(need_box && need_box++ !=1) drawport(curport,0);
	if(need_box != 2 ) {
	    j = cursorcol;
	    switchport(&paramport);
	    paramport.redit = PARAMRINFO;   /* !!! */
	    if (clrsw || new_info)
	    {
		if (!errsw && !first)
		{
		    poscursor(0,0);
		    if ( !new_info || !putcha(COCLLIN))
			    putblanks(PARAMREDIT);
		}
    /*            poscursor(PARAMREDIT+2,0);  */
    /*            info(DIAG("line ","строка: "),PARAMRINFO);        */
		ccsave = PARAMREDIT+2/* cursorcol */;
		clsave = 0 /* cursorline */;
		if (oport->wksp->wfile&&(oport->wksp->wfile != inf_wfile||new_info))
		{
		    poscursor(PARAMREDIT+8,0);
		    inf_wfile = oport->wksp->wfile;
		    info(DIAG(" file "," файл "),PARAMRINFO);
		    info(openfnames[inf_wfile],PARAMRINFO);
		    putblanks(PARAMRINFO-cursorcol);
		}
		first=0;
	    }
	    i = oport->wksp->ulhclno + k + 1; /* Рисуем номер строки */
	    if ( i != inf_iline || new_info) {
		inf_iline = i;
		poscursor(ccsave,clsave);
		cp = ich + 6;
		*--cp = '\0';
		do
		    (*--cp = '0' + (i % 10));
		while (i = i/10);
		info(cp,PARAMRINFO);
		*cp = '\0';
		while (cp != ich) *--cp = ' ';
	    info(ich,PARAMRINFO);
	    }
	    switchport(oport);
	    paramport.redit = PARAMREDIT;
	    if (new_info ||
		 ((on_autoi || inf_lmark != -1)&&oldautoi != autoindent)
		) {
		switchport(&wholescreen);
		if(inf_lmark != -1) {
			poscursor(inf_cmark,inf_lmark);
			putch(BMCH,A_MARG);
			inf_lmark = -1;
		}
		if(on_autoi&&oport->bmarg !=oport->ttext+oport->btext) {
			    inf_cmark = oport->ltext+autoindent;
			    inf_lmark = oport->bmarg;
			    poscursor(inf_cmark,inf_lmark);
			    putcha(COOPEN);
			    putch(AMCH,A_INFO);
			    putcha(COCLOSE);
			    }
		switchport(oport);
		oldautoi = autoindent;
		}
	    poscursor(j,k);
	    if (csrsw)
	    {
		putch(COCURS,1);
		poscursor(j,k);
		dumpcbuf(1);
		sleep(1);
		putup(k,k);
		poscursor(j,k);
	    }
#ifndef DEMOSES
	if (imodesw && (new_info || clrsw) && !errsw)
            telluser(DIAG("     ***** i n s e r t m o d e *****","  * * * * режим вставки * * * * "),0);
#endif DEMOSES
	csrsw = clrsw = new_info = 0;
	}
contin:   
        ;
    }
}

#ifdef DEMOSES
/*
 * editline(номер,строка)
 * Редактировать строку "номер" в текущем окне.
 * Заменить ее на "строка"
 */
static editline(ln,str,lnos)
int ln,lnos;
char *str;
{
    register int i;register char *cp;
    int lno; /* Номер в файле */
    int slen; /* Длина str */
    int scolno; /* Начальная колонка str */
    int newnline; /* Новая длина строки */
    /*
     * 1. Дай строку
     */
    lno = ln + curwksp->ulhclno;
    if ( lno != clineno ) putline(0), getline(lno);
    /*
     * 2. Определить длину новой строки без хвостовых пробелов.
     */
    scolno = curwksp->ulhccno;
    if ( ncline-1 <= scolno+(curport->rtext+1) ){
	slen = lnos;
	newnline = scolno + slen+1;
    } 
    else {
	slen = curport->rtext+1;
        newnline = ncline;
    }
    if ( lcline-2 < newnline ) excline(newnline+2);
    /*
     * 3. Заменяем часть строки
     */
    i = ncline-1;
    while ( i < scolno ) cline[i++] = ' ';
    for ( i = 0, cp = str; i < slen; i++ ) {
	cline[scolno+i] = (*cp?*cp++:' ');/* Becь xвocт зaбивaeм пpoбeлaми*/
    }
    ncline = newnline;
    cline[ncline-1]=012;
    fcline = 1;
 /*
  * Учитывая особенности терминала, устанавливаем режим - стирай все!
  */
    if ( !speccase )  {
	curport->firstcol[ln] = 0; curport->lastcol[ln]= slen;
	putup(ln,ln);
    } else
    putup(-1, ln);
    return;
}

/*
 * lineop(символ) - для ЕС
 * Выполнение простейших операций в строке.
 * В конце сбрасывает lread1.
 */
lineop(lr1)
register lr1;
{
	register int i,k;
	int thiscol, thisrow;
	/* Введем курсор в его границы */
	movecursor(0);
	if (openwrite[curfile] == 0) goto nowriterr;
	/* Строки у нас нет? Дай! */
	if (clineno != (i = curwksp->ulhclno+cursorline)) {
		if (fcline) putline(0);
		getline(i);
	}
	/* исключение символа */
	if (lr1==CCDELCH )
	{
		thiscol = cursorcol + curwksp->ulhccno;
		thisrow = cursorline;
		if (ncline < thiscol + 2)
			goto contin;
		for (i=thiscol;i<ncline-2;i++) cline[i] = cline[i+1];
		ncline--;
		thiscol -= curwksp->ulhccno;
		putup(-1,cursorline);
		poscursor(thiscol,thisrow);
		fcline = 1;
		goto contin;
	}
	/* Проверка на границу окна - для МАКРО */
	if (cursorcol > curport->rtext)
	{
		if (fcline) {
			putline(0);
			movep(defrport);
			goto contin;
		}
		else  goto margerr;
	}
	fcline = 1;
	/* Если строка удлинилась - отведем еще память */
	if ((i = cursorcol + curwksp->ulhccno ) >=
	    (lcline - 2)) excline(i+2);
	if (i >= ncline-1)
	{
		for (k=ncline-1; k<=i; k++) cline[k] = ' ';
		cline[i+1] = NEWLINE;
		ncline = i+2;
	}
	/* Вставка пробелов */
	if (lr1==CCINSERT)
	{
		thiscol = cursorcol + curwksp->ulhccno;
		thisrow = cursorline;
		if (ncline+dflinsert > lcline) excline(ncline+dflinsert);
		for (i=ncline-1;i >= thiscol;i--) cline[i+dflinsert]=cline[i];
		ncline += dflinsert;
		for ( i=0;i<dflinsert;i++) cline[i+thiscol] = ' ';
		thiscol -= curwksp->ulhccno;
		putup(-1,cursorline);
		poscursor(thiscol,thisrow);
		goto contin;
	}
	/* Выставим границу */
	if (cursorcol >= curport->rtext)
		curport->redit = curport->rtext + 1;
	/* Замена символа */
	if(lr1==CCCTRLQUOTE) lr1 = esc0;
	cline[i] = lr1;
	putch(lr1,1);
	/* Если переехали границу */
	curport->redit = curport->rtext;
	goto contin;
margerr:
	error("Margin stusk; move cursor to free.");
	goto errdone;
nowriterr:
	error(DIAG("You cannot modify this file!","Вы не можете изменить этот файл."));
	goto errdone;
errdone:
	/*lread1 = -1;  */
	return(1);
contin:
	/*lread1 = -1;  */
	return(0);
}

#else  NOT DEMOSES

/*
 * lineop(символ) - для СМ
 * Выполнение простейших операций в строке.
 * В конце сбрасывает lr1.
 */
lineop(lr1)
register lr1;
{
	register int i,k;
	int thiscol, thisrow,j;
repop:
	/* Отмена в 1 колонке */
	if (lr1 == CCBACKSPACE  &&  cursorcol == 0)
	{
		goto contin;
	}
	if (openwrite[curfile] == 0) goto nowriterr;
	/* Строки у нас нет? Дай! */
	if (clineno != (i = curwksp->ulhclno+cursorline)) getline(i);
	/* исключение символа */
	if (lr1==CCDELCH || (imodesw && lr1==CCBACKSPACE) || lr1==CCTRUNCATE)
	{
		thiscol = cursorcol + curwksp->ulhccno;
		thisrow = cursorline;
		if (lr1 == CCBACKSPACE) thiscol--;
		if (ncline < thiscol + 2)
		{
			if (lr1 == CCBACKSPACE) movecursor(LT);
			lr1 = -1;
			goto contin;
		}
		if(lr1 == CCTRUNCATE) {
			cline[thiscol] = cline[ncline-1];
			ncline = thiscol+1;
		} else
		{
			for (i=thiscol;i<ncline-2;i++) cline[i] = cline[i+1];
			ncline--;
		}
		thiscol -= curwksp->ulhccno;
		putup(-(1+thiscol),cursorline);
		poscursor(thiscol,thisrow);
		fcline = 1;
		goto contin;
	}
	/* Проверка на границу окна */
	if (cursorcol > curport->rtext)
	{
		if (fcline) {
			putline(0);
			movep(defrport);
			goto repop;
		}
		else  goto margerr;
	}
	fcline = 1;
	if (j = (lr1 == CCBACKSPACE))
	{
		movecursor(LT);
		lr1 = ' ';
	}
	if ((i = cursorcol + curwksp->ulhccno) >=
	    (lcline - 2)) excline(i+2);
	if (i >= ncline-1)
	{
		for (k=ncline-1; k<=i; k++) cline[k] = ' ';
		cline[i+1] = NEWLINE;
		ncline = i+2;
	}
	else if (imodesw)
	{
		thiscol = cursorcol + curwksp->ulhccno;
		thisrow = cursorline;
		if (ncline >= lcline) excline(ncline+1);
		for (i=ncline;i>thiscol;i--) cline[i] = cline[i-1];
		ncline++;
		thiscol -= curwksp->ulhccno;
		putup(-(1+thiscol),cursorline);
		poscursor(thiscol,thisrow);
	}
	/* Выставим границу */
	if (cursorcol >= curport->rtext)
		curport->redit = curport->rtext + 1;
	/* Замена символа */
	if(lr1==CCCTRLQUOTE) lr1 = esc0;
	if (cursorcol == curport->rtext - 10) putcha(COBELL);
	cline[i] = lr1;
	putch(lr1,1);
	/* Если переехали границу */
	curport->redit = curport->rtext;
	if (j) movecursor(LT);
	lr1 = -1;
	goto contin;
margerr:
error("Margin stusk; move cursor to free.");
goto errdone;
nowriterr:
error(DIAG("You cannot modify this file!","Вы не можете изменить этот файл."));
goto errdone;
errdone:
return(0);
contin:
return(1);
}
#endif DEMOSES

/*
 * search(delta) -
 * поиск вперед/назад в файле
 * delta =  1  / -1
 * Установить окно, если нужно, и показать
 * место найденного текста.
 * Ищется "searchkey"
 */
search(delta)
int delta;
{
    register char *at,*sk,*fk;
    int ln,lkey,col,lin,slin,i;
    paraml = 0;
    if (searchkey == 0 || *searchkey == 0)
    {
        error(DIAG("Nothing to search for.","А что искать?"));
        return;
    }
    col = cursorcol;
    slin = lin = cursorline;
    if (delta == 1) telluser("+",0);
    else telluser("-",0);
    telluser(DIAG("search: ","поиск: "),1);
    i=lcasef; 
/* --- */
    lcasef=0; /* Внутренняя форма текста: */
    telluser(searchkey,9);
    lcasef =i;
/* --- */
    putch(COCURS,1);
    poscursor(col,lin);
    dumpcbuf(1);
    lkey = 0;
    sk = searchkey;
    while (*sk++) lkey++;
    getline (ln = lin + curwksp->ulhclno);
    putline(0);
    at = cline + col + curwksp->ulhccno;
    FOREVER
        {
        at += delta;
        while (at <  cline || at >  cline + ncline - lkey)
        {
	    /* Прервать, если было прерывание с терминала */
            if ((i=intrup()) || (ln += delta) < 0 ||
                (wposit(curwksp,ln) && delta == 1))
            {
                putup(lin,lin);
                poscursor(col,lin);
                error(i?"Interup.":DIAG("Search key not found.","Текст не найден."));
                csrsw = 0; 
                return;
            }
            getline(ln);
            putline(0);
            at = cline;
            if (delta < 0) at += ncline - lkey;
        }
        sk = searchkey;
        fk = at;
        while (*sk == *fk++ && *++sk);
        if (*sk == 0)
        {
            cgoto(ln,at-cline,slin,0);
            csrsw = 1;  /* put up a bullit briefly */
            return;
        }
    }
}


/*
 * settab(tabcol) -
 * добавить точку табуляции
 */
settab(tabcol)
int tabcol;
{
    register int i, j;
    if (tabstops[NTABS-1] == BIGTAB)
    {
        error(DIAG("Too many tabstops; can't set more.","Много табуляций."));
        return;
    }
    for (i=0;i<NTABS;i++)
    {
        if (tabstops[i] == tabcol) return;
        if (tabstops[i] >  tabcol)
        {
            for (j=NTABS-1;j>i;j--) tabstops[j] = tabstops[j-1];
            tabstops[i] = tabcol;
            return;
        }
    }
    error("Error in settab!");
    return;
}

/*
 * clrtab(tabcol) -
 * убрать табуляцию tabcol
 */
clrtab(tabcol)
int tabcol;
{
    register int i,j;
    for (i=0;i<NTABS;i++) if (tabstops[i] == tabcol)
    {
        for (j=i;j<NTABS-1;j++) tabstops[j] = tabstops[j+1];
        tabstops[NTABS-1] = 0;
        return;
    }
    return;
}

/*
 * callexec() -
 * Выполнить команду "exec"
 * Ответ 1, если не было ошибок
 */
#define NARGS 20
callexec()
{
    register int i; 
    char **execargs;
    register char *cp, **e;
    int j,k,m,pipef[2];
    char pwbuf[100];
    /*
     * 1. Разбираем размер области.
     */
    i = curwksp->ulhclno + cursorline;
    m = 1;
    cp = paramv;
    if (*cp == '-' || (*cp >= '0' && *cp <= '9')) {
        cp = s2i(paramv,&m);
        if (cp == 0) goto noargerr;
    }
    m = -m;           /* По умолчанию - 1 параграф */
    if (*cp == 'l') {
        cp++; 
        m = -m; 
    }  /* _nl ==  -_n */
    /*
     * 2. Готовим строку аргументов.
     */
    e = execargs = (char **)salloc(NARGS*(sizeof (char *)));
    while (*cp == ' ') cp++;
    while (*cp != 0) {
        *e++ = cp;              /* адрес аргумента */
	if ((e-execargs) >= NARGS) goto noargerr; /* Слишком много */
        if (*cp == '"') {
            cp++;
            e[-1]++;
            while (*cp++ !=  '"')
                if (*cp == 0) goto noargerr;
            cp[-1] = 0;
        }
        else if (*cp++ == '\'') {
            e[-1]++;
            while (*cp++ !=  '\'')
                if (*cp == 0) goto noargerr;
            cp[-1] = 0;
        }
        else while (*cp != ' ' && *cp != ',' && *cp) cp++;
        while (*cp == ' ' || *cp == ',') *cp++ = 0;
    }
    *e = 0;
    /*
     * 3. Запускаем команду через pipe
     * (red) | (команда;red)
     * Вторая копия red занимается тем, что дочитывает
     * остаток информации из трубы.
     */
    if (pipe(pipef) == -1) goto nopiperr;
    if ((j = fork()) == -1) goto nopiperr;
    if (j == 0) {                   /* команда;red */
        close(0);               /* Замыкаем в станд. ввод */
        dup(pipef[0]);
        close(1);               /* Вывод в рабочий файл */
        open(tmpname,1);
        seek(1,tempfh,3);
        seek(1,tempfl,1);
        j = 2;
    /* Закрываем все, что осталось открыто */
        while ((k = dup(1)) >= 0) if (k > j) j = k;
        while (j >= 2) close(j--);
        if ((i = fork()) == -1) goto nopiperr;
        if (i != 0) {           /* ;red   */
            while (wait(&m) != i);  /* Ждем, затем читаем */
            while (read(0,pwbuf,100)); /* Пока не надоест */
            exit(m >> 8);        /* И возвр. статус      */
        }
        execr(execargs);
        /* exit теперь в EXECR, -1 если ошибка */
    }
    /* Отец: */
    telluser(DIAG("Executing ...","Выполнение ..."),0);
    dumpcbuf(1);
    free((char *)execargs);
    doreplace(i,m,j,pipef);
    return(1);
nopiperr:
    error(DIAG("Can not fork or write pipe.","Ошибка записи"));
    return(0);
noargerr:
    error(DIAG("Invalid argument.","ошибка в аргументе."));
    return(0);
}
@


3.13
log
@Исправлена ошибка в readch. Введены функции для удаления/вставки
строк на экране через ChangeScroll/InsertLine-DeleteLine.
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1.2.6 87/07/09 20:41:20 alex Exp $
d6 4
@


3.12
log
@Исправлены ошибки в режиме vilcase и мелочи для vt-200
@
text
@d2 1
a2 1
 *      Редактор RED. ИАЭ им. И.В. Курчатова, ОС ДЕМОС
d4 1
a4 1
 *      $Header: r.cmd.c,v 3.11 87/06/09 19:45:45 alex Exp $
d6 21
d103 1
a103 1
#define NEWEDIT
d127 1
a127 3
    /* Хитрости с экономией памяти */
    register int *lre1= &lread1;
#define lread1 (*lre1)
d149 1
a149 1
	read1();
d154 1
d192 1
a192 1
	if ((! CTRLCHAR) || lread1 == CCCTRLQUOTE || lread1 == CCBACKSPACE || lread1 == CCDELCH)
d194 1
a194 1
	if ((! CTRLCHAR) || lread1 == CCCTRLQUOTE || lread1 == CCINSERT || lread1 == CCDELCH)
d197 1
a197 1
		if ( !lineop(lread1)) goto contin;
d203 1
a203 1
	if (lread1<=BT) {
d206 1
a206 1
		if (lread1 <= VMOTCODE ) {
a210 1
		lread1 = -1;
d308 2
a309 2
	read1();
	if(CTRLCHAR) goto yesarg;
d315 1
a315 1
	param(0);
d421 1
a421 1
		if ( setkeys(paramv)) goto noargerr;
d448 1
d510 1
a510 1
	    goto newnumber;
d674 1
a674 1
			putch(BMCH,0);
d682 1
a682 1
			    putch(AMCH,0);
a706 1
#undef lread1
d848 1
a848 1
	lread1 = -1;
d851 1
a851 1
	lread1 = -1;
a870 1
		lr1 = -1;
a899 1
		lr1 = -1;
d957 2
a958 1
lread1 = -1;
a959 3
contin:
lread1 = -1;
return(0);
a1014 1
                symac = 0;
a1172 1
/*   Руднев А.П. Москва, ИАЭ им. Курчатова, 1984 */
@


3.11
log
@Добавлен roll для терминалов с sr/sf и отображение
 табуляций в режиме -t + всякая мелочь
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.10 87/06/06 16:48:07 alex Exp $
d6 3
d615 2
a616 2
		    if(!new_info || !putcha(COCLLIN))
					  putblanks(PARAMREDIT);
@


3.10
log
@Добавлен roll для терминалов с sr/sf и отображение
 табуляций в режиме -t + всякая мелочь
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.9 87/06/05 23:49:03 alex Exp $
d6 4
d612 2
a613 1
		    putblanks(PARAMREDIT);
@


3.9
log
@Добавлен roll для терминалов с sr/sf и отображение
 табуляций в режиме -t + всякая мелочь
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.8 87/06/04 23:42:15 alex Exp $
d6 4
d96 2
d154 1
a154 1
		movew(/* PL1MOVEW*/ defplline,1);
d181 1
a181 4
#ifndef DEMOSES
		    if(curspos)
#endif DEMOSES
			    goto newnumber;
d183 1
d394 1
d640 20
@


3.8
log
@Scroll on -sr- or -al/dl- added
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.7 87/04/02 18:35:04 alex Exp $
d6 3
a116 1
	csrsw = clrsw = new_info = 0;
d148 1
a148 1
		movew(PL1MOVEW,1);
d181 1
a181 1
		goto contin;
d190 1
d257 1
d389 1
d391 1
d477 2
a478 1
	    goto notimperr;
d589 10
a598 6
	j = cursorcol;
	switchport(&paramport);
	paramport.redit = PARAMRINFO;   /* !!! */
	if (clrsw || new_info)
	{
	    if (!errsw && !first)
d600 31
a630 29
		poscursor(0,0);
		putblanks(PARAMREDIT);
            }
/*            poscursor(PARAMREDIT+2,0);  */
/*            info(DIAG("line ","строка: "),PARAMRINFO);        */
	    ccsave = PARAMREDIT+2/* cursorcol */;
	    clsave = 0 /* cursorline */;
	    if (oport->wksp->wfile&&(oport->wksp->wfile != inf_wfile||new_info))
            {
		poscursor(PARAMREDIT+8,0);
		inf_wfile = oport->wksp->wfile;
		info(DIAG(" file "," файл "),PARAMRINFO);
		info(openfnames[inf_wfile],PARAMRINFO);
		putblanks(PARAMRINFO-cursorcol);
            }
            first=0;
        }
	i = oport->wksp->ulhclno + k + 1; /* Рисуем номер строки */
	if ( i != inf_iline || new_info) {
	    inf_iline = i;
	    poscursor(ccsave,clsave);
	    cp = ich + 6;
	    *--cp = '\0';
	    do
		(*--cp = '0' + (i % 10));
	    while (i = i/10);
	    info(cp,PARAMRINFO);
	    *cp = '\0';
	    while (cp != ich) *--cp = ' ';
d633 12
a644 12
        switchport(oport);
        paramport.redit = PARAMREDIT;
        poscursor(j,k);
        if (csrsw)
        {
            putch(COCURS,1);
            poscursor(j,k);
	    dumpcbuf(1);
            sleep(1);
            putup(k,k);
            poscursor(j,k);
        }
d646 1
a646 1
        if (imodesw && clrsw && !errsw)
d649 2
d826 1
a826 1
	if (lr1==CCDELCH || (imodesw && lr1==CCBACKSPACE) )
d837 8
a844 2
		for (i=thiscol;i<ncline-2;i++) cline[i] = cline[i+1];
		ncline--;
@


3.7
log
@Версия для Utec слита с версией с выделением прописных букв
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.7 87/04/01 19:13:17 alex Exp $
d6 3
d11 1
a11 1
 * 
d13 2
a14 2
 * 
 * 
d17 1
a17 1
 * 
d20 1
a20 1
 * 
d24 1
a24 1
 * 
d27 1
a27 1
 * 
d30 1
a30 1
 * 
d33 1
a33 1
 * 
d36 1
a36 1
 * 
d39 1
a39 1
 * 
d42 1
a42 1
 * 
d45 1
a45 1
 * 
d48 1
a48 1
 * 
d51 1
a51 1
 * 
d54 1
a54 1
 * 
d57 1
a57 1
 * 
d88 1
d102 1
d113 11
a123 11
        {
        csrsw = clrsw = 0;
        read1();
        if (errsw)
        {
            errsw = 0;
            clrsw = 1;
            goto errclear;
        }
        if (lread1 == CCQUIT)
        {
d125 3
a127 3
            if (endit() == 0) goto funcdone;
            return;
        }
d129 2
a130 2
        if (lread1 == CCRETURN )
        { 
d143 7
a149 7
            putline(0);
            if ( cursorline == curport->btext)
                movew(defplline);
            if((i=curwksp->ulhccno) !=0) movep(-i);
            movecursor(lread1);
            lread1= -1;
            goto errclear;
d152 1
a152 1
        /*
d155 1
a155 1
         */
d157 1
a157 1
        if ((! CTRLCHAR) || lread1 == CCCTRLQUOTE || lread1 == CCBACKSPACE || lread1 == CCDELCH)
d163 1
a163 1
		goto funcdone;
d165 8
a172 7
        /*
         * Если команда перемещения
         */
        if (lread1<=BT) {
            movecursor(lread1);
            if (lread1 <= VMOTCODE ) { 
                putline(0);
d174 1
a174 1
		if(curspos)
d176 17
a192 16
			goto newnumber;
            }
            lread1 = -1;
            goto contin;
        }
        /* Если граница поля */
        if (cursorcol > curport->rtext) poscursor(curport->rtext,cursorline);
        putline(0);
        switch (lread1)
        {
        case CCENTER:
            goto gotarg;
        case CCLPORT:
            movep(- deflport);
            goto funcdone;
        case CCSETFILE:
d194 2
a195 2
            goto funcdone;
        case CCCHPORT:
d197 23
a219 23
            goto funcdone;
        case CCOPEN:
            if (openwrite[curfile]==0)  goto nowriterr;
            openlines(curwksp->ulhclno + cursorline,definsert);
            goto funcdone;
        case CCMISRCH:
            search(-1);
            goto funcdone;
        case CCCLOSE:
            if (openwrite[curfile]==0)
                goto nowriterr;
            closelines(curwksp->ulhclno + cursorline, defdelete);
            goto funcdone;
        case CCPUT:
            if (openwrite[curfile]==0)
                goto nowriterr;
            if (pickbuf->nrows == 0) goto nopickerr;
            put(pickbuf,curwksp->ulhclno+cursorline,
            curwksp->ulhccno+cursorcol);
            goto funcdone;
        case CCPICK:
            picklines(curwksp->ulhclno + cursorline, defpick);
            goto funcdone;
d221 3
a223 3
        case CCINSMODE:
            imodesw = 1 - imodesw;  /* change it */
            goto funcdone;
d225 29
a253 29
        case CCGOTO:
            gtfcn(0);
            goto funcdone;
        case CCMIPAGE:
            movew(- defmipage * (1+curport->btext));
            goto funcdone;
        case CCPLSRCH:
            search(1);
            goto funcdone;
        case CCRPORT:
            movep(defrport);
            goto funcdone;
        case CCPLLINE:
            movew(defplline);
            goto funcdone;
        case CCDELCH:
            goto notimperr;
        case CCSAVEFILE:
            savefile(NULL,curfile);
            goto funcdone;
        case CCMILINE:
            movew(-defmiline);
            goto funcdone;
        case CCDOCMD:
            goto notstrerr;
        case CCPLPAGE:
            movew(defplpage * (1+curport->btext));
            goto funcdone;
        case CCMAKEPORT:
d255 4
a258 4
            goto funcdone;
        case CCTABS:
            settab(curwksp->ulhccno + cursorcol);
            goto funcdone;
d261 7
a267 7
            goto funcdone;
            /*    case CCMOVELEFT:        */
            /*    case CCTAB:             */
            /*    case CCMOVEDOWN:        */
            /*    case CCHOME:            */
            /*    case CCRETURN:  */
            /*    case CCMOVEUP:  */
d269 11
a279 11
        default:
            goto badkeyerr;
        }
        /* Повтор ввода аргумента */
reparg: 
        read1(); 
        if(CTRLCHAR) goto yesarg; 
        else goto noargerr;
        /*
         * Дай аргумент!
         */
d281 28
a308 28
        param(0);
yesarg:        
        if (lread1 == CCQUIT )
        {
            if (paraml>0 && (dechars(paramv,paraml),*paramv) == 'a')
            {
                if (*(paramv+1) != 'd') return;
                cleanup();
                inputfile = -1; /* to force a dump */
                fatal("ABORTED");
            }
            if (endit() == 0) goto funcdone;
            return;
        }
        switch (lread1)
        {
        case CCENTER:
            goto funcdone;
        case CCLPORT:
            if (paramtype <= 0)  goto notstrerr;
            if (s2i(paramv,&i)) goto notinterr;
            movep(-i);
            goto funcdone;
        case CCSETFILE:
            if (paramtype <=  0)  goto notstrerr;
            if (paramv == 0) goto noargerr;
            if ( use0flg || !inputfile)
                dechars(paramv,paraml); 
d310 6
a315 6
            editfile(paramv,0,0,1,1);
            goto funcdone;
        case CCCHPORT:
            if (paramtype <= 0)  goto notstrerr;
            if (s2i(paramv,&i)) goto notinterr;
            if (i <= 0) goto notposerr;
d317 17
a333 17
            goto funcdone;
        case CCOPEN:
            if (openwrite[curfile]==0)  goto nowriterr;
            if (paramtype == 0) {
                splitline(curwksp->ulhclno + paramr0,
                paramc0 + curwksp->ulhccno);
                goto funcdone;
            }
            else { 
                lnfun = openlines; 
                spfun = openspaces; 
                goto spdir;
            };
        case CCMISRCH:
        case CCPLSRCH:
            if (paramtype <= 0)  goto notstrerr;
            if (paramv == 0) goto noargerr;
d335 49
a383 49
            searchkey = paramv;
            paraml = 0;
            search(lread1==CCPLSRCH?1:-1);
            goto funcdone;
        case CCCLOSE:
            if (openwrite[curfile]==0)  goto nowriterr;
            if (paramtype == 0) combineline(curwksp->ulhclno + paramr0,
            paramc0 + curwksp->ulhccno);
            else {
                if(paramtype > 0 && paramv && paramv[0]=='>')
                {
                    msrbuf(deletebuf,paramv+1,0); 
                    goto funcdone;
                }
                lnfun = closelines;
                spfun = closespaces; 
                goto spdir;
            }
            goto funcdone;
        case CCPUT:
            if (paramtype >  0 && paramv && paramv[0]=='$' )
            {
                if (msrbuf(pickbuf,paramv+1,1))goto errclear;
                goto funcdone;
            }
            if (paramtype != 0)  goto notstrerr;
            if (openwrite[curfile]==0)
                goto nowriterr;
            if (deletebuf->nrows == 0) goto nodelerr;
            put(deletebuf,curwksp->ulhclno+cursorline,
            curwksp->ulhccno+cursorcol);
            goto funcdone;
        case CCTAB:
        case CCMOVELEFT:
        case CCMOVEDOWN:
        case CCHOME:
        case CCMOVEUP:
        case CCMOVERIGHT:
        case CCBACKTAB:
            if (s2i(paramv,&i)) goto notinterr;
            if (i <= 0) goto notposerr;
            m = ((lread1<=BT) ? lread1:0);
            while (--i >= 0) movecursor(m);
            goto funcdone;
        case CCRETURN:
            if(paramtype <=0|| !paramv) goto notimperr;
            dechars(paramv,paraml);
            switch (paramv[0])
            { 
d386 13
a398 13
                goto funcdone;
            case '>':
                msvtag(paramv+1); 
                goto funcdone;
            case '$':
                if(mdeftag(paramv+1)){ 
                    lread1= -1; 
                    goto reparg;
                }
                else goto funcdone;
            case 'k': 
                defkey(); 
                goto funcdone;
d401 1
a401 1
            case 'r':
d403 2
a404 2
            case 'd': 
                if(paramv[1]==' ') defmac(&paramv[2]);
d406 9
a414 9
            case 'q':
                lread1=CCQUIT; 
                if(paramv[1]=='a') {
                    return;
                }
                goto contin;
            default: 
                goto noargerr;
            }
d417 8
a424 8
            if (paramtype > 0 && paramv && paramv[0]=='>')
            {
                msrbuf(pickbuf,paramv+1,0); 
                goto funcdone;
            }
            lnfun = picklines; 
            spfun = pickspaces; 
            goto spdir;
d426 1
a426 1
        case CCINSMODE:
d431 2
a432 2
            {
                if (s2i(paramv,&i)) goto notinterr;
d434 1
a434 1
            }
d437 1
a437 1
            goto funcdone;
d439 66
a504 66
            if (paramtype == 0) gtfcn(nlines[curfile]);
            else if (paramtype > 0)
            {
                if(paramv && paramv[0]=='$') {
                    mgotag(paramv+1);
                    goto funcdone;
                }
                if (s2i(paramv,&i)) goto notinterr;
                gtfcn(i-1);
            }
            else goto noargerr;
            goto funcdone;
        case CCMIPAGE:
            if (paramtype <= 0)  goto notstrerr;
            if (s2i(paramv,&i)) goto notinterr;
            movew(- i * (1 + curport->btext));
            goto funcdone;
        case CCRPORT:
            if (paramtype <= 0)  goto notstrerr;
            if (s2i(paramv,&i)) goto notinterr;
            movep(i);
            goto funcdone;
        case CCPLLINE:
            if (paramtype < 0)  goto notstrerr;
            else if (paramtype == 0)  movew(cursorline);
            else if (paramtype > 0)
            {
                if (s2i(paramv,&i)) goto notinterr;
                movew(i);
            }
            goto funcdone;
        case CCDELCH:
            goto notimperr;
        case CCSAVEFILE:
            if (paramtype <=  0)  goto notstrerr;
            if (paramv == 0) goto noargerr;
            dechars(paramv,paraml);
            savefile(paramv,curfile);
            goto funcdone;
        case CCMILINE:
            if (paramtype < 0)  goto notstrerr;
            else if (paramtype == 0)  movew(cursorline - curport->btext);
            else if (paramtype > 0)
            {
                if (s2i(paramv,&i)) goto notinterr;
                movew(-i);
            }
            goto funcdone;
        case CCDOCMD:
            if(paramtype<=0) goto notstrerr;
            dechars(paramv,paraml);
            if (openwrite[curfile] == 0) goto nowriterr;
            callexec();
            goto funcdone;
        case CCPLPAGE:
            if (paramtype <= 0)  goto notstrerr;
            if (s2i(paramv,&i)) goto notinterr;
            movew(i * (1 + curport->btext));
            goto funcdone;
        case CCMAKEPORT:
            if (paramtype == 0)  removeport();
            else if (paramtype <  0)  goto notstrerr;
            else {
                dechars(paramv,paraml);
                makeport(paramv);
            }
d506 4
a509 4
            goto funcdone;
        case CCTABS:
            clrtab(curwksp->ulhccno + cursorcol);
            goto funcdone;
d513 28
a540 28
        default:
            goto badkeyerr;
        }
spdir: 
        if (paramtype > 0)
        {
            if(paramv[0] == '$')
            {
                if(mdeftag(paramv+1)) goto spdir; 
                else goto funcdone;
            }
            if (s2i(paramv,&i)) goto notinterr;
            if (i <= 0) goto notposerr;
            (*lnfun)(curwksp->ulhclno + cursorline, i);
        }
        else
        {
            if (paramc1 == paramc0)
            {
                (*lnfun)(curwksp->ulhclno+paramr0,
                (paramr1-paramr0)+1);
            }
            else (*spfun)(curwksp->ulhclno + paramr0,
            curwksp->ulhccno + paramc0,
            (paramc1-paramc0),
            (paramr1-paramr0) + 1);
        }
        goto funcdone;
d542 2
a543 2
        error(DIAG("Illegal key or unnown macro","Неизвестная клавиша или макро"));
        goto funcdone;
d545 2
a546 2
        error(DIAG("Argument must be a string.","Аргумент должен быть строкой"));
        goto funcdone;
d548 2
a549 2
        error(DIAG("Invalid argument.","Плохой аргумент"));
        goto funcdone;
d551 2
a552 2
        error(DIAG("Argument must be numerik.","Аргумент должен быть числом"));
        goto funcdone;
d554 2
a555 2
        error(DIAG("Argument must be positive.","Аргумент должен быть положительным"));
        goto funcdone;
d557 2
a558 2
        error(DIAG("Nothing in the pick buffer.","Буфер вставок пуст"));
        goto funcdone;
d560 2
a561 2
        error (DIAG("Nothing in the close buffer.","Буфер убранных строк пуст"));
        goto funcdone;
d563 2
a564 2
        error(DIAG("Feature not implemented yet.","Еще не определено."));
        goto funcdone;
d566 2
a567 2
        error(DIAG("You cannot modify this file!","Вы не можете изменить этот файл."));
        goto funcdone;
d569 1
a569 1
        clrsw = 1;
d571 1
a571 1
        lread1 = -1;        /* signify char read was used */
d573 2
a574 2
        oport = curport;
        k = cursorline;
d582 2
a583 2
        j = cursorcol;
        switchport(&paramport);
d585 6
a590 6
        if (clrsw)
        {
            if (!errsw && !first)
            {
                poscursor(0,0);
		putblanks(PARAMRINFO);
d592 5
a596 5
            poscursor(PARAMREDIT+2,0);
	    info(DIAG("line ","строка: "),PARAMRINFO);
            ccsave = cursorcol;
            clsave = cursorline;
            if (oport->wksp->wfile)
d598 5
a602 2
		info(DIAG("     file ","      файл "),PARAMRINFO);
                info(openfnames[oport->wksp->wfile],PARAMRINFO);
a605 1
        poscursor(ccsave,clsave);
d607 13
a619 9
	cp = ich + 6;
        *--cp = '\0';
        do
            (*--cp = '0' + (i % 10));
        while (i = i/10);
        info(cp,PARAMRINFO);
        *cp = '\0';
        while (cp != ich) *--cp = ' ';
        info(ich,PARAMRINFO);
@


3.6
log
@
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.5 86/09/19 19:49:42 alex Exp $
d6 6
a120 1
            gosw = 0;
a279 1
                gosw = 0;
a285 1
            gosw = 1;
a401 1
                    gosw=0;
d586 3
d591 1
a591 1
                info(DIAG("file ","файл "),PARAMRINFO);
a593 2
            info(DIAG(" line "," строка: "),PARAMRINFO);
            clsave = cursorline;
a594 1
            ccsave = cursorcol;
d598 1
a598 1
        cp = ich + 8;
@


3.5
log
@Версия для СМ-1700
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.4 86/08/04 20:50:21 alex Exp $
d6 3
d389 2
@


3.4
log
@Bepqh dk LMNQ/DELNQ 2
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.3 86/07/24 21:07:54 alex Exp $
d6 3
@


3.3
log
@Исправлена ошибка в автоматическом сдвиге
(привнесена при об'единении).
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.2 86/07/24 00:22:11 alex Exp $
d6 4
@


3.2
log
@Об'единены версии текстов для ЕС и СМ
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1.1.9 86/07/15 22:11:18 alex Exp $
d6 3
d671 1
d764 1
d773 1
d810 1
a810 1
			goto contin;
@


3.1
log
@Базовая версия для ЕС.
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1 86/04/20 23:40:29 alex Exp $
d6 24
d31 3
d45 2
d48 6
a69 1
    int thiscol, thisrow;
d78 1
d98 1
a98 4
        /*
         * Редактирование в строке
         */
        if ((! CTRLCHAR) || lread1 == CCCTRLQUOTE || lread1 == CCBACKSPACE || lread1 == CCDELCH)
d100 4
a103 78
            /* Отмена в 1 колонке */
            if (lread1 == CCBACKSPACE  &&  cursorcol == 0)
            {
                lread1 = -1;
                goto contin;
            }
            if (openwrite[curfile] == 0) goto nowriterr;
            /* Строки у нас нет? Дай! */
            if (clineno != (i = curwksp->ulhclno+cursorline)) getline(i);
            /* исключение символа */
            if (lread1==CCDELCH || (imodesw && lread1==CCBACKSPACE) )
            {
                thiscol = cursorcol + curwksp->ulhccno;
                thisrow = cursorline;
                if (lread1 == CCBACKSPACE) thiscol--;
                if (ncline < thiscol + 2)
                {
                    if (lread1 == CCBACKSPACE) movecursor(LT);
                    lread1 = -1;
                    goto contin;
                }
                for (i=thiscol;i<ncline-2;i++) cline[i] = cline[i+1];
                ncline--;
                thiscol -= curwksp->ulhccno;
                putup(-(1+thiscol),cursorline);
                poscursor(thiscol,thisrow);
                fcline = 1;
                lread1 = -1;
                goto contin;
            }
            /* Проверка на границу окна */
            if (cursorcol > curport->rtext)
            { 
                if (fcline) { 
                    putline(0); 
                    movep(defrport);
                    goto contin; 
                }
                else  goto margerr;
            }
            fcline = 1;
            if (j = (lread1 == CCBACKSPACE))
            {
                movecursor(LT);
                lread1 = ' ';
            }
            if ((i = cursorcol + curwksp->ulhccno) >=
                (lcline - 2)) excline(i+2);
            if (i >= ncline-1)
            {
                for (k=ncline-1; k<=i; k++) cline[k] = ' ';
                cline[i+1] = NEWLINE;
                ncline = i+2;
            }
            else if (imodesw)
            {
                thiscol = cursorcol + curwksp->ulhccno;
                thisrow = cursorline;
                if (ncline >= lcline) excline(ncline+1);
                for (i=ncline;i>thiscol;i--) cline[i] = cline[i-1];
                ncline++;
                thiscol -= curwksp->ulhccno;
                putup(-(1+thiscol),cursorline);
                poscursor(thiscol,thisrow);
            }
            /* Выставим границу */
            if (cursorcol >= curport->rtext)
                curport->redit = curport->rtext + 1;
            /* Замена символа */
            if(lread1==CCCTRLQUOTE) lread1 = esc0;
            if (cursorcol == curport->rtext - 10) putcha(COBELL);
            cline[i] = lread1;
            putch(lread1,1);
            /* Если переехали границу */
            curport->redit = curport->rtext;
            if (j) movecursor(LT);
            lread1 = -1;
            goto contin;
d105 1
a105 1
        /* Сдвиг вниз, если последняя строка  */
d108 12
d127 2
a128 1
        }
d130 13
d149 4
a152 1
                if(curspos) goto newnumber; 
a159 6
        if (lread1 == CCQUIT)
        {
            if (endit() == 0) goto funcdone;
            gosw = 0;
            return;
        }
d168 1
a168 1
            switchfile();
d171 1
a171 1
            chgport(-1);
d195 1
d199 1
d229 1
a229 1
            makeport(deffile);
d234 3
d243 1
d286 1
a286 1
            use0flg=1;
d293 1
a293 1
            chgport(i-1);
d311 1
a311 1
            if (searchkey) free(searchkey);
d344 1
a345 1
        case CCTAB:
d361 3
a372 5
            case 'w': 
                if(paramv[1]==' ' && paramv[2]=='+')
                    openwrite[curwksp->wfile]=1;
                else openwrite[curwksp->wfile]=0;
                goto funcdone;
d377 1
a377 2
                rescreen(-1); 
                goto funcdone; /* Восттановить экран */
d401 1
d404 9
d481 1
d486 3
a540 3
margerr:
        error("Margin stusk; move cursor to free.");
        goto funcdone;
d551 7
d560 1
a560 1
        paramport.redit = PARAMRINFO;
d566 1
a566 1
                info(blanks,PARAMRINFO);
d597 1
a597 1
            dumpcbuf();
d602 1
d605 1
d612 1
d614 248
d893 1
a893 1
    dumpcbuf();
d1061 1
@


3.1.2.1
log
@Start revision for red/4
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.12 87/06/12 18:08:21 alex Exp $
a5 63
 * Revision 3.12  87/06/12  18:08:21  alex
 * Исправлены ошибки в режиме vilcase и мелочи для vt-200
 * 
 * Revision 3.11  87/06/09  19:45:45  alex
 * Исправлена работа с tty ~ VT200 и 15-ИЭ-0013
 * 
 * Revision 3.10  87/06/06  16:48:07  alex
 * Добавлен roll для терминалов с sr/sf и отображение
 *  табуляций в режиме -t + всякая мелочь
 * 
 * Revision 3.9  87/06/05  23:49:03  alex
 * Добавлен roll для терминалов с sr/sf и отображение
 *  табуляций в режиме -t + всякая мелочь
 * 
 * Revision 3.8  87/06/04  23:42:15  alex
 * Scroll on -sr- or -al/dl- added
 * 
 * Revision 3.7  87/04/02  18:35:04  alex
 * Версия для Utec слита с версией с выделением прописных букв
 *
 * Revision 3.7  87/04/01  19:13:17  alex
 * Revision for Utec: Cs, Ce, Ct, hR
 *
 * Revision 3.6  86/09/19  21:37:19  alex
 *
 *
 * Revision 3.5  86/09/19  19:49:42  alex
 * Версия для СМ-1700
 *
 * Revision 3.4  86/08/04  20:50:21  alex
 * Bepqh dk LMNQ/DELNQ 2
 *
 * Revision 3.3  86/07/24  21:07:54  alex
 * Исправлена ошибка в автоматическом сдвиге
 * (привнесена при об'единении).
 *
 * Revision 3.2  86/07/24  00:22:11  alex
 * Об'единены версии текстов для ЕС и СМ
 *
 * Revision 3.1.1.9  86/07/15  22:11:18  alex
 * RED 3.3/EC.
 *
 * Revision 3.1.1.8  86/06/25  19:40:32  alex
 * Введено автоматическое смещение экрана
 *
 * Revision 3.1.1.7  86/06/20  23:30:50  alex
 * Улучшен "editline"".
 *
 * Revision 3.1.1.6  86/06/19  00:09:42  alex
 * Отлажен на модели повтор сеанса
 *
 * Revision 3.1.1.5  86/06/16  22:15:50  alex
 * Первая версия с повтором сеанса (пока грязная)
 *
 * Revision 3.1.1.3  86/06/06  00:12:49  alex
 * Введена установка ключей
 *
 * Revision 3.1.1.2  86/06/05  18:52:38  alex
 * Отлажено_на_модели
 *
 * Revision 3.1.1.1  86/06/05  00:03:11  alex
 * Отлажено_на_модели
 *
a6 3
 * Базовая версия для ЕС.
 *
 * Revision 3.1  86/04/20  23:40:29  alex
d8 1
a8 1
 *
a17 2
#ifndef DEMOSES
#define NEWEDIT
a18 6
#else DEMOSES
/* int imodesw;/* 1 - режим вставки  */
extern short zerowsflag;
static editline();
#define NEWEDIT newedit = 1
#endif DEMOSES
a30 3
    int inf_wfile= -1, inf_iline= -1;
    int inf_cmark = -1, inf_lmark= -1;
    int oldautoi = -1;
d35 1
a43 2
    NEWEDIT;
    new_info = 1;
d54 214
a267 166
	{
	read1();
	if (errsw)
	{
	    errsw = 0;
	    clrsw = 1;
	    goto errclear;
	}
	if (lread1 == CCQUIT)
	{
	    putline(0);
	    if (endit() == 0) goto funcdone;
	    return;
	}
	/* Обработка RETURN  */
	if (lread1 == CCRETURN )
	{
#ifdef DEMOSES
	    if ( cursorcol < 0 && curwksp->ulhccno != 0 )
		lread1 = CCLPORT;
	    else if ( cursorcol > curport->rtext)
		lread1 = CCRPORT;
	    else if ( cursorline < 0 )
		lread1 = CCMILINE;
	    else if ( cursorline > curport->btext)
		lread1 = CCPLLINE;
	    else
#endif DEMOSES
	    {
	    putline(0);
	    if(!fix_screen && (i=curwksp->ulhccno) !=0) movep(-i);
	    if ( cursorline == curport->btext)
		movew( defreturn?defreturn:defplline,1);
	    movecursor(lread1);
	    lread1= -1;
	    goto errclear;
	    }
	}
	/*
	 * Редактирование в строке. Обычные символы на ЕС
	 * могут прийти из макро.
	 */
#ifndef DEMOSES
	if ((! CTRLCHAR) || lread1 == CCCTRLQUOTE || lread1 == CCBACKSPACE || lread1 == CCDELCH)
#else DEMOSES
	if ((! CTRLCHAR) || lread1 == CCCTRLQUOTE || lread1 == CCINSERT || lread1 == CCDELCH)
#endif DEMOSES
	{
		if ( !lineop(lread1)) goto contin;
		goto newnumber;
	}
	/*
	 * Если команда перемещения
	 */
	if (lread1<=BT) {
	    i=movecursor(fix_screen?lread1:lread1|MOVE_NOFIX);
	    if(i != -1 ) lread1 = i; else {
		if (lread1 <= VMOTCODE ) {
		    putline(0);
		    goto newnumber;
		}
		autoindent = cursorcol;
		lread1 = -1;
		goto newnumber;
	    }
	}
	/* Если граница поля */
	if (cursorcol > curport->rtext) poscursor(curport->rtext,cursorline);
	putline(0);
	switch (lread1)
	{
	case CCENTER:
	    if(need_box) drawport(curport,0);
	    goto gotarg;
	case CCLPORT:
	    movep(- deflport);
	    goto newnumber;
	case CCSETFILE:
	    switchfile(); NEWEDIT;
	    goto funcdone;
	case CCCHPORT:
	    chgport(-1);NEWEDIT;
	    goto newnumber;
	case CCOPEN:
	    if (openwrite[curfile]==0)  goto nowriterr;
	    openlines(curwksp->ulhclno + cursorline,definsert);
	    goto newnumber;
	case CCMISRCH:
	    search(-1);
	    goto funcdone;
	case CCCLOSE:
	    if (openwrite[curfile]==0)
		goto nowriterr;
	    closelines(curwksp->ulhclno + cursorline, defdelete);
	    goto newnumber;
	case CCPUT:
	    if (openwrite[curfile]==0)
		goto nowriterr;
	    if (pickbuf->nrows == 0) goto nopickerr;
	    put(pickbuf,curwksp->ulhclno+cursorline,
	    curwksp->ulhccno+cursorcol);
	    goto newnumber;
	case CCPICK:
	    picklines(curwksp->ulhclno + cursorline, defpick);
	    goto newnumber;
#ifndef DEMOSES
	case CCINSMODE:
	    imodesw = 1 - imodesw;  /* change it */
	    goto funcdone;
#endif DEMOSES
	case CCGOTO:
	    gtfcn(0);
	    goto newnumber;
	case CCMIPAGE:
	    movew(- defmipage * (1+curport->btext),0);
	    goto newnumber;
	case CCPLSRCH:
	    search(1);
	    goto funcdone;
	case CCRPORT:
	    movep(defrport);
	    goto newnumber;
	case CCPLLINE:
	    movew(PL1MOVEW,fix_screen);
	    goto newnumber;
	case CCDELCH:
	    goto notimperr;
	case CCSAVEFILE:
	    savefile(NULL,curfile);
	    goto funcdone;
	case CCMILINE:
	    movew(MI1MOVEW,fix_screen);
	    goto newnumber;
	case CCDOCMD:
	    goto notstrerr;
	case CCPLPAGE:
	    movew(defplpage * (1+curport->btext),0);
	    goto newnumber;
	case CCMAKEPORT:
	    if(need_box) drawport(curport,0);
	    makeport(deffile); NEWEDIT;
	    goto funcdone;
	case CCTABS:
	    settab(curwksp->ulhccno + cursorcol);
	    goto newnumber;
	case CCRESCREEN:
	    rescreen(0);
	    goto funcdone;
	    /*    case CCMOVELEFT:        */
	    /*    case CCTAB:             */
	    /*    case CCMOVEDOWN:        */
	    /*    case CCHOME:            */
	    /*    case CCRETURN:  */
	    /*    case CCMOVEUP:  */
	    /*    case CCINSERT:  */
	default:
	    goto badkeyerr;
	}
	/* Повтор ввода аргумента */
reparg:
	read1();
	if(CTRLCHAR) goto yesarg;
	else goto noargerr;
	/*
	 * Дай аргумент!
	 */
d269 127
a395 42
	param(0);
yesarg:
	if (lread1 == CCQUIT )
	{
	    if (paraml>0 && (dechars(paramv,paraml),*paramv) == 'a')
	    {
		if (*(paramv+1) != 'd') return;
		cleanup();
		inputfile = -1; /* to force a dump */
		fatal("ABORTED");
	    }
	    if (endit() == 0) goto funcdone;
	    return;
	}
	switch (lread1)
	{
	case CCENTER:
	    goto funcdone;
	case CCLPORT:
	    if (paramtype <= 0)  goto notstrerr;
	    if (s2i(paramv,&i)) goto notinterr;
	    movep(-i);
	    goto funcdone;
	case CCSETFILE:
	    if (paramtype <=  0)  goto notstrerr;
	    if (paramv == 0) goto noargerr;
	    if ( use0flg || !inputfile)
		dechars(paramv,paraml);
	    use0flg=1;NEWEDIT;
	    editfile(paramv,0,0,1,1);
	    goto funcdone;
	case CCCHPORT:
	    if (paramtype <= 0)  goto notstrerr;
	    if (s2i(paramv,&i)) goto notinterr;
	    if (i <= 0) goto notposerr;
	    chgport(i-1); NEWEDIT;
	    goto funcdone;
	case CCOPEN:
	    if (openwrite[curfile]==0)  goto nowriterr;
	    if (paramtype == 0) {
		splitline(curwksp->ulhclno + paramr0,
		paramc0 + curwksp->ulhccno);
d397 10
a406 94
	    }
	    else {
		lnfun = openlines;
		spfun = openspaces;
		goto spdir;
	    };
	case CCMISRCH:
	case CCPLSRCH:
	    if (paramtype <= 0)  goto notstrerr;
	    if (paramv == 0) goto noargerr;
	    if (searchkey) free((char *)searchkey);
	    searchkey = paramv;
	    paraml = 0;
	    search(lread1==CCPLSRCH?1:-1);
	    goto funcdone;
	case CCCLOSE:
	    if (openwrite[curfile]==0)  goto nowriterr;
	    if (paramtype == 0) combineline(curwksp->ulhclno + paramr0,
	    paramc0 + curwksp->ulhccno);
	    else {
		if(paramtype > 0 && paramv && paramv[0]=='>')
		{
		    msrbuf(deletebuf,paramv+1,0);
		    goto funcdone;
		}
		lnfun = closelines;
		spfun = closespaces;
		goto spdir;
	    }
	    goto funcdone;
	case CCPUT:
	    if (paramtype >  0 && paramv && paramv[0]=='$' )
	    {
		if (msrbuf(pickbuf,paramv+1,1))goto errclear;
		goto funcdone;
	    }
	    if (paramtype != 0)  goto notstrerr;
	    if (openwrite[curfile]==0)
		goto nowriterr;
	    if (deletebuf->nrows == 0) goto nodelerr;
	    put(deletebuf,curwksp->ulhclno+cursorline,
	    curwksp->ulhccno+cursorcol);
	    goto funcdone;
	case CCTAB:
	case CCMOVELEFT:
	case CCMOVEDOWN:
	case CCHOME:
	case CCMOVEUP:
	case CCMOVERIGHT:
	case CCBACKTAB:
	    if (s2i(paramv,&i)) goto notinterr;
	    if (i <= 0) goto notposerr;
	    m = ((lread1<=BT) ? lread1:0);
	    while (--i >= 0) movecursor(m);
	    goto funcdone;
	case CCRETURN:
	    if(paramtype <=0|| !paramv) goto notimperr;
	    dechars(paramv,paraml);
	    switch (paramv[0])
	    {
	    case '-': case '+':
		lread1 = -1;
		new_info = 1;
		if ( setkeys(paramv)) goto noargerr;
		if(lread1 != -1) rescreen(0);
		goto funcdone;
	    case '>':
		msvtag(paramv+1);
		goto funcdone;
	    case '$':
		if(mdeftag(paramv+1)){
		    lread1= -1;
		    goto reparg;
		}
		else goto funcdone;
	    case 'k':
		defkey();
		goto funcdone;
	    case 's':
		tostop();
	    case 'r':
		rescreen(0); goto funcdone;
	    case 'd':
		if(paramv[1]==' ') defmac(&paramv[2]);
		goto funcdone;
	    case 'q':
		lread1=CCQUIT;
		if(paramv[1]=='a') {
		    return;
		}
		goto contin;
	    default:
		goto noargerr;
	    }
d409 9
a417 10
	    if (paramtype > 0 && paramv && paramv[0]=='>')
	    {
		msrbuf(pickbuf,paramv+1,0);
		goto funcdone;
	    }
	    lnfun = picklines;
	    spfun = pickspaces;
	    goto spdir;
#ifndef DEMOSES
	case CCINSMODE:
d419 1
a419 10
#else DEMOSES
	case CCINSERT:
	    if (paramtype > 0)
	    {
		if (s2i(paramv,&i)) goto notinterr;
		dflinsert = i;
	    }
	    else dflinsert = 1;
#endif DEMOSES
	    goto funcdone;
d421 98
a518 103
	    if (paramtype == 0) gtfcn(nlines[curfile]);
	    else if (paramtype > 0)
	    {
		if(paramv && paramv[0]=='$') {
		    mgotag(paramv+1);
		    goto funcdone;
		}
		if (s2i(paramv,&i)) goto notinterr;
		gtfcn(i-1);
	    }
	    else goto noargerr;
	    goto funcdone;
	case CCMIPAGE:
	    if (paramtype <= 0)  movew(cursorline - curport->btext,0);
	    if (s2i(paramv,&i)) goto notinterr;
	    movew(- i * (1 + curport->btext),0);
	    goto funcdone;
	case CCRPORT:
	    if (paramtype <= 0)  goto notstrerr;
	    if (s2i(paramv,&i)) goto notinterr;
	    movep(i);
	    goto funcdone;
	case CCPLLINE:
	    if (paramtype < 0)  goto notstrerr;
	    else if (paramtype == 0)  movew(cursorline,1);
	    else if (paramtype > 0)
	    {
		if (s2i(paramv,&i)) goto notinterr;
		movew(i,1);
	    }
	    goto funcdone;
	case CCDELCH:
	    lineop(CCTRUNCATE);
	    goto newnumber;
	case CCSAVEFILE:
	    if (paramtype <=  0)  goto notstrerr;
	    if (paramv == 0) goto noargerr;
	    dechars(paramv,paraml);
	    savefile(paramv,curfile);
	    goto funcdone;
	case CCMILINE:
	    if (paramtype < 0)  goto notstrerr;
	    else if (paramtype == 0)  movew(cursorline - curport->btext,1);
	    else if (paramtype > 0)
	    {
		if (s2i(paramv,&i)) goto notinterr;
		movew(-i,1);
	    }
	    goto funcdone;
	case CCDOCMD:
	    if(paramtype<=0) goto notstrerr;
	    dechars(paramv,paraml);
	    if (openwrite[curfile] == 0) goto nowriterr;
	    callexec();
	    goto funcdone;
	case CCPLPAGE:
	    if (paramtype <= 0)  movew(cursorline,0);
	    if (s2i(paramv,&i)) goto notinterr;
	    movew(i * (1 + curport->btext),1);
	    goto funcdone;
	case CCMAKEPORT:
	    if (paramtype == 0)  removeport();
	    else if (paramtype <  0)  goto notstrerr;
	    else {
		dechars(paramv,paraml);
		makeport(paramv);
	    }
	    NEWEDIT;
	    goto funcdone;
	case CCTABS:
	    clrtab(curwksp->ulhccno + cursorcol);
	    goto funcdone;
	case CCRESCREEN:
	    rescreen(0);
	    goto funcdone;
	default:
	    goto badkeyerr;
	}
spdir:
	if (paramtype > 0)
	{
	    if(paramv[0] == '$')
	    {
		if(mdeftag(paramv+1)) goto spdir;
		else goto funcdone;
	    }
	    if (s2i(paramv,&i)) goto notinterr;
	    if (i <= 0) goto notposerr;
	    (*lnfun)(curwksp->ulhclno + cursorline, i);
	}
	else
	{
	    if (paramc1 == paramc0)
	    {
		(*lnfun)(curwksp->ulhclno+paramr0,
		(paramr1-paramr0)+1);
	    }
	    else (*spfun)(curwksp->ulhclno + paramr0,
	    curwksp->ulhccno + paramc0,
	    (paramc1-paramc0),
	    (paramr1-paramr0) + 1);
	}
	goto funcdone;
d520 2
a521 2
	error(DIAG("Illegal key or unnown macro","Неизвестная клавиша или макро"));
	goto funcdone;
d523 2
a524 2
	error(DIAG("Argument must be a string.","Аргумент должен быть строкой"));
	goto funcdone;
d526 2
a527 2
	error(DIAG("Invalid argument.","Плохой аргумент"));
	goto funcdone;
d529 2
a530 2
	error(DIAG("Argument must be numerik.","Аргумент должен быть числом"));
	goto funcdone;
d532 2
a533 2
	error(DIAG("Argument must be positive.","Аргумент должен быть положительным"));
	goto funcdone;
d535 2
a536 2
	error(DIAG("Nothing in the pick buffer.","Буфер вставок пуст"));
	goto funcdone;
d538 2
a539 2
	error (DIAG("Nothing in the close buffer.","Буфер убранных строк пуст"));
	goto funcdone;
d541 5
a545 2
	error(DIAG("Feature not implemented yet.","Еще не определено."));
	goto funcdone;
d547 2
a548 2
	error(DIAG("You cannot modify this file!","Вы не можете изменить этот файл."));
	goto funcdone;
d550 1
a550 1
	clrsw = 1;
d552 1
a552 1
	lread1 = -1;        /* signify char read was used */
d554 47
a600 88
	oport = curport;
	k = cursorline;
#ifdef DEMOSES
	if ( newedit ) {
		newedit = 0;
		if ( openwrite[curfile] ) editwind(curport,editline,zerowsflag);
		else editwind((struct viewport *)0,(int (*)())0,0);
		}
#endif DEMOSES
/*
 * Алгоритм для перерисования рамок и номера -
 * если только что был сдвиг, то блокируем
 */
	if(need_box && need_box++ !=1) drawport(curport,0);
	if(need_box != 2 ) {
	    j = cursorcol;
	    switchport(&paramport);
	    paramport.redit = PARAMRINFO;   /* !!! */
	    if (clrsw || new_info)
	    {
		if (!errsw && !first)
		{
		    poscursor(0,0);
		    if ( !new_info || !putcha(COCLLIN))
			    putblanks(PARAMREDIT);
		}
    /*            poscursor(PARAMREDIT+2,0);  */
    /*            info(DIAG("line ","строка: "),PARAMRINFO);        */
		ccsave = PARAMREDIT+2/* cursorcol */;
		clsave = 0 /* cursorline */;
		if (oport->wksp->wfile&&(oport->wksp->wfile != inf_wfile||new_info))
		{
		    poscursor(PARAMREDIT+8,0);
		    inf_wfile = oport->wksp->wfile;
		    info(DIAG(" file "," файл "),PARAMRINFO);
		    info(openfnames[inf_wfile],PARAMRINFO);
		    putblanks(PARAMRINFO-cursorcol);
		}
		first=0;
	    }
	    i = oport->wksp->ulhclno + k + 1; /* Рисуем номер строки */
	    if ( i != inf_iline || new_info) {
		inf_iline = i;
		poscursor(ccsave,clsave);
		cp = ich + 6;
		*--cp = '\0';
		do
		    (*--cp = '0' + (i % 10));
		while (i = i/10);
		info(cp,PARAMRINFO);
		*cp = '\0';
		while (cp != ich) *--cp = ' ';
	    info(ich,PARAMRINFO);
	    }
	    switchport(oport);
	    paramport.redit = PARAMREDIT;
	    if (new_info ||
		 ((on_autoi || inf_lmark != -1)&&oldautoi != autoindent)
		) {
		switchport(&wholescreen);
		if(inf_lmark != -1) {
			poscursor(inf_cmark,inf_lmark);
			putch(BMCH,0);
			inf_lmark = -1;
		}
		if(on_autoi&&oport->bmarg !=oport->ttext+oport->btext) {
			    inf_cmark = oport->ltext+autoindent;
			    inf_lmark = oport->bmarg;
			    poscursor(inf_cmark,inf_lmark);
			    putcha(COOPEN);
			    putch(AMCH,0);
			    putcha(COCLOSE);
			    }
		switchport(oport);
		oldautoi = autoindent;
		}
	    poscursor(j,k);
	    if (csrsw)
	    {
		putch(COCURS,1);
		poscursor(j,k);
		dumpcbuf(1);
		sleep(1);
		putup(k,k);
		poscursor(j,k);
	    }
#ifndef DEMOSES
	if (imodesw && (new_info || clrsw) && !errsw)
a601 3
#endif DEMOSES
	csrsw = clrsw = new_info = 0;
	}
a607 1
#ifdef DEMOSES
a608 257
 * editline(номер,строка)
 * Редактировать строку "номер" в текущем окне.
 * Заменить ее на "строка"
 */
static editline(ln,str,lnos)
int ln,lnos;
char *str;
{
    register int i;register char *cp;
    int lno; /* Номер в файле */
    int slen; /* Длина str */
    int scolno; /* Начальная колонка str */
    int newnline; /* Новая длина строки */
    /*
     * 1. Дай строку
     */
    lno = ln + curwksp->ulhclno;
    if ( lno != clineno ) putline(0), getline(lno);
    /*
     * 2. Определить длину новой строки без хвостовых пробелов.
     */
    scolno = curwksp->ulhccno;
    if ( ncline-1 <= scolno+(curport->rtext+1) ){
	slen = lnos;
	newnline = scolno + slen+1;
    } 
    else {
	slen = curport->rtext+1;
        newnline = ncline;
    }
    if ( lcline-2 < newnline ) excline(newnline+2);
    /*
     * 3. Заменяем часть строки
     */
    i = ncline-1;
    while ( i < scolno ) cline[i++] = ' ';
    for ( i = 0, cp = str; i < slen; i++ ) {
	cline[scolno+i] = (*cp?*cp++:' ');/* Becь xвocт зaбивaeм пpoбeлaми*/
    }
    ncline = newnline;
    cline[ncline-1]=012;
    fcline = 1;
 /*
  * Учитывая особенности терминала, устанавливаем режим - стирай все!
  */
    if ( !speccase )  {
	curport->firstcol[ln] = 0; curport->lastcol[ln]= slen;
	putup(ln,ln);
    } else
    putup(-1, ln);
    return;
}

/*
 * lineop(символ) - для ЕС
 * Выполнение простейших операций в строке.
 * В конце сбрасывает lread1.
 */
lineop(lr1)
register lr1;
{
	register int i,k;
	int thiscol, thisrow;
	/* Введем курсор в его границы */
	movecursor(0);
	if (openwrite[curfile] == 0) goto nowriterr;
	/* Строки у нас нет? Дай! */
	if (clineno != (i = curwksp->ulhclno+cursorline)) {
		if (fcline) putline(0);
		getline(i);
	}
	/* исключение символа */
	if (lr1==CCDELCH )
	{
		thiscol = cursorcol + curwksp->ulhccno;
		thisrow = cursorline;
		if (ncline < thiscol + 2)
			goto contin;
		for (i=thiscol;i<ncline-2;i++) cline[i] = cline[i+1];
		ncline--;
		thiscol -= curwksp->ulhccno;
		putup(-1,cursorline);
		poscursor(thiscol,thisrow);
		fcline = 1;
		goto contin;
	}
	/* Проверка на границу окна - для МАКРО */
	if (cursorcol > curport->rtext)
	{
		if (fcline) {
			putline(0);
			movep(defrport);
			goto contin;
		}
		else  goto margerr;
	}
	fcline = 1;
	/* Если строка удлинилась - отведем еще память */
	if ((i = cursorcol + curwksp->ulhccno ) >=
	    (lcline - 2)) excline(i+2);
	if (i >= ncline-1)
	{
		for (k=ncline-1; k<=i; k++) cline[k] = ' ';
		cline[i+1] = NEWLINE;
		ncline = i+2;
	}
	/* Вставка пробелов */
	if (lr1==CCINSERT)
	{
		thiscol = cursorcol + curwksp->ulhccno;
		thisrow = cursorline;
		if (ncline+dflinsert > lcline) excline(ncline+dflinsert);
		for (i=ncline-1;i >= thiscol;i--) cline[i+dflinsert]=cline[i];
		ncline += dflinsert;
		for ( i=0;i<dflinsert;i++) cline[i+thiscol] = ' ';
		thiscol -= curwksp->ulhccno;
		putup(-1,cursorline);
		poscursor(thiscol,thisrow);
		goto contin;
	}
	/* Выставим границу */
	if (cursorcol >= curport->rtext)
		curport->redit = curport->rtext + 1;
	/* Замена символа */
	if(lr1==CCCTRLQUOTE) lr1 = esc0;
	cline[i] = lr1;
	putch(lr1,1);
	/* Если переехали границу */
	curport->redit = curport->rtext;
	goto contin;
margerr:
	error("Margin stusk; move cursor to free.");
	goto errdone;
nowriterr:
	error(DIAG("You cannot modify this file!","Вы не можете изменить этот файл."));
	goto errdone;
errdone:
	lread1 = -1;
	return(1);
contin:
	lread1 = -1;
	return(0);
}

#else  NOT DEMOSES

/*
 * lineop(символ) - для СМ
 * Выполнение простейших операций в строке.
 * В конце сбрасывает lr1.
 */
lineop(lr1)
register lr1;
{
	register int i,k;
	int thiscol, thisrow,j;
repop:
	/* Отмена в 1 колонке */
	if (lr1 == CCBACKSPACE  &&  cursorcol == 0)
	{
		lr1 = -1;
		goto contin;
	}
	if (openwrite[curfile] == 0) goto nowriterr;
	/* Строки у нас нет? Дай! */
	if (clineno != (i = curwksp->ulhclno+cursorline)) getline(i);
	/* исключение символа */
	if (lr1==CCDELCH || (imodesw && lr1==CCBACKSPACE) || lr1==CCTRUNCATE)
	{
		thiscol = cursorcol + curwksp->ulhccno;
		thisrow = cursorline;
		if (lr1 == CCBACKSPACE) thiscol--;
		if (ncline < thiscol + 2)
		{
			if (lr1 == CCBACKSPACE) movecursor(LT);
			lr1 = -1;
			goto contin;
		}
		if(lr1 == CCTRUNCATE) {
			cline[thiscol] = cline[ncline-1];
			ncline = thiscol+1;
		} else
		{
			for (i=thiscol;i<ncline-2;i++) cline[i] = cline[i+1];
			ncline--;
		}
		thiscol -= curwksp->ulhccno;
		putup(-(1+thiscol),cursorline);
		poscursor(thiscol,thisrow);
		fcline = 1;
		lr1 = -1;
		goto contin;
	}
	/* Проверка на границу окна */
	if (cursorcol > curport->rtext)
	{
		if (fcline) {
			putline(0);
			movep(defrport);
			goto repop;
		}
		else  goto margerr;
	}
	fcline = 1;
	if (j = (lr1 == CCBACKSPACE))
	{
		movecursor(LT);
		lr1 = ' ';
	}
	if ((i = cursorcol + curwksp->ulhccno) >=
	    (lcline - 2)) excline(i+2);
	if (i >= ncline-1)
	{
		for (k=ncline-1; k<=i; k++) cline[k] = ' ';
		cline[i+1] = NEWLINE;
		ncline = i+2;
	}
	else if (imodesw)
	{
		thiscol = cursorcol + curwksp->ulhccno;
		thisrow = cursorline;
		if (ncline >= lcline) excline(ncline+1);
		for (i=ncline;i>thiscol;i--) cline[i] = cline[i-1];
		ncline++;
		thiscol -= curwksp->ulhccno;
		putup(-(1+thiscol),cursorline);
		poscursor(thiscol,thisrow);
	}
	/* Выставим границу */
	if (cursorcol >= curport->rtext)
		curport->redit = curport->rtext + 1;
	/* Замена символа */
	if(lr1==CCCTRLQUOTE) lr1 = esc0;
	if (cursorcol == curport->rtext - 10) putcha(COBELL);
	cline[i] = lr1;
	putch(lr1,1);
	/* Если переехали границу */
	curport->redit = curport->rtext;
	if (j) movecursor(LT);
	lr1 = -1;
	goto contin;
margerr:
error("Margin stusk; move cursor to free.");
goto errdone;
nowriterr:
error(DIAG("You cannot modify this file!","Вы не можете изменить этот файл."));
goto errdone;
errdone:
lread1 = -1;
return(1);
contin:
lread1 = -1;
return(0);
}
#endif DEMOSES

/*
d640 1
a640 1
    dumpcbuf(1);
a807 1
    dumpcbuf(1);
@


3.1.2.2
log
@wYNESENA PEREMENNAQ lread1 I \TO OTLAVENO
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1.2.1 87/06/19 16:57:34 alex Exp $
a5 3
 * Revision 3.1.2.1  87/06/19  16:57:34  alex
 * Start revision for red/4
 * 
d109 3
a111 1
    register int lread1;
d133 1
a133 1
	lread1=readch();
a137 1
	    unread1(lread1);
d175 1
a175 1
	if ((! ISACMD(lread1)) || lread1 == CCCTRLQUOTE || lread1 == CCBACKSPACE || lread1 == CCDELCH)
d177 1
a177 1
	if ((! ISACMD(lread1)) || lread1 == CCCTRLQUOTE || lread1 == CCINSERT || lread1 == CCDELCH)
d180 1
a180 1
		if ( lineop(lread1)) goto contin;
d194 1
d292 2
a293 2
	lread1=readch();
	if(ISACMD(lread1)) goto yesarg;
d299 1
a299 1
	lread1=param(0);
d405 1
a405 1
		if ( !(lread1=setkeys(paramv))) goto noargerr;
a431 1
		unread1(lread1);
d690 1
d832 1
a832 1
	/*lread1 = -1;  */
d835 1
a835 1
	/*lread1 = -1;  */
d855 1
d885 1
d943 4
a947 2
contin:
return(1);
@


3.1.2.3
log
@New readch + gettc + tc table Tested
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1.2.2 87/06/23 18:48:22 alex Exp $
a5 3
 * Revision 3.1.2.2  87/06/23  18:48:22  alex
 * wYNESENA PEREMENNAQ lread1 I \TO OTLAVENO
 * 
d88 1
a88 1
#define NEWEDIT new_info = 1
d1000 1
@


3.1.2.4
log
@Commans set to 0200-0277
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1.2.3 87/06/24 22:33:07 alex Stab $
a5 3
 * Revision 3.1.2.3  87/06/24  22:33:07  alex
 * New readch + gettc + tc table Tested
 * 
d191 1
a191 1
	if (ISACMD(lread1) && lread1<=CCBACKTAB) {
d194 1
a194 1
		if ((lread1) <= VMOTCODE+CC ) {
@


3.1.2.5
log
@Graph_characters used in margin
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1.2.4 87/06/29 17:55:11 alex Exp $
a5 3
 * Revision 3.1.2.4  87/06/29  17:55:11  alex
 * Commans set to 0200-0277
 * 
d665 1
a665 1
			putch(BMCH,A_INFO);
d673 1
a673 1
			    putch(AMCH,A_INFO);
@


3.1.2.6
log
@REVISION
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1.2.5 87/07/03 22:01:30 alex Exp $
a5 3
 * Revision 3.1.2.5  87/07/03  22:01:30  alex
 * Graph_characters used in margin
 * 
d668 1
a668 1
			putch(BMCH,A_MARG);
@


3.1.1.1
log
@Отлажено_на_модели
@
text
@a6 3
 * Базовая версия для ЕС.
 * 
 * Revision 3.1  86/04/20  23:40:29  alex
d18 1
a18 1
/* int imodesw;/* 1 - режим вставки  */
d21 1
a21 1
static int editline();
a43 1
    newedit = 1;
a62 7
        if (lread1 == CCQUIT)
        {
	    putline(0);
            if (endit() == 0) goto funcdone;
            gosw = 0;
            return;
        }
d64 1
a64 1
	 * Редактирование в строке. Обычные символы могут прийти из макро.
d66 9
a74 7
	if ((! CTRLCHAR) || lread1 == CCCTRLQUOTE || lread1 == CCINSERT || lread1 == CCDELCH)
	{   /* Введем курсор в его границы */
	    if ( cursorcol < 0 ) cursorcol = 0;
	    if ( cursorline < 0 ) cursorline = 0;
	    if ( cursorcol > curport->redit) cursorcol = curport->redit;
	    if ( cursorline > curport->bedit) cursorline = curport->bedit;
	    if (openwrite[curfile] == 0) goto nowriterr;
d76 1
a76 4
	    if (clineno != (i = curwksp->ulhclno+cursorline)) {
		 if (fcline) putline(0);
		 getline(i);
	    }
d78 1
a78 1
	    if (lread1==CCDELCH )
d82 1
d85 1
d92 1
a92 1
		putup(-1,cursorline);
d98 1
a98 1
	    /* Проверка на границу окна - для МАКРО */
d109 7
a115 3
	    /* Если строка удлинилась - отведем еще память */
	    if ((i = cursorcol + curwksp->ulhccno ) >=
		(lcline - 2)) excline(i+2);
d122 1
a122 2
	    /* Вставка пробелов */
	    if (lread1==CCINSERT)
d126 3
a128 4
		if (ncline+dflinsert > lcline) excline(ncline+dflinsert);
		for (i=ncline-1;i >= thiscol;i--) cline[i+dflinsert]=cline[i];
		ncline += dflinsert;
		for ( i=0;i<dflinsert;i++) cline[i+thiscol] = ' ';
d130 1
a130 1
		putup(-1,cursorline);
d132 1
a132 2
		lread1 = -1; goto contin;
	    }
d135 1
a135 1
		curport->redit = curport->rtext + 1;
d138 1
d143 1
d165 1
a165 1
		goto newnumber;
d173 6
d187 1
a187 1
	    switchfile(); newedit = 1;
d190 1
a190 1
	    chgport(-1);newedit = 1;
d214 3
d246 1
a246 1
	    makeport(deffile); newedit = 1;
a256 1
	    /*    case CCINSERT:  */
d299 1
a299 1
	    use0flg=1;newedit = 1;
d306 1
a306 1
	    chgport(i-1); newedit = 1;
d357 7
a363 7
/*        case CCMOVELEFT:      */
	case CCTAB:
/*        case CCMOVEDOWN:      */
/*        case CCHOME:          */
/*        case CCMOVEUP:        */
/*        case CCMOVERIGHT:     */
	case CCBACKTAB:
a383 1
		newedit = 1;
d417 2
a418 7
	case CCINSERT:
	    if (paramtype > 0)
            {
                if (s2i(paramv,&i)) goto notinterr;
		dflinsert = i;
            }
	    else dflinsert = 1;
a486 1
	    newedit = 1;
a555 5
	if ( newedit ) {
		newedit = 0;
		if ( openwrite[curfile] ) editwind(curport,editline,1);
		else editwind((struct viewport *)0,(int (*)())0,0);
		}
d558 1
a558 1
	paramport.redit = PARAMRINFO;   /* !!! */
d564 1
a564 1
		putblanks(PARAMRINFO);
d595 1
a595 1
	    dumpcbuf(1);
d600 2
a608 49
 * editline(номер,строка)
 * Редактировать строку "номер" в текущем окне.
 * Заменить ее на "строка"
 */
editline(ln,str)
int ln; 
char *str;
{
    register int i;register char *cp;
    int lno; /* Номер в файле */
    int slen; /* Длина str */
    int scolno; /* Начальная колонка str */
    int newnline; /* Новая длина строки */
    /*
     * 1. Дай строку
     */
    lno = ln + curwksp->ulhclno;
    if ( lno != cline ) putline(0), getline(lno);
    /*
     * 2. Определить длину новой строки без хвостовых пробелов.
     */
    scolno = curwksp->ulhccno;
    if ( ncline-1 <= scolno+(curport->rtext+1) ){
	for ( i = curport->rtext; i>=0; i--)
            if ( str[i] != ' ' && str[i] != '\0') break;
        slen = i + 1;
	newnline = scolno + slen+1;
    } 
    else {
	slen = curport->rtext+1;
        newnline = ncline;
    }
    if ( lcline-2 < newnline ) excline(newnline+2);
    /*
     * 3. Заменяем часть строки
     */
    i = ncline-1;
    while ( i < scolno ) cline[i++] = ' ';
    for ( i = 0, cp = str; i < slen; i++, cp++ ) {
	cline[scolno+i] = (*cp?*cp:' ');
    }
    ncline = newnline;
    cline[ncline-1]=012;
    putup(-1, ln);
    fcline = 1;
    return;
}

/*
d640 1
a640 1
    dumpcbuf(1);
@


3.1.1.2
log
@Отлажено_на_модели
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1.1.1 86/06/05 00:03:11 alex Exp $
a5 3
 * Revision 3.1.1.1  86/06/05  00:03:11  alex
 * Отлажено_на_модели
 * 
d24 1
a24 1
static editline();
d323 1
a323 1
	    if (searchkey) free((char *)searchkey);
d622 1
a622 1
static editline(ln,str)
d635 1
a635 1
    if ( lno != cline ) putline(NULL), getline(lno);
@


3.1.1.3
log
@Введена установка ключей
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1.1.2 86/06/05 18:52:38 alex Exp $
a5 3
 * Revision 3.1.1.2  86/06/05  18:52:38  alex
 * Отлажено_на_модели
 * 
d638 1
a638 1
    if ( lno != cline ) putline(0), getline(lno);
d664 1
a665 10
 /*
  * Учитывая особенности терминала, устанавливаем режим - стирай все!
  */
    if ( !speccase )  {
        putline(0);
        getline(lno);
        curport->firstcol[ln]=curport->ledit;
        curport->lastcol[ln] = curport->redit;
    }
    putup(-1, ln);
@


3.1.1.4
log
@Отлажено на ЕС без режима восстановления и без макро
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1.1.3 86/06/06 00:12:49 alex Exp $
a5 3
 * Revision 3.1.1.3  86/06/06  00:12:49  alex
 * Введена установка ключей
 * 
d85 4
a88 1
	    movecursor(0);
a378 3
	    case '-': case '+':
		if ( setkeys(paramv)) goto noargerr;
                goto funcdone;
d388 6
d398 1
a398 1
		rescreen(0);
d641 1
a641 1
    if ( lno != clineno ) putline(0), getline(lno);
a880 1
    dumpcbuf(1);
@


3.1.1.5
log
@Первая версия с повтором сеанса (пока грязная)
@
text
@@


3.1.1.6
log
@Отлажен на модели повтор сеанса
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1.1.5 86/06/16 22:15:50 alex Exp $
a5 3
 * Revision 3.1.1.5  86/06/16  22:15:50  alex
 * Первая версия с повтором сеанса (пока грязная)
 * 
a254 3
	case CCRESCREEN:
	    rescreen(0);
            goto funcdone;
d395 2
a396 1
		lread1 = CCRESCREEN; goto contin;
a499 3
	case CCRESCREEN:
	    rescreen(0);
	    goto funcdone;
d625 2
a626 2
static editline(ln,str,lnos)
int ln,lnos;
d644 3
a646 1
	slen = lnos;
@


3.1.1.7
log
@Улучшен "editline"".
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1.1.6 86/06/19 00:09:42 alex Exp $
a5 3
 * Revision 3.1.1.6  86/06/19  00:09:42  alex
 * Отлажен на модели повтор сеанса
 * 
d675 5
a679 2
	putup(ln,ln);
    } else
@


3.1.1.8
log
@Введено автоматическое смещение экрана
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1.1.7 86/06/20 23:30:50 alex Exp $
a5 3
 * Revision 3.1.1.7  86/06/20  23:30:50  alex
 * Улучшен "editline"".
 * 
d53 1
a88 22
	/* Обработка RETURN  */
	if (lread1 == CCRETURN )
	{
	    if ( cursorcol < 0 && curwksp->ulhccno != 0 )
		lread1 = CCLPORT;
	    else if ( cursorcol > curport->rtext)
		lread1 = CCRPORT;
	    else if ( cursorline < 0 )
		lread1 = CCMILINE;
	    else if ( cursorline > curport->btext)
		lread1 = CCPLLINE;
	    else {
		putline(0);
		if ( cursorline == curport->btext)
		    movew(defplline);
		if((i=curwksp->ulhccno) !=0) movep(-i);
		movecursor(lread1);
		lread1= -1;
		goto errclear;
	    }
	}

d93 84
a176 4
	{
		if ( !lineop(lread1)) goto contin;
		goto funcdone;
	}
a681 90
}

/*
 * Выполнение простейших операций в строке.
 * В конце сбрасывает lread1.
 */
lineop(lr1)
register lr1;
{
	register int i,k;
	int thiscol, thisrow;
	/* Введем курсор в его границы */
	movecursor(0);
	if (openwrite[curfile] == 0) goto nowriterr;
	/* Строки у нас нет? Дай! */
	if (clineno != (i = curwksp->ulhclno+cursorline)) {
		if (fcline) putline(0);
		getline(i);
	}
	/* исключение символа */
	if (lr1==CCDELCH )
	{
		thiscol = cursorcol + curwksp->ulhccno;
		thisrow = cursorline;
		if (ncline < thiscol + 2)
			goto contin;
		for (i=thiscol;i<ncline-2;i++) cline[i] = cline[i+1];
		ncline--;
		thiscol -= curwksp->ulhccno;
		putup(-1,cursorline);
		poscursor(thiscol,thisrow);
		fcline = 1;
		goto contin;
	}
	/* Проверка на границу окна - для МАКРО */
	if (cursorcol > curport->rtext)
	{
		if (fcline) {
			putline(0);
			movep(defrport);
			goto contin;
		}
		else  goto margerr;
	}
	fcline = 1;
	/* Если строка удлинилась - отведем еще память */
	if ((i = cursorcol + curwksp->ulhccno ) >=
	    (lcline - 2)) excline(i+2);
	if (i >= ncline-1)
	{
		for (k=ncline-1; k<=i; k++) cline[k] = ' ';
		cline[i+1] = NEWLINE;
		ncline = i+2;
	}
	/* Вставка пробелов */
	if (lr1==CCINSERT)
	{
		thiscol = cursorcol + curwksp->ulhccno;
		thisrow = cursorline;
		if (ncline+dflinsert > lcline) excline(ncline+dflinsert);
		for (i=ncline-1;i >= thiscol;i--) cline[i+dflinsert]=cline[i];
		ncline += dflinsert;
		for ( i=0;i<dflinsert;i++) cline[i+thiscol] = ' ';
		thiscol -= curwksp->ulhccno;
		putup(-1,cursorline);
		poscursor(thiscol,thisrow);
		goto contin;
	}
	/* Выставим границу */
	if (cursorcol >= curport->rtext)
		curport->redit = curport->rtext + 1;
	/* Замена символа */
	if(lr1==CCCTRLQUOTE) lr1 = esc0;
	cline[i] = lr1;
	putch(lr1,1);
	/* Если переехали границу */
	curport->redit = curport->rtext;
	goto contin;
margerr:
	error("Margin stusk; move cursor to free.");
	goto errdone;
nowriterr:
	error(DIAG("You cannot modify this file!","Вы не можете изменить этот файл."));
	goto errdone;
errdone:
	lread1 = -1;
	return(1);
contin:
	lread1 = -1;
	return(0);
@


3.1.1.9
log
@RED 3.3/EC.
@
text
@d4 1
a4 1
 *      $Header: r.cmd.c,v 3.1.1.8 86/06/25 19:40:32 alex Exp $
a5 3
 * Revision 3.1.1.8  86/06/25  19:40:32  alex
 * Введено автоматическое смещение экрана
 * 
a38 4
#ifndef DEMOSES
#define NEWEDIT
int imodesw;/* 1 - режим вставки  */
#else DEMOSES
a39 4
extern short zerowsflag;
static editline();
#define NEWEDIT newedit = 1
#endif DEMOSES
d42 1
a42 1

d64 1
a64 1
    NEWEDIT;
d92 2
a93 3
        if (lread1 == CCRETURN )
        { 
#ifdef DEMOSES
d102 8
a109 10
	    else
#endif DEMOSES
	    {
            putline(0);
            if ( cursorline == curport->btext)
                movew(defplline);
            if((i=curwksp->ulhccno) !=0) movep(-i);
            movecursor(lread1);
            lread1= -1;
            goto errclear;
d112 1
d114 1
a114 2
	 * Редактирование в строке. Обычные символы на ЕС
	 * могут прийти из макро.
a115 3
#ifndef DEMOSES
        if ((! CTRLCHAR) || lread1 == CCCTRLQUOTE || lread1 == CCBACKSPACE || lread1 == CCDELCH)
#else DEMOSES
a116 1
#endif DEMOSES
d128 1
a128 4
#ifndef DEMOSES
		if(curspos)
#endif DEMOSES
			goto newnumber;
d144 1
a144 1
	    switchfile(); NEWEDIT;
d147 1
a147 1
	    chgport(-1);NEWEDIT;
a170 5
#ifndef DEMOSES
        case CCINSMODE:
            imodesw = 1 - imodesw;  /* change it */
            goto funcdone;
#endif DEMOSES
d200 1
a200 1
	    makeport(deffile); NEWEDIT;
d257 1
a257 1
	    use0flg=1;NEWEDIT;
d264 1
a264 1
	    chgport(i-1); NEWEDIT;
d315 7
a321 7
        case CCTAB:
        case CCMOVELEFT:
        case CCMOVEDOWN:
        case CCHOME:
        case CCMOVEUP:
        case CCMOVERIGHT:
        case CCBACKTAB:
a371 4
#ifndef DEMOSES
        case CCINSMODE:
	    imodesw = 1 - imodesw;  /* Щелкнем!! */
#else DEMOSES
a378 1
#endif DEMOSES
d447 1
a447 1
	    NEWEDIT;
d507 3
a519 1
#ifdef DEMOSES
d522 1
a522 1
		if ( openwrite[curfile] ) editwind(curport,editline,zerowsflag);
a524 1
#endif DEMOSES
a568 4
#ifndef DEMOSES
        if (imodesw && clrsw && !errsw)
            telluser(DIAG("     ***** i n s e r t m o d e *****","  * * * * режим вставки * * * * "),0);
#endif DEMOSES
a574 1
#ifdef DEMOSES
d612 2
a613 2
    for ( i = 0, cp = str; i < slen; i++ ) {
	cline[scolno+i] = (*cp?*cp++:' ');/* Becь xвocт зaбивaeм пpoбeлaми*/
a621 1
	curport->firstcol[ln] = 0; curport->lastcol[ln]= slen;
a716 105

#else  NOT DEMOSES

/*
 * Выполнение простейших операций в строке.
 * В конце сбрасывает lr1.
 */
lineop(lr1)
register lr1;
{
	register int i,k;
	int thiscol, thisrow;
	    /* Отмена в 1 колонке */
	    if (lr1 == CCBACKSPACE  &&  cursorcol == 0)
	    {
		lr1 = -1;
		goto contin;
	    }
	    if (openwrite[curfile] == 0) goto nowriterr;
	    /* Строки у нас нет? Дай! */
	    if (clineno != (i = curwksp->ulhclno+cursorline)) getline(i);
	    /* исключение символа */
	    if (lr1==CCDELCH || (imodesw && lr1==CCBACKSPACE) )
	    {
		thiscol = cursorcol + curwksp->ulhccno;
		thisrow = cursorline;
		if (lr1 == CCBACKSPACE) thiscol--;
		if (ncline < thiscol + 2)
		{
		    if (lr1 == CCBACKSPACE) movecursor(LT);
		    lr1 = -1;
		    goto contin;
		}
		for (i=thiscol;i<ncline-2;i++) cline[i] = cline[i+1];
		ncline--;
		thiscol -= curwksp->ulhccno;
		putup(-(1+thiscol),cursorline);
		poscursor(thiscol,thisrow);
		fcline = 1;
		lr1 = -1;
		goto contin;
	    }
	    /* Проверка на границу окна */
	    if (cursorcol > curport->rtext)
	    {
		if (fcline) {
		    putline(0);
		    movep(defrport);
		    goto contin;
		}
		else  goto margerr;
	    }
	    fcline = 1;
	    if (j = (lr1 == CCBACKSPACE))
	    {
		movecursor(LT);
		lr1 = ' ';
	    }
	    if ((i = cursorcol + curwksp->ulhccno) >=
		(lcline - 2)) excline(i+2);
	    if (i >= ncline-1)
	    {
		for (k=ncline-1; k<=i; k++) cline[k] = ' ';
		cline[i+1] = NEWLINE;
		ncline = i+2;
	    }
	    else if (imodesw)
	    {
		thiscol = cursorcol + curwksp->ulhccno;
		thisrow = cursorline;
		if (ncline >= lcline) excline(ncline+1);
		for (i=ncline;i>thiscol;i--) cline[i] = cline[i-1];
		ncline++;
		thiscol -= curwksp->ulhccno;
		putup(-(1+thiscol),cursorline);
		poscursor(thiscol,thisrow);
	    }
	    /* Выставим границу */
	    if (cursorcol >= curport->rtext)
		curport->redit = curport->rtext + 1;
	    /* Замена символа */
	    if(lr1==CCCTRLQUOTE) lr1 = esc0;
	    if (cursorcol == curport->rtext - 10) putcha(COBELL);
	    cline[i] = lr1;
	    putch(lr1,1);
	    /* Если переехали границу */
	    curport->redit = curport->rtext;
	    if (j) movecursor(LT);
	    lr1 = -1;
	    goto contin;
	}
margerr:
	error("Margin stusk; move cursor to free.");
	goto errdone;
nowriterr:
	error(DIAG("You cannot modify this file!","Вы не можете изменить этот файл."));
	goto errdone;
errdone:
	lread1 = -1;
	return(1);
contin:
	lread1 = -1;
	return(0);
}
#endif DEMOSES
@
