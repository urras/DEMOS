head     1.13;
access   ;
symbols  BSD29:1.1.2.9 AVG1:1.3 VAX:0.0.2.0 MNOS12:0.0.1;
locks    ;
comment  @ * @;


1.13
date     89.11.22.14.01.29;  author abs;  state Exp;
branches ;
next     1.12;

1.12
date     89.03.16.11.59.52;  author avg;  state Exp;
branches ;
next     1.11;

1.11
date     88.08.03.18.20.13;  author abs;  state Exp;
branches ;
next     1.10;

1.10
date     88.08.03.18.16.38;  author abs;  state Exp;
branches ;
next     1.9;

1.9
date     87.08.01.15.33.05;  author avg;  state Exp;
branches ;
next     1.8;

1.8
date     87.07.10.20.46.07;  author avg;  state Exp;
branches ;
next     1.7;

1.7
date     87.06.24.16.41.58;  author avg;  state Exp;
branches ;
next     1.6;

1.6
date     87.06.13.17.02.48;  author avg;  state Exp;
branches ;
next     1.5;

1.5
date     86.09.24.12.57.45;  author avg;  state Exp;
branches ;
next     1.4;

1.4
date     86.09.24.12.28.10;  author avg;  state Exp;
branches ;
next     1.3;

1.3
date     86.07.20.21.52.32;  author avg;  state Exp;
branches ;
next     1.2;

1.2
date     86.06.02.18.17.53;  author dmitry;  state Exp;
branches ;
next     1.1;

1.1
date     86.06.01.20.19.59;  author dmitry;  state Exp;
branches 1.1.2.9;
next     0.0;

0.0
date     86.06.01.19.17.32;  author dmitry;  state Exp;
branches 0.0.1.0 0.0.2.0;
next     ;

0.0.1.0
date     86.06.01.19.40.25;  author dmitry;  state Exp;
branches ;
next     ;

0.0.2.0
date     86.07.20.19.09.40;  author avg;  state Exp;
branches ;
next     ;

1.1.2.9
date     86.09.23.22.34.41;  author avg;  state Exp;
branches ;
next     ;


desc
@@


1.13
log
@добавлен меьанизм функций в выражениях
@
text
@#ifndef lint
/*NOXSTR*/
static  char rcsid[] = "$Header: sh.func.c,v 1.12 89/03/16 11:59:52 avg Exp $";
/*YESXSTR*/
#endif  lint

/*
 * $Log:        sh.func.c,v $
 * Revision 1.12  89/03/16  11:59:52  avg
 * Внесены изменения для экранной версии csh.
 *
 * Revision 1.11  88/08/03  18:20:13  abs
 * Добавлена dobugs для внутренней отладки.
 *
 * Revision 1.9  87/08/01  15:33:05  avg
 * Теперь evalHIST обнуляется в savehist, т.к. process
 * может сделать reset, что приводит к 'залипанию' evalHIST
 * и ошибкам при накоплении history.
 * Сия плюха замечена dmitry.
 *
 * Revision 1.8  87/07/10  20:46:07  avg
 * Добавлен ключ -h у команды eval -
 * по нему в history запоминается не сама команда eval..., а
 * команда - аргумент eval.
 *
 * Revision 1.7  87/06/24  16:41:58  avg
 * Доведена до конца пред. правка.
 * + сделана проще логика работы getword при wd == 0.
 * (интересно, почему BJ не мог это сделать сразу?).
 *
 * Revision 1.6  87/06/13  17:02:48  avg
 * Исправлена ошибка в getword при разборе конструкций вида a(b:
 * скобка ДОЛЖНА восприниматься как разделитель.
 * Эффект от этой плюхи был такой:
 *      if(a) then
 *              if(b) then
 *              else
 *              endif
 *      else
 *      endif
 * внешний if сваливался по первому else.
 * Кроме того, слегка правлены диагностики.
 *
 * Revision 1.5  86/09/24  12:57:45  avg
 * Поправлена диагностика.
 *
 * Revision 1.4  86/09/24  12:28:10  avg
 * Немного почищены vlimit-ные штуки.
 *
 * Revision 1.3  86/07/20  21:52:32  avg
 * Слита с версией alex-а из 4.2.
 *
 * Revision 1.2  86/06/02  18:17:53  dmitry
 * Слиянием с версией для МНОС 1.2 добавлены русские
 * буквы и диагностики.
 *
 * Revision 1.1  86/06/01  20:19:59  dmitry
 * DEMOS & MNOS 2 version
 *
 */

#include "sh.h"
#include <sys/ioctl.h>

/*
 * C shell
 */

struct biltins *
isbfunc(t)
	register struct command *t;
{
	register char *cp = t->t_dcom[0];
	register char *dp;
	register struct biltins *bp;
	int dolabel(), dofg1(), dobg1();
	static struct biltins label = { "", dolabel, 0, 0 };
	static struct biltins foregnd = { "%job", dofg1, 0, 0 };
	static struct biltins backgnd = { "%job &", dobg1, 0, 0 };

	if (lastchr(cp) == ':') {
		label.bname = cp;
		return (&label);
	}
	if (*cp == '%') {
		if (t->t_dflg & FAND) {
			t->t_dflg &= ~FAND;
			backgnd.bname = cp;
			return (&backgnd);
		}
		foregnd.bname = cp;
		return (&foregnd);
	}
	for (bp = bfunc; dp = bp->bname; bp++) {
		if (dp[0] == cp[0] && eq(dp, cp))
			return (bp);
		if (dp[0] > cp[0])
			break;
	}
	return (0);
}

func(t, bp)
	register struct command *t;
	register struct biltins *bp;
{
	int i;


	xechoit(t->t_dcom);
	setname(bp->bname);
	i = blklen(t->t_dcom) - 1;
	if (i < bp->minargs)
		bferr(ediag("Too few arguments",
			    "Слишом мало аргументов"));
	if (i > bp->maxargs)
		bferr(ediag("Too many arguments",
			    "Слишком много аргументов"));
	(*bp->bfunct)(t->t_dcom, t);
}

dolabel()
{

}

doonintr(v)
	char **v;
{
	register char *cp;
	register char *vv = v[1];

	if (parintr == SIG_IGN)
		return;
	if (setintr && intty)
		bferr(ediag("Can't from terminal",
			    "Нельзя с терминала"));
	cp = gointr, gointr = 0, xfree(cp);
	if (vv == 0) {
		if (setintr)
			sighold(SIGINT);
		else
			sigset(SIGINT, SIG_DFL);
		gointr = 0;
	} else if (eq((vv = strip(vv)), "-")) {
		sigset(SIGINT, SIG_IGN);
		gointr = "-";
	} else {
		gointr = savestr(vv);
		sigset(SIGINT, pintr);
	}
}

donohup()
{

	if (intty)
		bferr(ediag("Can't from terminal",
			    "Нельзя с терминала"));
	if (setintr == 0) {
		signal(SIGHUP, SIG_IGN);
#ifdef CC
		submit(getpid());
#endif
	}
}

dozip()
{

	;
}

prvars()
{

	plist(&shvhed);
}

doalias(v)
	register char **v;
{
	register struct varent *vp;
	register char *p;

	v++;
	p = *v++;
	if (p == 0)
		plist(&aliases);
	else if (*v == 0) {
		vp = adrof1(strip(p), &aliases);
		if (vp)
			blkpr(vp->vec), printf("\n");
	} else {
		if (eq(p, "alias") || eq(p, "unalias")) {
			setname(p);
			bferr(ediag("Too dangerous to alias that",
				    "Не стоит делать такой alias"));
		}
		set1(strip(p), saveblk(v), &aliases);
	}
}

unalias(v)
	char **v;
{

	unset1(v, &aliases);
}

dologout()
{

	islogin();
	goodbye();
}

dologin(v)
	char **v;
{

	islogin();
	rechist();
	signal(SIGTERM, parterm);
	execl("/bin/login", "login", v[1], 0);
	untty();
	exit(1);
}

#ifdef NEWGRP
donewgrp(v)
	char **v;
{

	if (chkstop == 0 && setintr)
		panystop(0);
	signal(SIGTERM, parterm);
	execl("/bin/newgrp", "newgrp", v[1], 0);
	execl("/usr/bin/newgrp", "newgrp", v[1], 0);
	untty();
	exit(1);
}
#endif

islogin()
{

	if (chkstop == 0 && setintr)
		panystop(0);
	if (loginsh)
		return;
	error(ediag("Not login shell",
		    "Не внешняя оболочка"));
}

doif(v, kp)
	char **v;
	struct command *kp;
{
	register int i;
	register char **vv;

	v++;
	i = expint(&v);
	vv = v;
	if (*vv == NOSTR)
		bferr(ediag("Empty if",
			    "Пустой if"));
	if (eq(*vv, "then")) {
		if (*++vv)
			bferr(ediag("Improper then",
				    "Недопустимый then"));
		setname("then");
		/*
		 * If expression was zero, then scan to else,
		 * otherwise just fall into following code.
		 */
		if (!i)
			search(ZIF, 0);
		return;
	}
	/*
	 * Simple command attached to this if.
	 * Left shift the node in this tree, munging it
	 * so we can reexecute it.
	 */
	if (i) {
		lshift(kp->t_dcom, vv - kp->t_dcom);
		reexecute(kp);
		donefds();
	}
}

/*
 * Reexecute a command, being careful not
 * to redo i/o redirection, which is already set up.
 */
reexecute(kp)
	register struct command *kp;
{

	kp->t_dflg &= FSAVE;
	kp->t_dflg |= FREDO;
	/*
	 * If tty is still ours to arbitrate, arbitrate it;
	 * otherwise dont even set pgrp's as the jobs would
	 * then have no way to get the tty (we can't give it
	 * to them, and our parent wouldn't know their pgrp, etc.
	 */
	execute(kp, tpgrp > 0 ? tpgrp : -1);
}

doelse()
{

	search(ZELSE, 0);
}

dogoto(v)
	char **v;
{
	register struct whyle *wp;
	char *lp;

	/*
	 * While we still can, locate any unknown ends of existing loops.
	 * This obscure code is the WORST result of the fact that we
	 * don't really parse.
	 */
	for (wp = whyles; wp; wp = wp->w_next)
		if (wp->w_end == 0) {
			search(ZBREAK, 0);
			wp->w_end = btell();
		} else
			bseek(wp->w_end);
	search(ZGOTO, 0, lp = globone(v[1]));
	xfree(lp);
	/*
	 * Eliminate loops which were exited.
	 */
	wfree();
}

doswitch(v)
	register char **v;
{
	register char *cp, *lp;

	v++;
	if (!*v || *(*v++) != '(')
		goto syntax;
	cp = **v == ')' ? "" : *v++;
	if (*(*v++) != ')')
		v--;
	if (*v)
syntax:
		error(ediag("Syntax error",
			    "Синтаксическая ошибка"));
	search(ZSWITCH, 0, lp = globone(cp));
	xfree(lp);
}

dobreak()
{

	if (whyles)
		toend();
	else
		bferr(ediag("Not in while/foreach",
			    "Не в while/foreach"));
}

doexit(v)
	char **v;
{
	char *s;

	if (chkstop == 0)
		panystop(0);
	/*
	 * Don't DEMAND parentheses here either.
	 */
	v++;
	if (*v) {
		s = exp( &v );
		set("status", s);
		egetn( s );     /* check if it is not number */
		if (*v)
			bferr(ediag("Expression syntax",
				    "Синтаксическая ошибка в выражении"));
	}
	btoeof();
	if (intty) {
		extern closein;

#ifdef COMMANDEDIT
		if( ttysaved )
			reset_tty(&tsave); /* восстановим состояние терминала */
#endif
		close(SHIN);
		closein = 1;
	}
}

doforeach(v)
	register char **v;
{
	register char *cp;
	register struct whyle *nwp;

	v++;
	cp = strip(*v);
	while (*cp && letter(*cp))
		cp++;
	if (*cp || strlen(*v) >= 20)
		bferr(ediag("Invalid variable",
			    "Плохая переменная"));
	cp = *v++;
	if (v[0][0] != '(' || v[blklen(v) - 1][0] != ')')
		bferr(ediag("Words not ()'ed",
			    "Слова не в ()"));
	v++;
	gflag = 0, rscan(v, tglob);
	v = glob(v);
	if (v == 0)
		bferr(ediag("No match",
			    "Нет таких имен"));
	nwp = (struct whyle *) calloc(1, sizeof *nwp);
	nwp->w_fe = nwp->w_fe0 = v; gargv = 0;
	nwp->w_start = btell();
	nwp->w_fename = savestr(cp);
	nwp->w_next = whyles;
	whyles = nwp;
	/*
	 * Pre-read the loop so as to be more
	 * comprehensible to a terminal user.
	 */
	if (intty)
		preread();
	doagain();
}

dowhile(v)
	char **v;
{
	register int status;
	register bool again = whyles != 0 && whyles->w_start == lineloc &&
	    whyles->w_fename == 0;

	v++;
	/*
	 * Implement prereading here also, taking care not to
	 * evaluate the expression before the loop has been read up
	 * from a terminal.
	 */
	if (intty && !again)
		status = !exp0int(&v, 1);
	else
		status = !expint(&v);
	if (*v)
		bferr(ediag("Expression syntax",
			    "Синтаксическая ошибка в выражении"));
	if (!again) {
		register struct whyle *nwp = (struct whyle *) calloc(1, sizeof (*nwp));

		nwp->w_start = lineloc;
		nwp->w_end = 0;
		nwp->w_next = whyles;
		whyles = nwp;
		if (intty) {
			/*
			 * The tty preread
			 */
			preread();
			doagain();
			return;
		}
	}
	if (status)
		/* We ain't gonna loop no more, no more! */
		toend();
}

preread()
{

	whyles->w_end = -1;
	if (setintr)
		sigrelse(SIGINT);
	search(ZBREAK, 0);
	if (setintr)
		sighold(SIGINT);
	whyles->w_end = btell();
}

doend()
{

	if (!whyles)
		bferr(ediag("Not in while/foreach",
			    "Не в while/foreach"));
	whyles->w_end = btell();
	doagain();
}

docontin()
{

	if (!whyles)
		bferr(ediag("Not in while/foreach",
			    "Не в while/foreach"));
	doagain();
}

doagain()
{

	/* Repeating a while is simple */
	if (whyles->w_fename == 0) {
		bseek(whyles->w_start);
		return;
	}
	/*
	 * The foreach variable list actually has a spurious word
	 * ")" at the end of the w_fe list.  Thus we are at the
	 * of the list if one word beyond this is 0.
	 */
	if (!whyles->w_fe[1]) {
		dobreak();
		return;
	}
	set(whyles->w_fename, savestr(*whyles->w_fe++));
	bseek(whyles->w_start);
}

dorepeat(v, kp)
	char **v;
	struct command *kp;
{
	register int i;

	i = getn(v[1]);
	if (setintr)
		sighold(SIGINT);
	lshift(v, 2);
	while (i > 0) {
		if (setintr)
			sigrelse(SIGINT);
		reexecute(kp);
		--i;
	}
	donefds();
	if (setintr)
		sigrelse(SIGINT);
}

doswbrk()
{

	search(ZBRKSW, 0);
}

srchx(cp)
	register char *cp;
{
	register struct srch *sp;

	for (sp = srchn; sp->s_name; sp++)
		if (eq(cp, sp->s_name))
			return (sp->s_value);
	return (-1);
}

char    Stype;
char    *Sgoal;

/*VARARGS2*/
search(type, level, goal)
	int type;
	register int level;
	char *goal;
{
	char wordbuf[BUFSIZ];
	register char *aword = wordbuf;
	register char *cp;

	Stype = type; Sgoal = goal;
	if (type == ZGOTO)
		bseek(0l);
	do {
		if (intty && fseekp == feobp)
			printf("? "), flush();
		aword[0] = 0, getword(aword);
		switch (srchx(aword)) {

		case ZELSE:
			if (level == 0 && type == ZIF)
				return;
			break;

		case ZIF:
			while (getword(aword));
			if ((type == ZIF || type == ZELSE) && eq(aword, "then"))
				level++;
			break;

		case ZENDIF:
			if (type == ZIF || type == ZELSE)
				level--;
			break;

		case ZFOREACH:
		case ZWHILE:
			if (type == ZBREAK)
				level++;
			break;

		case ZEND:
			if (type == ZBREAK)
				level--;
			break;

		case ZSWITCH:
			if (type == ZSWITCH || type == ZBRKSW)
				level++;
			break;

		case ZENDSW:
			if (type == ZSWITCH || type == ZBRKSW)
				level--;
			break;

		case ZLABEL:
			if (type == ZGOTO && getword(aword) && eq(aword, goal))
				level = -1;
			break;

		default:
			if (type != ZGOTO && (type != ZSWITCH || level != 0))
				break;
			if (lastchr(aword) != ':')
				break;
			aword[strlen(aword) - 1] = 0;
			if (type == ZGOTO && eq(aword, goal) || type == ZSWITCH && eq(aword, "default"))
				level = -1;
			break;

		case ZCASE:
			if (type != ZSWITCH || level != 0)
				break;
			getword(aword);
			if (lastchr(aword) == ':')
				aword[strlen(aword) - 1] = 0;
			cp = strip(Dfix1(aword));
			if (Gmatch(goal, cp))
				level = -1;
			xfree(cp);
			break;

		case ZDEFAULT:
			if (type == ZSWITCH && level == 0)
				level = -1;
			break;
		}
		getword(NOSTR);
	} while (level >= 0);
}

getword(wp)
	register char *wp;
{
	register int found = 0;
	register int c, d;
	char *wwp = wp;

	c = readc(1);
	d = 0;
	if( wp == 0 ) {
		while( c >= 0 && c != '\n' )
			c = readc(1);
		if (c < 0)
			goto past;
		return(0);
	}

	while (c == ' ' || c == '\t')
		c = readc(1);
	if (c == '#')
		do
			c = readc(1);
		while (c >= 0 && c != '\n');
	if (c < 0)
		goto past;
	if (c == '\n')
		goto Brk;
	unreadc(c);
	found = 1;
	do {
		c = readc(1);
		if (c == '\\' && (c = readc(1)) == '\n')
			c = ' ';
		if (any(c, "'\""))
			if (d == 0)
				d = c;
			else if (d == c)
				d = 0;
		if (c < 0)
			goto past;
		*wp++ = c;
	} while ((d || c != ' ' && c != '\t' && c != '(' && c != ')' ) && c != '\n');
Brk:
	if (found) {
		if( wwp == --wp ) wp++;
		else              unreadc(c);
		*wp = 0;
	} else
		unreadc(c);
	return (found);

past:
	switch (Stype) {

	case ZIF:
		bferr(ediag("else/endif not found",
			    "Нет else/endif"));

	case ZELSE:
		bferr(ediag("endif not found",
			    "Нет endif"));

	case ZBRKSW:
	case ZSWITCH:
		bferr(ediag("endsw not found",
			    "Нет endsw"));

	case ZBREAK:
		bferr(ediag("end not found",
			    "Нет end"));

	case ZGOTO:
		setname(Sgoal);
		bferr(ediag("label not found",
			    "метка не найдена"));
	}
	/*NOTREACHED*/
}

toend()
{

	if (whyles->w_end == 0) {
		search(ZBREAK, 0);
		whyles->w_end = btell() - 1;
	} else
		bseek(whyles->w_end);
	wfree();
}

wfree()
{
	long o = btell();

	while (whyles) {
		register struct whyle *wp = whyles;
		register struct whyle *nwp = wp->w_next;

		if (o >= wp->w_start && (wp->w_end == 0 || o < wp->w_end))
			break;
		if (wp->w_fe0)
			blkfree(wp->w_fe0);
		if (wp->w_fename)
			xfree(wp->w_fename);
		xfree((char *)wp);
		whyles = nwp;
	}
}

doecho(v)
	char **v;
{

	echo(' ', v);
}

doglob(v)
	char **v;
{

	echo(0, v);
	flush();
}

echo(sep, v)
	char sep;
	register char **v;
{
	register char *cp;
	int nonl = 0;

	if (setintr)
		sigrelse(SIGINT);
	v++;
	if (*v == 0)
		return;
	gflag = 0; rscan(v, tglob);
	if (gflag) {
		v = glob(v);
		if (v == 0)
			bferr(ediag("No match",
				    "Нет таких имен"));
	} else
		scan(v, trim);
	if (sep == ' ' && !strcmp(*v, "-n"))
		nonl++, v++;
	while (cp = *v++) {
		register int c;

		while (c = *cp++)
			putchar(QUOTED(c));
		if (*v)
			putqchar(sep);
	}
	if (sep && nonl == 0)
		putchar('\n');
	else
		flush();
	if (setintr)
		sighold(SIGINT);
	if (gargv)
		blkfree(gargv), gargv = 0;
}

char    **environ;

dosetenv(v)
	register char **v;
{
	char *pp, **ppp ;

	if( !v[1] ) {
		for( ppp = environ ; *ppp ; ppp++ )
			printf("%s\n", *ppp) ;
			return ;
	}
	if( !v[2] )
		goto Synterr ;
	if( !letter( v[1][0] ))
		goto Synterr ;
	for( pp = v[1] ; alnum( *pp ) ; pp++ ) ;
	if( *pp )
Synterr:
		error(ediag("setenv: Syntax error",
			    "setenv: Синтаксическая ошибка"));
	pp = globone( v[2] ) ;
	setenv(v[1], pp);
	if (eq(v[1], "PATH")) {
		importpath(pp);
		dohash();
	}
	xfree(pp);
}

dounsetenv(v)
	register char **v;
{

	v++;
	do
		unsetenv(*v++);
	while (*v);
}

setenv(name, value)
	char *name, *value;
{
	register char **ep;
	register char *cp, *dp;
	char *blk[2], **oep;

	if(eq(name, "MSG")) {
		_ediag = 1;
		if( *value == (char)'r' || *value == (char)'R'
		 || *value == (char)'р' || *value == (char)'Р')
			_ediag = 0;
	}
	else if(eq(name, "TERM")) {
		char *tc;
		extern int TermInitFlag;

		if( (tc = getenv("TERMCAP")) != (char *)0 && *tc != '/' )
			unsetenv("TERMCAP");
		TermInitFlag = 0;
	}

	oep = ep = environ;
	for (; *ep; ep++) {
		for (cp = name, dp = *ep; *cp && *cp == *dp; cp++, dp++)
			continue;
		if (*cp != 0 || *dp != '=')
			continue;
		cp = strspl("=", value);
		xfree(*ep);
		*ep = strspl(name, cp);
		xfree(cp);
		scan(ep, trim);
		return;
	}
	blk[0] = strspl(name, "="); blk[1] = 0;
	environ = blkspl(environ, blk);
	xfree((char *)oep);
	setenv(name, value);
}

unsetenv(name)
	char *name;
{
	register char **ep = environ;
	register char *cp, *dp;
	char **oep = ep;

	for (; *ep; ep++) {
		for (cp = name, dp = *ep; *cp && *cp == *dp; cp++, dp++)
			continue;
		if (*cp != 0 || *dp != '=')
			continue;
		cp = *ep;
		*ep = 0;
		environ = blkspl(environ, ep+1);
		*ep = cp;
		xfree(cp);
		xfree((char *)oep);
		return;
	}
}

doumask(v)
	register char **v;
{
	register char *cp = v[1];
	register int i;

	if (cp == 0) {
		i = umask(0);
		umask(i);
		printf("%o\n", i);
		return;
	}
	i = 0;
	while (digit(*cp) && *cp != '8' && *cp != '9')
		i = i * 8 + *cp++ - '0';
	if (*cp || i < 0 || i > 0777)
		bferr(ediag("Improper mask",
			    "Плохая маска"));
	umask(i);
}

#ifdef U42
struct limits {
	int     limconst;
	char    *limname;
	int     limdiv;
	char    *limscale;
} limits[] = {
	RLIMIT_CPU,     "cputime",      1,      "seconds",
	RLIMIT_FSIZE,   "filesize",     1024,   "kbytes",
	RLIMIT_DATA,    "datasize",     1024,   "kbytes",
	RLIMIT_STACK,   "stacksize",    1024,   "kbytes",
	RLIMIT_CORE,    "coredumpsize", 1024,   "kbytes",
	RLIMIT_RSS,     "memoryuse",    1024,   "kbytes",
	-1,             0,
};

struct limits *
findlim(cp)
	char *cp;
{
	register struct limits *lp, *res;

	res = 0;
	for (lp = limits; lp->limconst >= 0; lp++)
		if (prefix(cp, lp->limname)) {
			if (res)
				bferr(ediag("Ambiguous",
					    "Неоднозначно"));
			res = lp;
		}
	if (res)
		return (res);
	bferr(ediag("No such limit",
		    "Нет такого лимитирования."));
}

dolimit(v)
	register char **v;
{
	register struct limits *lp;
	register int limit;

	v++;
	if (*v == 0) {
		for (lp = limits+1; lp->limconst >= 0; lp++)
			plim(lp);
		return;
	}
	lp = findlim(v[0]);
	if (v[1] == 0) {
		plim(lp);
		return;
	}
	limit = getval(lp, v+1);
	setlim(lp, limit);
}

getval(lp, v)
	register struct limits *lp;
	char **v;
{
	register float f;
	double atof();
	char *cp = *v++;

	f = atof(cp);
	while (digit(*cp) || *cp == '.' || *cp == 'e' || *cp == 'E')
		cp++;
	if (*cp == 0) {
		if (*v == 0)
			return ((int)(f+0.5) * lp->limdiv);
		cp = *v;
	}
	switch (*cp) {

	case ':':
		if (lp->limconst != RLIMIT_CPU)
			goto badscal;
		return ((int)(f * 60.0 + atof(cp+1)));

	case 'h':
		if (lp->limconst != RLIMIT_CPU)
			goto badscal;
		limtail(cp, "hours");
		f *= 3600.;
		break;

	case 'm':
		if (lp->limconst == RLIMIT_CPU) {
			limtail(cp, "minutes");
			f *= 60.;
			break;
		}
	case 'M':
		if (lp->limconst == RLIMIT_CPU)
			goto badscal;
		*cp = 'm';
		limtail(cp, "megabytes");
		f *= 1024.*1024.;
		break;

	case 's':
		if (lp->limconst != RLIMIT_CPU)
			goto badscal;
		limtail(cp, "seconds");
		break;

	case 'k':
		if (lp->limconst == RLIMIT_CPU)
			goto badscal;
		limtail(cp, "kbytes");
		f *= 1024;
		break;

	case 'u':
		limtail(cp, "unlimited");
		return (RLIM_INFINITY);

	default:
badscal:
		bferr(ediag("Improper or unknown scale factor",
			    "Недопустимый масштабный множитель"));
	}
	return ((int)(f+0.5));
}

limtail(cp, str0)
	char *cp, *str0;
{
	register char *str = str0;

	while (*cp && *cp == *str)
		cp++, str++;
	if (*cp)
		error(ediag("Bad scaling; did you mean ``%s''?",
			    "Плохая размерность; что означает \"%s\"?"), str0);
}

plim(lp)
	register struct limits *lp;
{
	struct rlimit rlim;

	printf("%s \t", lp->limname);
	getrlimit(lp->limconst, &rlim);
	if (rlim.rlim_cur == RLIM_INFINITY)
		printf("unlimited");
	else if (lp->limconst == RLIMIT_CPU)
		psecs((long)rlim.rlim_cur);
	else
		printf("%d %s", rlim.rlim_cur / lp->limdiv, lp->limscale);
	printf("\n");
}

dounlimit(v)
	register char **v;
{
	register struct limits *lp;

	v++;
	if (*v == 0) {
		for (lp = limits+1; lp->limconst >= 0; lp++)
			setlim(lp, RLIM_INFINITY);
		return;
	}
	while (*v) {
		lp = findlim(*v++);
		setlim(lp, RLIM_INFINITY);
	}
}

setlim(lp, limit)
	register struct limits *lp;
{
	struct rlimit rlim;

	getrlimit(lp->limconst, &rlim);
	rlim.rlim_cur = limit;
	if (setrlimit(lp->limconst, &rlim) < 0)
		Perror(bname);
}
#endif U42

dosuspend()
{
	int (*old)(), ldisc;
	int ctpgrp;

	if (loginsh)
		error(ediag("Can't suspend a login shell",
			    "Не могу приостановить внешнюю оболочку"));
	untty();
	old = sigsys(SIGTSTP, SIG_DFL);
	kill(0, SIGTSTP);
	/* the shell stops here */
	sigsys(SIGTSTP, old);
	if (tpgrp != -1) {
retry:
		ioctl(FSHTTY, TIOCGPGRP, &ctpgrp);
		if (ctpgrp != opgrp) {
			old = sigsys(SIGTTIN, SIG_DFL);
			kill(0, SIGTTIN);
			sigsys(SIGTTIN, old);
			goto retry;
		}
		ioctl(FSHTTY, TIOCSPGRP, &shpgrp);
		setpgrp(0, shpgrp);
	}
	ioctl(FSHTTY, TIOCGETD, &oldisc);
	if (oldisc != NTTYDISC) {
		printf(ediag("Switching to new tty driver...\n",
			     "Используется новый терминальный драйвер...\n"));
		ldisc = NTTYDISC;
		ioctl(FSHTTY, TIOCSETD, &ldisc);
	}
}

doeval(v)
	char **v;
{
	char **oevalvec = evalvec;
	char *oevalp = evalp;
	jmp_buf osetexit;
	int reenter;
	char **gv = 0;
	int hflg = 0;
	extern evalHIST;

	v++;
	if (*v == 0)
		return;
	if( eq( *v, "-h" ) ) {
		v++;
		hflg = 1;
	}
	gflag = 0; rscan(v, tglob);
	if (gflag) {
		gv = v = glob(v);
		gargv = 0;
		if (v == 0)
			error(ediag("No match",
				    "Нет таких имен"));
		v = copyblk(v);
	} else
		scan(v, trim);
	getexit(osetexit);
	reenter = 0;
	setexit();
	reenter++;
	if (reenter == 1) {
		evalvec = v;
		evalp = 0;
		if( hflg )
			evalHIST = 1;
		process(0);
	}
	evalvec = oevalvec;
	evalp = oevalp;
	doneinp = 0;
	if (gv)
		blkfree(gv);
	resexit(osetexit);
	if (reenter >= 2)
		error(NOSTR);
}

#ifdef DOBUGS
/* Функция для отладки внутренностей */
/* Каждый может написать здесь то, что захочет */
#include <ediag.h>
int dobugs(){
	struct biltins *ptr = bfunc;
	int i=0;

	printf( "%s:\n", ediag("Builtin functions","Встроенные функции"));
	while( ptr -> bname ){
		printf( "%s", ptr-> bname );
		_shif( ptr-> bname );
		i++;
		if( i == 6 ){ i=0; printf("\n"); }
		ptr++;
	}
	if( i )printf("\n");
}

static _shif( s ) char *s;  /* Выравнивание */
{
	register i;
	for( i = 12-strlen(s); i>0; --i)
		printf(" ");
}
#endif
@


1.12
log
@Внесены изменения для экранной версии csh.
@
text
@d3 1
a3 1
static  char rcsid[] = "$Header: sh.func.c,v 1.11 88/08/03 18:20:13 abs Exp $";
d9 3
d264 1
a264 1
	i = exp(&v);
d376 1
d385 3
a387 1
		set("status", putn(exp(&v)));
d457 1
a457 1
		status = !exp0(&v, 1);
d459 1
a459 1
		status = !exp(&v);
@


1.11
log
@Добавлена dobugs для внутренней отладки.
@
text
@d3 1
a3 1
static  char rcsid[] = "$Header: sh.func.c,v 1.9 87/08/01 15:33:05 avg Exp $";
d9 3
d387 7
a393 1
	if (intty)
d395 2
a853 6
	  else if(eq(v[1], "MSG")) {
		_ediag = 1;
		if( *pp == (char)'r' || *pp == (char)'R'
		 || *pp == (char)'р' || *pp == (char)'Р')
			_ediag = 0;
	}
d870 1
a870 1
	register char **ep = environ;
d872 1
a872 1
	char *blk[2], **oep = ep;
d874 16
@


1.10
log
@добавлена dobugs для внутренней отладки.
@
text
@@


1.9
log
@Теперь evalHIST обнуляется в savehist, т.к. process
может сделать reset, что приводит к 'залипанию' evalHIST
и ошибкам при накоплении history.
Сия плюха замечена dmitry.
@
text
@d3 1
a3 1
static  char rcsid[] = "$Header: sh.func.c,v 1.8 87/07/10 20:46:07 avg Exp $";
d9 6
d103 1
d1195 27
@


1.8
log
@Добавлен ключ -h у команды eval -
по нему в history запоминается не сама команда eval..., а
команда - аргумент eval.
@
text
@d3 1
a3 1
static  char rcsid[] = "$Header: sh.func.c,v 1.7 87/06/24 16:41:58 avg Exp $";
d9 5
d1148 1
a1148 1
	int hflg = 0, oevalhist;
d1175 1
a1175 2
		if( hflg ) {
			oevalhist = evalHIST;
a1176 1
		}
a1177 2
		if( hflg )
			evalHIST = oevalhist;
@


1.7
log
@Доведена до конца пред. правка. 
+ сделана проще логика работы getword при wd == 0.
(интересно, почему BJ не мог это сделать сразу?).
@
text
@d3 1
a3 1
static  char rcsid[] = "$Header: sh.func.c,v 1.6 87/06/13 17:02:48 avg Exp $";
d9 5
d1143 2
d1149 4
d1170 4
d1175 2
@


1.6
log
@Исправлена ошибка в getword при разборе конструкций вида a(b:
скобка ДОЛЖНА восприниматься как разделитель.
Эффект от этой плюхи был такой:
	if(a) then
		if(b) then
		else
		endif
	else
	endif
внешний if сваливался по первому else.
Кроме того, слегка правлены диагностики.
@
text
@d3 1
a3 1
static  char rcsid[] = "$Header: sh.func.c,v 1.5 86/09/24 12:57:45 avg Exp $";
d9 13
d644 2
a645 2
	do {
		while (c == ' ' || c == '\t')
a646 4
		if (c == '#')
			do
				c = readc(1);
			while (c >= 0 && c != '\n');
d649 7
a655 8
		if (c == '\n') {
			if (wp)
				break;
			return (0);
		}
		unreadc(c);
		found = 1;
		do {
d657 21
a677 13
			if (c == '\\' && (c = readc(1)) == '\n')
				c = ' ';
			if (any(c, "'\""))
				if (d == 0)
					d = c;
				else if (d == c)
					d = 0;
			if (c < 0)
				goto past;
			if (wp)
				*wp++ = c;
		} while ((d || c != ' ' && c != '\t' && c != '(' && c != ')' ) && c != '\n');
	} while (wp == 0);
@


1.5
log
@Поправлена диагностика.
@
text
@d3 1
a3 1
static  char rcsid[] = "$Header: sh.func.c,v 1.4 86/09/24 12:28:10 avg Exp $";
d9 3
d555 1
a555 2
			while (getword(aword))
				continue;
d627 1
d660 1
a660 1
		} while ((d || c != ' ' && c != '\t') && c != '\n');
d662 6
a667 3
	unreadc(c);
	if (found)
		*--wp = 0;
d674 2
a675 2
		bferr(ediag("then/endif not found",
			    "Нет then/endif"));
@


1.4
log
@Немного почищены vlimit-ные штуки.
@
text
@d3 1
a3 1
static  char rcsid[] = "$Header: sh.func.c,v 1.3 86/07/20 21:52:32 avg Exp $";
d9 3
d348 1
a348 1
				    "Синатксическая ошибка в выражении"));
@


1.3
log
@Слита с версией alex-а из 4.2.
@
text
@d3 1
a3 1
static  char rcsid[] = "$Header: sh.func.c,v 1.2 86/06/02 18:17:53 dmitry Exp $";
d9 3
a888 2
#include <sys/vlimit.h>

d914 2
a915 1
				bferr("Ambiguous");
d920 2
a921 1
	bferr("No such limit");
d1008 2
a1009 1
		bferr("Improper or unknown scale factor");
d1022 2
a1023 1
		error("Bad scaling; did you mean ``%s''?", str0);
d1062 1
@


1.2
log
@Слиянием с версией для МНОС 1.2 добавлены русские
буквы и диагностики.
@
text
@d3 1
a3 3

static  char *rcsid = "$Header: sh.func.c,v 1.1 86/06/01 20:19:59 dmitry Exp $";

d9 4
d178 1
d185 1
d198 1
d363 1
a363 4
	{ register int i; register char **w;
	i = blklen(v) - 1; w = v + i;
	/* if (v[0][0] != '(' || v[blklen(v) - 1][0] != ')') */
	if (v[0][0] != '(' || **w != ')')
a365 1
		}
d884 2
a885 1
#ifdef LIMITS
d894 6
a899 7
	LIM_NORAISE,    "noraise",      1,      "",
	LIM_CPU,        "cputime",      1,      "seconds",
	LIM_FSIZE,      "filesize",     1024,   "kbytes",
	LIM_DATA,       "datasize",     1024,   "kbytes",
	LIM_STACK,      "stacksize",    1024,   "kbytes",
	LIM_CORE,       "coredumpsize", 1024,   "kbytes",
	LIM_MAXRSS,     "memoryuse",    1024,   "kbytes",
a930 2
		if (vlimit(LIM_NORAISE, -1) && getuid())
			printf("Limits cannot be raised\n");
a957 2
	if (lp->limconst == LIM_NORAISE)
		goto badscal;
d961 1
a961 1
		if (lp->limconst != LIM_CPU)
d966 1
a966 1
		if (lp->limconst != LIM_CPU)
d973 1
a973 1
		if (lp->limconst == LIM_CPU) {
d979 1
a979 1
		if (lp->limconst == LIM_CPU)
d987 1
a987 1
		if (lp->limconst != LIM_CPU)
d993 1
a993 1
		if (lp->limconst == LIM_CPU)
d1001 1
a1001 1
		return (INFINITY);
d1024 1
a1024 1
	register int lim;
d1027 2
a1028 2
	lim = vlimit(lp->limconst, -1);
	if (lim == INFINITY)
d1030 2
a1031 2
	else if (lp->limconst == LIM_CPU)
		psecs((long)lim);
d1033 1
a1033 1
		printf("%d %s", lim / lp->limdiv, lp->limscale);
d1045 1
a1045 1
			setlim(lp, INFINITY);
d1050 1
a1050 1
		setlim(lp, INFINITY);
d1058 3
a1060 1
	if (vlimit(lp->limconst, limit) < 0)
d1063 1
a1063 1
#endif
d1067 2
a1068 2
	int old, ldisc;
	short ctpgrp;
@


1.1
log
@DEMOS & MNOS 2 version
@
text
@d4 1
a4 1
static  char *rcsid = "$Header: sh.func.c,v 0.0 86/04/20 21:24:18 root Exp $";
d10 4
a13 1
 * $Log$
d67 2
a68 1
		bferr("Too few arguments");
d70 2
a71 1
		bferr("Too many arguments");
d89 2
a90 1
		bferr("Can't from terminal");
d111 2
a112 1
		bferr("Can't from terminal");
d150 2
a151 1
			bferr("Too dangerous to alias that");
d202 2
a203 1
	error("Not login shell");
d217 2
a218 1
		bferr("Empty if");
d221 2
a222 1
			bferr("Improper then");
d307 2
a308 1
		error("Syntax error");
d319 2
a320 1
		bferr("Not in while/foreach");
d336 2
a337 1
			bferr("Expression syntax");
d355 2
a356 1
		bferr("Invalid variable");
d358 7
a364 2
	if (v[0][0] != '(' || v[blklen(v) - 1][0] != ')')
		bferr("Words not ()'ed");
d369 2
a370 1
		bferr("No match");
d404 2
a405 1
		bferr("Expression syntax");
d443 2
a444 1
		bferr("Not in while/foreach");
d453 2
a454 1
		bferr("Not in while/foreach");
d661 2
a662 1
		bferr("then/endif not found");
d665 2
a666 1
		bferr("endif not found");
d670 2
a671 1
		bferr("endsw not found");
d674 2
a675 1
		bferr("end not found");
d679 2
a680 1
		bferr("label not found");
d746 2
a747 1
			bferr("No match");
d756 1
a756 1
			putchar(c | QUOTE);
d758 1
a758 1
			putchar(sep | QUOTE);
d775 1
a775 1
	char *lp = globone(v[2]);
d777 16
a792 1
	setenv(v[1], lp);
d794 1
a794 1
		importpath(lp);
d797 7
a803 1
	xfree(lp);
d879 2
a880 1
		bferr("Improper mask");
d1072 2
a1073 1
		error("Can't suspend a login shell (yet)");
d1093 2
a1094 1
		printf("Switching to new tty driver...\n");
d1117 2
a1118 1
			error("No match");
@


1.1.2.9
log
@ORIGINAL 2.9 VERSION
@
text
@d1 2
a2 1
static	char *sccsid = "@@(#)sh.func.c 4.5 81/06/19";
d4 9
d41 1
a41 1
		} 
d493 2
a494 2
char	Stype;
char	*Sgoal;
d740 1
a740 1
char	**environ;
d835 4
a838 4
	int	limconst;
	char	*limname;
	int	limdiv;
	char	*limscale;
d840 8
a847 8
	LIM_NORAISE,	"noraise",	1,	"",
	LIM_CPU,	"cputime",	1,	"seconds",
	LIM_FSIZE,	"filesize",	1024,	"kbytes",
	LIM_DATA,	"datasize",	1024,	"kbytes",
	LIM_STACK,	"stacksize",	1024,	"kbytes",
	LIM_CORE,	"coredumpsize",	1024,	"kbytes",
	LIM_MAXRSS,	"memoryuse",	1024,	"kbytes",
	-1,		0,
@


0.0
log
@Basic version
@
text
@d1 12
a12 2
/*      @@(#)sh.func.c   2.1     SCCS id keyword */
/* Copyright (c) 1980 Regents of the University of California */
d14 1
d21 2
a22 2
isbfunc(cp)
	register char *cp;
d24 1
d27 4
d32 13
a44 2
	if (lastchr(cp) == ':')
		return ((struct biltins *) 1);
d54 1
a54 1
func(t)
d56 1
a57 1
	register struct biltins *bp;
a59 16
	bp = bfunc;
	if (lastchr(t->t_dcom[0]) == ':') {
		xechoit(t->t_dcom);
		if (!eq(t->t_dcom[0], ":") && t->t_dcom[1])
			error("No args on labels");
		return (1);
	}
	bp = isbfunc(t->t_dcom[0]);
	if (bp == 0)
		return (0);
	/* timed builtins must go in background if output is pipe, or &'ed */
	if (eq(bp->bname, "time"))
		if ((t->t_dflg & FAND) || (t->t_dflg & FPOU))
			return (0);
	if (eq(bp->bname, "nohup") && t->t_dcom[1])
		return (0);
d67 1
a67 3
	i = (*bp->bfunct)(t->t_dcom, t);
	/* time and nice may not do their deeds, all others guarantee too */
	return (eq(bp->bname, "time") || eq(bp->bname, "nice") ? i : 1);
d70 5
d87 4
a90 1
		signal(SIGINT, setintr ? SIG_IGN : SIG_DFL);
d93 1
a93 1
		signal(SIGINT, SIG_IGN);
d97 1
a97 1
		signal(SIGINT, pintr);
a119 46
chngd(vp)
	register char **vp;
{
	register int i;
	register char *dp;
	register char **cdp;

	vp++;
	dp = *vp;
	if (dp)
		dp = globone(dp);
	else {
		dp = value("home");
		if (*dp == 0)
			bferr("No home");
	}
	i = chdir(dp);
	if (i < 0 && dp[0] != '/') {
		struct varent *c = adrof("cdpath");

		if (c == 0)
			goto simple;
		for (cdp = c->vec; *cdp; cdp++) {
			char buf[BUFSIZ];

			strcpy(buf, *cdp);
			strcat(buf, "/");
			strcat(buf, dp);
			i = chdir(buf);
			if (i >= 0)
				goto simple;
		}
	}
simple:
	if (i < 0 && adrof(dp)) {
		char *cp = value(dp);

		if (cp[0] == '/')
			i = chdir(cp);
	}
	if (*vp)
		xfree(dp);
	if (i < 0)
		Perror(dp);
}

d168 1
d170 1
d178 4
a181 4
#ifndef V6
	execlp("newgrp", "newgrp", v[1], 0);
#endif
	execl("/bin/newgrp", "newgrp", v[1], 0);        /* just in case */
d183 2
d190 2
d207 4
a210 3
	if (*vv && eq(*vv, "then")) {
		vv++;
		if (*vv)
d241 9
a249 2
	kp->t_dflg = FREDO;
	execute(kp);
d270 4
a273 3
		if (wp->w_end == 0)
			wp->w_end = search(ZBREAK, 0);
		else
d314 2
d369 2
a370 1
	register bool again = whyles && whyles->w_start == lineloc && whyles->w_fename == 0;
a406 1
	register int (*oldint)();
d410 1
a410 1
		oldint = signal(SIGINT, pintr);
d413 1
a413 1
		signal(SIGINT, oldint);
a459 1
	register int (*saveintr)();
d463 1
a463 1
		saveintr = signal(SIGINT, SIG_IGN);
d467 1
a467 1
			signal(SIGINT, pintr);
d473 1
a473 1
		signal(SIGINT, saveintr);
d585 1
a585 1
		getword(0);
d600 4
d681 1
a681 1
		xfree(wp);
d706 2
a707 1
	int (*saveintr)();
d709 1
a709 2
		saveintr = signal(SIGINT, pintr);

d720 2
d725 1
a725 11
		while (c = *cp++) {
			if (sep == ' ' && *cp && c == '\\') {
				c = *cp++;
				if (c == 'c') {
					flush();
					return;
				} else if (c == 'n')
					c = '\n';
				else
					putchar('\\');
			}
a726 1
		}
d730 1
a730 1
	if (sep)
d732 2
d735 1
a735 1
		signal(SIGINT, saveintr);
a739 1
#ifndef V6
d748 1
a748 1
	if (eq(v[1], "PATH"))
d750 2
d755 10
d786 1
a786 1
	xfree(oep);
d790 22
d831 181
d1013 72
@


0.0.2.0
log
@VAX BSD 4.2 version by alex (8-bits)
@
text
@d1 2
a2 2
/* $Header: sh.func.c,v 2.1 86/03/12 23:47:33 alex Exp $ */

a3 1
#include <sys/ioctl.h>
d10 2
a11 2
isbfunc(t)
	register struct command *t;
a12 1
	register char *cp = t->t_dcom[0];
a14 4
	int dolabel(), dofg1(), dobg1();
	static struct biltins label = { "", dolabel, 0, 0 };
	static struct biltins foregnd = { "%job", dofg1, 0, 0 };
	static struct biltins backgnd = { "%job &", dobg1, 0, 0 };
d16 2
a17 13
	if (lastchr(cp) == ':') {
		label.bname = cp;
		return (&label);
	}
	if (*cp == '%') {
		if (t->t_dflg & FAND) {
			t->t_dflg &= ~FAND;
			backgnd.bname = cp;
			return (&backgnd);
		} 
		foregnd.bname = cp;
		return (&foregnd);
	}
d27 1
a27 1
func(t, bp)
d29 1
a30 1
{
d33 16
d56 3
a58 1
	(*bp->bfunct)(t->t_dcom, t);
a60 5
dolabel()
{

}

d73 1
a73 4
		if (setintr)
			sighold(SIGINT);
		else
			sigset(SIGINT, SIG_DFL);
d76 1
a76 1
		sigset(SIGINT, SIG_IGN);
d80 1
a80 1
		sigset(SIGINT, pintr);
d103 46
a196 2
	rechist();
	signal(SIGTERM, parterm);
a197 1
	untty();
a200 1
#ifdef NEWGRP
d205 4
a208 4
	if (chkstop == 0 && setintr)
		panystop(0);
	signal(SIGTERM, parterm);
	execl("/bin/newgrp", "newgrp", v[1], 0);
a209 2
	untty();
	exit(1);
a210 1
#endif
a214 2
	if (chkstop == 0 && setintr)
		panystop(0);
d230 3
a232 4
	if (*vv == NOSTR)
		bferr("Empty if");
	if (eq(*vv, "then")) {
		if (*++vv)
d263 2
a264 9
	kp->t_dflg &= FSAVE;
	kp->t_dflg |= FREDO;
	/*
	 * If tty is still ours to arbitrate, arbitrate it;
	 * otherwise dont even set pgrp's as the jobs would
	 * then have no way to get the tty (we can't give it
	 * to them, and our parent wouldn't know their pgrp, etc.
	 */
	execute(kp, tpgrp > 0 ? tpgrp : -1);
d285 3
a287 4
		if (wp->w_end == 0) {
			search(ZBREAK, 0);
			wp->w_end = btell();
		} else
a327 2
	if (chkstop == 0)
		panystop(0);
d381 1
a381 2
	register bool again = whyles != 0 && whyles->w_start == lineloc &&
	    whyles->w_fename == 0;
d418 1
d422 1
a422 1
		sigrelse(SIGINT);
d425 1
a425 1
		sighold(SIGINT);
d472 1
d476 1
a476 1
		sighold(SIGINT);
d480 1
a480 1
			sigrelse(SIGINT);
d486 1
a486 1
		sigrelse(SIGINT);
d506 2
a507 2
char	Stype;
char	*Sgoal;
d598 1
a598 1
		getword(NOSTR);
a612 4
		if (c == '#')
			do
				c = readc(1);
			while (c >= 0 && c != '\n');
d690 1
a690 1
		xfree((char *)wp);
d715 3
a717 1
	int nonl = 0;
a718 2
	if (setintr)
		sigrelse(SIGINT);
a728 2
	if (sep == ' ' && !strcmp(*v, "-n"))
		nonl++, v++;
d732 13
a744 2
		while (c = *cp++)
			putqchar(c);
d746 1
a746 1
			putqchar(sep);
d748 1
a748 1
	if (sep && nonl == 0)
a749 2
	else
		flush();
d751 1
a751 1
		sighold(SIGINT);
d756 2
a757 1
char	**environ;
d765 1
a765 1
	if (eq(v[1], "PATH")) {
a766 2
		dohash();
	}
a769 10
dounsetenv(v)
	register char **v;
{

	v++;
	do
		unsetenv(*v++);
	while (*v);
}

d791 1
a791 1
	xfree((char *)oep);
a794 22
unsetenv(name)
	char *name;
{
	register char **ep = environ;
	register char *cp, *dp;
	char **oep = ep;

	for (; *ep; ep++) {
		for (cp = name, dp = *ep; *cp && *cp == *dp; cp++, dp++)
			continue;
		if (*cp != 0 || *dp != '=')
			continue;
		cp = *ep;
		*ep = 0;
		environ = blkspl(environ, ep+1);
		*ep = cp;
		xfree(cp);
		xfree((char *)oep);
		return;
	}
}

d814 1
a814 250


struct limits {
	int	limconst;
	char	*limname;
	int	limdiv;
	char	*limscale;
} limits[] = {
	RLIMIT_CPU,	"cputime",	1,	"seconds",
	RLIMIT_FSIZE,	"filesize",	1024,	"kbytes",
	RLIMIT_DATA,	"datasize",	1024,	"kbytes",
	RLIMIT_STACK,	"stacksize",	1024,	"kbytes",
	RLIMIT_CORE,	"coredumpsize",	1024,	"kbytes",
	RLIMIT_RSS,	"memoryuse",	1024,	"kbytes",
	-1,		0,
};

struct limits *
findlim(cp)
	char *cp;
{
	register struct limits *lp, *res;

	res = 0;
	for (lp = limits; lp->limconst >= 0; lp++)
		if (prefix(cp, lp->limname)) {
			if (res)
				bferr("Ambiguous");
			res = lp;
		}
	if (res)
		return (res);
	bferr("No such limit");
}

dolimit(v)
	register char **v;
{
	register struct limits *lp;
	register int limit;

	v++;
	if (*v == 0) {
		for (lp = limits+1; lp->limconst >= 0; lp++)
			plim(lp);
		return;
	}
	lp = findlim(v[0]);
	if (v[1] == 0) {
		plim(lp);
		return;
	}
	limit = getval(lp, v+1);
	setlim(lp, limit);
}

getval(lp, v)
	register struct limits *lp;
	char **v;
{
	register float f;
	double atof();
	char *cp = *v++;

	f = atof(cp);
	while (digit(*cp) || *cp == '.' || *cp == 'e' || *cp == 'E')
		cp++;
	if (*cp == 0) {
		if (*v == 0)
			return ((int)(f+0.5) * lp->limdiv);
		cp = *v;
	}
	switch (*cp) {

	case ':':
		if (lp->limconst != RLIMIT_CPU)
			goto badscal;
		return ((int)(f * 60.0 + atof(cp+1)));

	case 'h':
		if (lp->limconst != RLIMIT_CPU)
			goto badscal;
		limtail(cp, "hours");
		f *= 3600.;
		break;

	case 'm':
		if (lp->limconst == RLIMIT_CPU) {
			limtail(cp, "minutes");
			f *= 60.;
			break;
		}
	case 'M':
		if (lp->limconst == RLIMIT_CPU)
			goto badscal;
		*cp = 'm';
		limtail(cp, "megabytes");
		f *= 1024.*1024.;
		break;

	case 's':
		if (lp->limconst != RLIMIT_CPU)
			goto badscal;
		limtail(cp, "seconds");
		break;

	case 'k':
		if (lp->limconst == RLIMIT_CPU)
			goto badscal;
		limtail(cp, "kbytes");
		f *= 1024;
		break;

	case 'u':
		limtail(cp, "unlimited");
		return (RLIM_INFINITY);

	default:
badscal:
		bferr("Improper or unknown scale factor");
	}
	return ((int)(f+0.5));
}

limtail(cp, str0)
	char *cp, *str0;
{
	register char *str = str0;

	while (*cp && *cp == *str)
		cp++, str++;
	if (*cp)
		error("Bad scaling; did you mean ``%s''?", str0);
}

plim(lp)
	register struct limits *lp;
{
	struct rlimit rlim;

	printf("%s \t", lp->limname);
	getrlimit(lp->limconst, &rlim);
	if (rlim.rlim_cur == RLIM_INFINITY)
		printf("unlimited");
	else if (lp->limconst == RLIMIT_CPU)
		psecs((long)rlim.rlim_cur);
	else
		printf("%d %s", rlim.rlim_cur / lp->limdiv, lp->limscale);
	printf("\n");
}

dounlimit(v)
	register char **v;
{
	register struct limits *lp;

	v++;
	if (*v == 0) {
		for (lp = limits+1; lp->limconst >= 0; lp++)
			setlim(lp, RLIM_INFINITY);
		return;
	}
	while (*v) {
		lp = findlim(*v++);
		setlim(lp, RLIM_INFINITY);
	}
}

setlim(lp, limit)
	register struct limits *lp;
{
	struct rlimit rlim;

	getrlimit(lp->limconst, &rlim);
	rlim.rlim_cur = limit;
	if (setrlimit(lp->limconst, &rlim) < 0)
		Perror(bname);
}

dosuspend()
{
	int (*old)(), ldisc;
	int ctpgrp;

	if (loginsh)
		error("Can't suspend a login shell (yet)");
	untty();
	old = sigsys(SIGTSTP, SIG_DFL);
	kill(0, SIGTSTP);
	/* the shell stops here */
	sigsys(SIGTSTP, old);
	if (tpgrp != -1) {
retry:
		ioctl(FSHTTY, TIOCGPGRP, &ctpgrp);
		if (ctpgrp != opgrp) {
			old = sigsys(SIGTTIN, SIG_DFL);
			kill(0, SIGTTIN);
			sigsys(SIGTTIN, old);
			goto retry;
		}
		ioctl(FSHTTY, TIOCSPGRP, &shpgrp);
		setpgrp(0, shpgrp);
	}
	ioctl(FSHTTY, TIOCGETD, &oldisc);
	if (oldisc != NTTYDISC) {
		printf("Switching to new tty driver...\n");
		ldisc = NTTYDISC;
		ioctl(FSHTTY, TIOCSETD, &ldisc);
	}
}

doeval(v)
	char **v;
{
	char **oevalvec = evalvec;
	char *oevalp = evalp;
	jmp_buf osetexit;
	int reenter;
	char **gv = 0;

	v++;
	if (*v == 0)
		return;
	gflag = 0; rscan(v, tglob);
	if (gflag) {
		gv = v = glob(v);
		gargv = 0;
		if (v == 0)
			error("No match");
		v = copyblk(v);
	} else
		scan(v, trim);
	getexit(osetexit);
	reenter = 0;
	setexit();
	reenter++;
	if (reenter == 1) {
		evalvec = v;
		evalp = 0;
		process(0);
	}
	evalvec = oevalvec;
	evalp = oevalp;
	doneinp = 0;
	if (gv)
		blkfree(gv);
	resexit(osetexit);
	if (reenter >= 2)
		error(NOSTR);
}
@


0.0.1.0
log
@MNOS 1.2 version
@
text
@d1 2
a6 5
 *
 * $Log:	sh.func.c,v $
 * Revision 1.1  86/02/24  20:23:05  sys
 * Initial revision
 * 
d37 1
a37 2
			error(ediag("No args on labels",
				    "Mетки должны быть без аргументов"));
d53 1
a53 2
		bferr(ediag("Too few arguments",
			    "Слишом мало аргументов"));
d55 1
a55 2
		bferr(ediag("Too many arguments",
			    "Слишком много аргументов"));
d70 1
a70 2
		bferr(ediag("Can't from terminal",
			    "Нельзя с терминала"));
d88 1
a88 2
		bferr(ediag("Can't from terminal",
			    "Нельзя с терминала"));
d117 1
a117 2
			bferr(ediag("No home",
				    "Нет home"));
d172 1
a172 2
			bferr(ediag("Too dangerous to alias that",
				    "Не стоит делать такой alias"));
a196 1
	signal(SIGTERM, parterm);
d205 4
a208 2
	signal(SIGTERM, parterm);
	execl("/bin/newgrp", "newgrp", v[1], 0);
d217 1
a217 2
	error(ediag("Not login shell",
		    "Не начальный shell"));
d233 1
a233 2
			bferr(ediag("Improper then",
				    "Недопустимый then"));
d310 1
a310 2
		error(ediag("Syntax error",
			    "Синтаксическая ошибка"));
d321 1
a321 2
		bferr(ediag("Not in while/foreach",
			    "Не в while/foreach"));
d335 1
a335 2
			bferr(ediag("Expression syntax",
				    "Синатксическая ошибка в выражении"));
d353 1
a353 2
		bferr(ediag("Invalid variable",
			    "Плохая переменная"));
d355 2
a356 7
	{ register int i; register char **w;
	i = blklen(v) - 1; w = v + i;
	/* if (v[0][0] != '(' || v[blklen(v) - 1][0] != ')') */
	if (v[0][0] != '(' || **w != ')')
		bferr(ediag("Words not ()'ed",
			    "Слова не в ()"));
		}
d361 1
a361 2
		bferr(ediag("No match",
			    "Нет таких имен"));
d394 1
a394 2
		bferr(ediag("Expression syntax",
			    "Синтаксическая ошибка в выражении"));
d433 1
a433 2
		bferr(ediag("Not in while/foreach",
			    "Не в while/foreach"));
d442 1
a442 2
		bferr(ediag("Not in while/foreach",
			    "Не в while/foreach"));
d646 1
a646 2
		bferr(ediag("then/endif not found",
			    "Нет then/endif"));
d649 1
a649 2
		bferr(ediag("endif not found",
			    "Нет endif"));
d653 1
a653 2
		bferr(ediag("endsw not found",
			    "Нет endsw"));
d656 1
a656 2
		bferr(ediag("end not found",
			    "Нет end"));
d660 1
a660 2
		bferr(ediag("label not found",
			    "метка не найдена"));
d726 1
a726 2
			bferr(ediag("No match",
				    "Нет таких имен"));
d743 1
a743 1
			putqchar(c);
d746 1
a746 1
			putqchar(sep);
d762 1
a762 1
	char *pp, **ppp ;
d764 4
a767 28
	if( !v[1] ) {
		for( ppp = environ ; *ppp ; ppp++ )
			printf("%s\n", *ppp) ;
			return ;
	}
	if( !v[2] )
		goto Synterr ;
	if( !letter( v[1][0] ))
		goto Synterr ;
	for( pp = v[1] ; alnum( *pp ) ; pp++ ) ;
	if( *pp )
Synterr:
		error(ediag("setenv: Syntax error",
			    "setenv: Синтаксическая ошибка"));
	pp = globone( v[2] ) ;
	setenv(v[1], pp);
	if (eq(v[1], "PATH")) {
		importpath(pp);
		dohash();
	}
#ifdef EDIAG
	  else if(eq(v[1], "MSG")) {
		_ediag = 1;
		if( *pp == 'r' )
			_ediag = 0;
	}
#endif EDIAG
	xfree(pp);
d811 1
a811 2
		bferr(ediag("Improper mask",
			    "Плохая маска"));
d814 1
a814 57
#endif  V6

#ifdef  GOGO
dogogo( v )
char **v ;
{
	extern GOGOflag ;

	if( strcmp( v[1], "on" ) == 0 )
		GOGOflag = 1 ;
	else if( strcmp( v[1], "off" ) == 0 )
		GOGOflag = 0 ;
	else
		error( "You little fool Rotten. Only 'on' or 'off' here" ) ;
}
#endif  GOGO

doeval(v)
register char **v;
{
	char  **oevalvec = evalvec;
	char   *oevalp   = evalp;
	jmp_buf osetexit;
	int     reenter;
	register char **gv = 0;

	v++;
	if(*v == 0)
		return;
	gflag = 0;
	rscan(v, tglob);
	if(gflag) {
		gv = v = glob(v);
		gargv = 0;
		if(v == 0)
			error( ediag("No match", "Не найдено") );
		v = copyblk(v);
	} else
		scan(v, trim);
	getexit(osetexit);
	reenter = 0;
	setexit();
	reenter++;
	if(reenter == 1) {
		evalvec = v;
		evalp = 0;
		process(0);
	}
	evalvec = oevalvec;
	evalp = oevalp;
	doneinp = 0;
	if(gv)
		blkfree(gv);
	resexit(osetexit);
	if(reenter >= 2)
		error(NOSTR);
}
@
