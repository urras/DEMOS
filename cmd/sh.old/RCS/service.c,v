head     0.5;
access   ;
symbols  MNOS:0.3 SYSTEM2_9:0.2 DEMOS1_3:0.1;
locks    ;
comment  @ * @;


0.5
date     88.09.22.18.12.26;  author avg;  state Exp;
branches ;
next     0.4;

0.4
date     86.09.29.18.30.08;  author alex;  state Exp;
branches ;
next     0.3;

0.3
date     86.09.24.21.54.48;  author alex;  state Exp;
branches ;
next     0.2;

0.2
date     86.09.24.21.42.48;  author alex;  state Exp;
branches ;
next     0.1;

0.1
date     86.09.24.21.17.06;  author alex;  state Exp;
branches ;
next     ;


desc
@SHELL -интерпретатор
@


0.5
log
@Поправлен NEWEXEC - если файл начинается на
	#\n       
то по-прежнему должен вызываться CSH.
@
text
@#
/*
 * KIAE  shell
 */

#include        "defs.h"


PROC VOID       gsort();

#define ARGMK   01

INT             errno;
STRING          sysmsg[];

/* fault handling */
#define ENOMEM  12
#define ENOEXEC 8
#define E2BIG   7
#define ENOENT  2
#define ETXTBSY 26



/* service routines for `execute' */

VOID    initio(iop)
	IOPTR           iop;
{
	REG STRING      ion;
	REG INT         iof, fd;

	IF iop
	THEN    iof=iop->iofile;
		ion=mactrim(iop->ioname);
		IF *ion ANDF (flags&noexec)==0
		THEN    IF iof&IODOC
			THEN    subst(chkopen(ion),(fd=tmpfil()));
				close(fd); fd=chkopen(tmpout); unlink(tmpout);
			ELIF iof&IOMOV
			THEN    IF eq(minus,ion)
				THEN    fd = -1;
					close(iof&IOUFD);
				ELIF (fd=stoi(ion))>=USERIO
				THEN    failed(ion,badfile);
				ELSE    fd=dup(fd);
				FI
			ELIF (iof&IOPUT)==0
			THEN    fd=chkopen(ion);
			ELIF flags&rshflg
			THEN    failed(ion,restricted);
			ELIF iof&IOAPP ANDF (fd=open(ion,1))>=0
			THEN    lseek(fd, 0L, 2);
			ELSE    fd=create(ion);
			FI
			IF fd>=0
			THEN    rename(fd,iof&IOUFD);
			FI
		FI
		initio(iop->ionxt);
	FI
}

STRING  getpath(s)
	STRING          s;
{
	REG STRING      path;
	IF any('/',s)
	THEN    IF flags&rshflg
		THEN    failed(s, restricted);
		ELSE    return(nullstr);
		FI
	ELIF (path = pathnod.namval)==0
	THEN    return(defpath);
	ELSE    return(cpystak(path));
	FI
}

INT     pathopen(path, name)
	REG STRING      path, name;
{
	REG UFD         f;

	REP path=catpath(path,name);
	PER (f=open(curstak(),0))<0 ANDF path DONE
	return(f);
}

STRING  catpath(path,name)
	REG STRING      path;
	STRING          name;
{
	/* leaves result on top of stack */
	REG STRING      scanp = path,
			argp = locstak();

	WHILE *scanp ANDF *scanp!=COLON DO *argp++ = *scanp++ OD
	IF scanp!=path THEN *argp++='/' FI
	IF *scanp==COLON THEN scanp++ FI
	path=(*scanp ? scanp : 0); scanp=name;
	WHILE (*argp++ = *scanp++) DONE
	return(path);
}

LOCAL STRING    xecmsg;
LOCAL STRING    *xecenv;

VOID    execa(at)
	STRING          at[];
{
	REG STRING      path;
	REG STRING      *t = at;

	IF (flags&noexec)==0
	THEN    xecmsg=notfound; path=getpath(*t);
		namscan(exname);
		xecenv=setenv();
		WHILE path=execs(path,t) DONE
		failed(*t,xecmsg);
	FI
}

LOCAL STRING    execs(ap,t)
	STRING          ap;
	REG STRING      t[];
{
	REG STRING      p, prefix;

	prefix=catpath(ap,t[0]);
	trim(p=curstak());

	sigchk();
	execve(p, &t[0] ,xecenv);
	SWITCH errno IN

	    case ENOEXEC:
		flags=0;
		comdiv=0; ioset=0;
		clearup(); /* remove open files and for loop junk */
		IF input THEN close(input) FI
		close(output); output=2;
		input=chkopen(p);

		/* band aid to get csh... 2/26/79 */
		{
			char s[2];

			if (!isatty(input)) {
				read(input, s, 2);
				if (s[0] == '#'
#ifdef NEWEXEC
				&&  s[1] == '\n'
#endif NEWEXEC
						 )
					gocsh(t, p, xecenv);
				lseek(input, (long) 0, 0);
			}
		}

		/* set up new args */
		setargs(t);
		longjmp(subshell,1);

	    case ENOMEM:
		failed(p,toobig);

	    case E2BIG:
		failed(p,arglist);

	    case ETXTBSY:
		failed(p,txtbsy);

	    default:
		xecmsg=badexec;
	    case ENOENT:
		return(prefix);
	ENDSW
}

gocsh(t, cp, xecenv)
	register char **t, *cp, **xecenv;
{
	char **newt[1000];
	register char **p;
	register int i;

	for (i = 0; t[i]; i++)
		newt[i+1] = t[i];
	newt[i+1] = 0;
	newt[0] = "/bin/csh";
	newt[1] = cp;
	execve("/bin/csh", newt, xecenv);
}

/* for processes to be waited for */
#define MAXP 20
LOCAL INT       pwlist[MAXP];
LOCAL INT       pwc;

postclr()
{
	REG INT         *pw = pwlist;

	WHILE pw <= &pwlist[pwc]
	DO *pw++ = 0 OD
	pwc=0;
}

VOID    post(pcsid)
	INT             pcsid;
{
	REG INT         *pw = pwlist;

	IF pcsid
	THEN	WHILE *pw DO pw++ OD
		IF pwc >= MAXP-1
		THEN	pw--;
		ELSE	pwc++;
		FI
		*pw = pcsid;
	FI
}

VOID	await(i)
	INT		i;
{
	INT		rc=0, wx=0;
	INT		w;
	INT		ipwc = pwc;

	post(i);
	WHILE pwc
	DO	REG INT		p;
		REG INT		sig;
		INT		w_hi;

		BEGIN
		   REG INT	*pw=pwlist;
		   p=wait(&w);
		   WHILE pw <= &pwlist[ipwc]
		   DO IF *pw==p
		      THEN *pw=0; pwc--;
		      ELSE pw++;
		      FI
		   OD
		END

		IF p == -1 THEN continue FI

		w_hi = (w>>8)&LOBYTE;

		IF sig = w&0177
		THEN	IF sig == 0177	/* ptrace! return */
			THEN	prs("ptrace: ");
				sig = w_hi;
			FI
			IF sysmsg[sig]
			THEN	IF i!=p ORF (flags&prompt)==0 THEN prp(); prn(p); blank() FI
				prs(sysmsg[sig]);
				IF w&0200 THEN prs(coredump) FI
			FI
			newline();
		FI

		IF rc==0
		THEN	rc = (sig ? sig|SIGFLG : w_hi);
		FI
		wx |= w;
	OD

	IF wx ANDF flags&errflg
	THEN	exitsh(rc);
	FI
	exitval=rc; exitset();
}

BOOL		nosubst;

trim(at)
	STRING		at;
{
	REG STRING	p;
	REG CHAR	c;
	REG CHAR	q=0;

	IF p=at
	THEN	WHILE c = *p
		DO *p++=smask(c); q |= c OD
	FI
	nosubst=isq(q);
}

STRING	mactrim(s)
	STRING		s;
{
	REG STRING	t=macro(s);
	trim(t);
	return(t);
}

STRING	*scan(argn)
	INT		argn;
{
	REG ARGPTR	argp = Rcheat(gchain)&~ARGMK;
	REG STRING	*comargn, *comargm;

	comargn=getstak(BYTESPERWORD*argn+BYTESPERWORD); comargm = comargn += argn; *comargn = ENDARGS;

	WHILE argp
	DO	*--comargn = argp->argval;
		IF argp = argp->argnxt
		THEN trim(*comargn);
		FI
		IF argp==0 ORF Rcheat(argp)&ARGMK
		THEN	gsort(comargn,comargm);
			comargm = comargn;
		FI
		/* Lcheat(argp) &= ~ARGMK; */
		argp = Rcheat(argp)&~ARGMK;
	OD
	return(comargn);
}

LOCAL VOID	gsort(from,to)
	STRING		from[], to[];
{
	INT		k, m, n;
	REG INT		i, j;

	IF (n=to-from)<=1 THEN return FI

	FOR j=1; j<=n; j*=2 DONE

	FOR m=2*j-1; m/=2;
	DO  k=n-m;
	    FOR j=0; j<k; j++
	    DO	FOR i=j; i>=0; i-=m
		DO  REG STRING *fromi; fromi = &from[i];
		    IF cf(fromi[m],fromi[0])>0
		    THEN break;
		    ELSE STRING s; s=fromi[m]; fromi[m]=fromi[0]; fromi[0]=s;
		    FI
		OD
	    OD
	OD
}

/* Argument list generation */

INT	getarg(ac)
	COMPTR		ac;
{
	REG ARGPTR	argp;
	REG INT		count=0;
	REG COMPTR	c;

	IF c=ac
	THEN	argp=c->comarg;
		WHILE argp
		DO	count += split(macro(argp->argval));
			argp=argp->argnxt;
		OD
	FI
	return(count);
}

LOCAL INT	split(s)
	REG STRING	s;
{
	REG STRING	argp;
	REG INT		c;
	INT		count=0;

	LOOP	sigchk(); argp=locstak()+BYTESPERWORD;
		WHILE (c = *s++, !any(c,ifsnod.namval) && c)
		DO *argp++ = c OD
		IF argp==staktop+BYTESPERWORD
		THEN	IF c
			THEN	continue;
			ELSE	return(count);
			FI
		ELIF c==0
		THEN	s--;
		FI
		IF c=expand((argp=endstak(argp))->argval,0)
		THEN	count += c;
		ELSE	/* assign(&fngnod, argp->argval); */
			makearg(argp); count++;
		FI
		Lcheat(gchain) |= ARGMK;
	POOL
}
/* ИАЭ им. И. В. КУРЧАТОВА, МОСКВА, 1984 (КОИ-8) */
@


0.4
log
@Версия, слитая из 2.9 и ДЕМОС без русских диагностик
@
text
@d6 1
a6 1
#include	"defs.h"
d9 1
a9 1
PROC VOID	gsort();
d11 1
a11 1
#define ARGMK	01
d13 2
a14 2
INT		errno;
STRING		sysmsg[];
d17 1
a17 1
#define ENOMEM	12
d19 2
a20 2
#define E2BIG	7
#define ENOENT	2
d27 2
a28 2
VOID	initio(iop)
	IOPTR		iop;
d30 2
a31 2
	REG STRING	ion;
	REG INT		iof, fd;
d34 1
a34 1
	THEN	iof=iop->iofile;
d37 2
a38 2
		THEN	IF iof&IODOC
			THEN	subst(chkopen(ion),(fd=tmpfil()));
d41 2
a42 2
			THEN	IF eq(minus,ion)
				THEN	fd = -1;
d45 2
a46 2
				THEN	failed(ion,badfile);
				ELSE	fd=dup(fd);
d49 1
a49 1
			THEN	fd=chkopen(ion);
d51 1
a51 1
			THEN	failed(ion,restricted);
d53 2
a54 2
			THEN	lseek(fd, 0L, 2);
			ELSE	fd=create(ion);
d57 1
a57 1
			THEN	rename(fd,iof&IOUFD);
d64 2
a65 2
STRING	getpath(s)
	STRING		s;
d67 1
a67 1
	REG STRING	path;
d69 3
a71 3
	THEN	IF flags&rshflg
		THEN	failed(s, restricted);
		ELSE	return(nullstr);
d74 2
a75 2
	THEN	return(defpath);
	ELSE	return(cpystak(path));
d79 2
a80 2
INT	pathopen(path, name)
	REG STRING	path, name;
d82 1
a82 1
	REG UFD		f;
d89 3
a91 3
STRING	catpath(path,name)
	REG STRING	path;
	STRING		name;
d94 1
a94 1
	REG STRING	scanp = path,
d105 2
a106 2
LOCAL STRING	xecmsg;
LOCAL STRING	*xecenv;
d108 2
a109 2
VOID	execa(at)
	STRING		at[];
d111 2
a112 2
	REG STRING	path;
	REG STRING	*t = at;
d115 1
a115 1
	THEN	xecmsg=notfound; path=getpath(*t);
d123 3
a125 3
LOCAL STRING	execs(ap,t)
	STRING		ap;
	REG STRING	t[];
d127 1
a127 1
	REG STRING	p, prefix;
a143 1
#ifndef NEWEXEC
d146 2
a147 1
			char c;
d149 6
a154 2
				read(input, &c, 1);
				if (c == '#')
a159 1
#endif
a179 1
#ifndef NEWEXEC
a194 1
#endif NEWEXEC
d197 2
a198 2
LOCAL INT	pwlist[MAXP];
LOCAL INT	pwc;
d202 1
a202 1
	REG INT		*pw = pwlist;
d209 2
a210 2
VOID	post(pcsid)
	INT		pcsid;
d212 1
a212 1
	REG INT		*pw = pwlist;
@


0.3
log
@Версия из МНОС
@
text
@d3 1
a3 3
 * МНОС РЛ 1.2 shell
 *
 *
d6 1
a6 1
#include        "defs.h"
d9 1
a9 1
PROC VOID       gsort();
d11 1
a11 1
#define ARGMK   01
d13 2
a14 2
INT             errno;
STRING          *sysmsg;
d17 1
a17 1
#define ENOMEM  12
d19 2
a20 2
#define E2BIG   7
#define ENOENT  2
d24 1
d144 1
d156 1
d177 1
d193 1
d287 1
a287 1
		DO *p++=smask(c); q |= _ctype3[c] OD
@


0.2
log
@Версия из 2.9
@
text
@d3 1
a3 1
 * UNIX shell
a4 2
 * S. R. Bourne
 * Bell Telephone Laboratories
d8 1
a8 1
#include	"defs.h"
d11 1
a11 1
PROC VOID	gsort();
d13 1
a13 1
#define ARGMK	01
d15 2
a16 2
INT		errno;
STRING		sysmsg[];
d19 1
a19 1
#define ENOMEM	12
d21 2
a22 2
#define E2BIG	7
#define ENOENT	2
a25 1

d145 11
d176 15
d284 1
a284 1
		DO *p++=c&STRIP; q |= c OD
d286 1
a286 1
	nosubst=q&QUOTE;
d389 1
@


0.1
log
@*** empty log message ***
@
text
@d3 5
a7 1
 * KIAE  shell
a147 11
		/* band aid to get csh... 2/26/79 */
		{
			char c;
			if (!isatty(input)) {
				read(input, &c, 1);
				if (c == '#')
					gocsh(t, p, xecenv);
				lseek(input, (long) 0, 0);
			}
		}

a167 15
gocsh(t, cp, xecenv)
	register char **t, *cp, **xecenv;
{
	char **newt[1000];
	register char **p;
	register int i;

	for (i = 0; t[i]; i++)
		newt[i+1] = t[i];
	newt[i+1] = 0;
	newt[0] = "/bin/csh";
	newt[1] = cp;
	execve("/bin/csh", newt, xecenv);
}

d261 1
a261 1
		DO *p++=smask(c); q |= c OD
d263 1
a263 1
	nosubst=isq(q);
a365 1
/* ИАЭ им. И. В. КУРЧАТОВА, МОСКВА, 1984 (КОИ-8) */
@
