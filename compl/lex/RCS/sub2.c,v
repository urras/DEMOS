head     1.6;
access   ;
symbols  ;
locks    ;
comment  @ * @;


1.6
date     88.10.21.20.18.48;  author abs;  state Exp;
branches ;
next     1.5;

1.5
date     88.10.21.19.19.07;  author abs;  state Exp;
branches ;
next     1.4;

1.4
date     88.10.21.18.48.47;  author abs;  state Exp;
branches ;
next     1.3;

1.3
date     87.03.22.21.06.55;  author avg;  state Exp;
branches ;
next     1.2;

1.2
date     86.12.28.20.30.24;  author avg;  state Exp;
branches ;
next     1.1;

1.1
date     86.12.28.18.50.58;  author avg;  state Exp;
branches ;
next     1.0;

1.0
date     86.12.28.18.42.20;  author avg;  state Exp;
branches ;
next     ;


desc
@Построитель лексических анализатров LEX.
@


1.6
log
@исправлен способ выдачи рекомендации.
@
text
@/*
 * $Log:        sub2.c,v $
 * Revision 1.5  88/10/21  19:19:07  abs
 * выдать полезную рекомендацию при обломе.
 *
 * Revision 1.4  88/10/21  18:48:47  abs
 * чуть расширена полезная диагностика на случай облома.
 *
 * Revision 1.3  87/03/22  21:06:55  avg
 * Неправильно обрабатывались русские буквы
 * в строках (тип RSTR).
 *
 * Revision 1.2  86/12/28  20:30:24  avg
 * Версия для ДЕМОС 2.0
 *
 */
/*NOXSTR*/
#ifndef lint
static char rcsid[] = "$Header: sub2.c,v 1.5 88/10/21 19:19:07 abs Exp $";
#endif
/*YESXSTR*/

#include <ediag.h>
#include "ldefs.h"

cfoll( v )
int      v;
{
	register int     i;
	register int     j;
	register int     k;
		 char   *p;

	i = name[v];
	if( i < NCH ){
		i = 1;      /* character */
	}
	switch( i ){
	  case 1:
	  case RSTR:
	  case RCCL:
	  case RNCCL:
	  case RNULLS:
			for( j = 0; j < tptr; j++ ){
				tmpstat[j] = FALSE;
			}
			count = 0;
			follow( v );
#ifdef PP
			padd( foll, v );           /* packing version */
#else
			add( foll, v );            /* no packing version */
#endif PP
			if( i == RSTR ){
				cfoll( left[v] );
			}else if( i == RCCL || i == RNCCL ){       /* compress ccl list */
				for( j = 1; j < NCH; j++ )
					symbol[C(j)] = ( i == RNCCL );
				p = left[v];
				while( *p )
					symbol[C(*p++)] = ( i == RCCL );
				p = pcptr;
				for( j = 1; j < NCH; j++ )
					if( symbol[C(j)] ){
						for( k = 0; p + k < pcptr; k++ )
							if( cindex[C(j)] == *( p + k ) )
								break;
						if( p + k >= pcptr )
							*pcptr++ = cindex[C(j)];
					}
				*pcptr++ = 0;
				if( pcptr > pchar + pchlen )
					error( "Too many packed char classes (%%k)",
					       "Слишком много упакованных классов символов (%%k)" );
				left[v] = p;
				name[v] = RCCL; /* RNCCL eliminated */
#ifdef DEBUG
				if( debug && *p ){
					printf( "ccl %d: %d", v, *p++ );
					while( *p )
						printf( ", %d", *p++ );
					putchar( '\n' );
				}
#endif
			}
			break;
	  case CARAT:
			cfoll( left[v] );
			break;
	  case STAR:
	  case PLUS:
	  case QUEST:
	  case RSCON:
			cfoll( left[v] );
			break;
	  case BAR:
	  case RCAT:
	  case DIV:
	  case RNEWE:
			cfoll( left[v] );
			cfoll( right[v] );
			break;
#ifdef DEBUG
	  case FINAL:
	  case S1FINAL:
	  case S2FINAL:
			break;
	  default:
			warning( "bad switch cfoll %d","плохой switch cfoll %d", v );
#endif
	}
	return;
}

#ifdef DEBUG
pfoll()
{
	register int     i;
	register int     k;
	register int    *p;
		 int     j;

	/* print sets of chars which may follow positions */
	printf( "pos\tchars\n" );
	for( i = 0; i < tptr; i++ )
		if( p = foll[i] ){
			j = *p++;
			if( j >= 1 ){
				printf( "%d:\t%d", i, *p++ );
				for( k = 2; k <= j; k++ )
					printf( ", %d", *p++ );
				putchar( '\n' );
			}
		}
	return;
}
#endif DEBUG

add( array, n )
int    **array;
int      n;
{
	register int     i;
	register int    *temp;
	register char   *ctemp;

	temp = nxtpos;
	ctemp = tmpstat;
	array[n] = nxtpos;              /* note no packing is done in positions */
	*temp++ = count;
	for( i = 0; i < tptr; i++ )
		if( ctemp[i] == TRUE )
			*temp++ = i;
	nxtpos = temp;
	if( nxtpos >= positions + maxpos )
		error( "Too many positions (%%p)", "Слишком много позиций (%%p)" );
	return;
}

follow( v )
int      v;
{
	register int     p;

	if( v >= tptr-1 )
		return;
	p = parent[v];
	if( p == 0 )
		return;
	switch( name[p] ){
			/* will not be CHAR RNULLS FINAL S1FINAL S2FINAL RCCL RNCCL */
	  case RSTR:
			if( tmpstat[p] == FALSE ){
				count++;
				tmpstat[p] = TRUE;
			}
			break;
	  case STAR:
	  case PLUS:
			first( v );
			follow( p );
			break;
	  case BAR:
	  case QUEST:
	  case RNEWE:
			follow( p );
			break;
	  case RCAT:
	  case DIV:
			if( v == left[p] ){
				if( nullstr[right[p]] )
					follow( p );
				first( right[p] );
			}else
				follow( p );
			break;
	  case RSCON:
	  case CARAT:
			follow( p );
			break;
#ifdef DEBUG
	  default:
			warning( "bad switch follow %d", "плохой switch follow %d", p );
#endif DEBUG
	}
	return;
}

first( v )        /* calculate set of positions with v as root which can be active initially */
int      v;
{
	register int     i;
	register char   *p;

	i = name[v];
	if( i < NCH )
		i = 1;
	switch( i ){
	  case 1:
	  case RCCL:
	  case RNCCL:
	  case RNULLS:
	  case FINAL:
	  case S1FINAL:
	  case S2FINAL:
			if( tmpstat[v] == FALSE ){
				count++;
				tmpstat[v] = TRUE;
			}
			break;
	  case BAR:
	  case RNEWE:
			first( left[v] );
			first( right[v] );
			break;
	  case CARAT:
			if( stnum % 2 == 1 )
				first( left[v] );
			break;
	  case RSCON:
			i = stnum/2 +1;
			p = right[v];
			while( *p )
				if( *p++ == i ){
					first( left[v] );
					break;
				}
			break;
	  case STAR:
	  case QUEST:
	  case PLUS:
	  case RSTR:
			first( left[v] );
			break;
	  case RCAT:
	  case DIV:
			first( left[v] );
			if( nullstr[left[v]] )
				first( right[v] );
			break;
#ifdef DEBUG
	  default:
			warning( "bad switch first %d", "плохой switch first %d", v );
#endif DEBUG
	}
	return;
}

cgoto()
{
	register int     i;
	register int     j;
	register int     s;
		 int     npos;
		 int     curpos;
		 int     n;
		 int     tryit;
		 char    tch[NCH];
		 int     tst[NCH];
		 char   *q;

	/* generate initial state, for each start condition */
	fprintf( fout, "int yyvstop[] ={\n0,\n" );
	while( stnum < 2 || stnum/2 < sptr ){
		for( i = 0; i < tptr; i++ )
			tmpstat[i] = 0;
		count = 0;
		if( tptr > 0 )
			first( tptr - 1 );
		add( state, stnum );
#ifdef DEBUG
		if( debug ){
			if( stnum > 1 )
				printf( "%s:\n", sname[stnum/2] );
			pstate( stnum );
		}
#endif DEBUG
		stnum++;
	}
	stnum--;
	/* even stnum = might not be at line begin */
	/* odd stnum  = must be at line begin */
	/* even states can occur anywhere, odd states only at line begin */
	for( s = 0; s <= stnum; s++ ){
		tryit = FALSE;
		cpackflg[s] = FALSE;
		sfall[s] = -1;
		acompute( s );
		for( i = 0; i < NCH; i++ )
			symbol[C(i)] = 0;
		npos = *state[s];
		for( i = 1; i <= npos; i++ ){
			curpos = *( state[s] + i );
			if( name[curpos] < NCH ){
				symbol[C(name[curpos])] = TRUE;
			}else{
				switch( name[curpos] ){
				  case RCCL:
						tryit = TRUE;
						q = left[curpos];
						while( *q ){
							for( j = 1; j < NCH; j++ )
								if( cindex[C(j)] == *q )
									symbol[C(j)] = TRUE;
							q++;
						}
						break;
				  case RSTR:
						symbol[C(right[curpos])] = TRUE;
						break;
#ifdef DEBUG
				  case RNULLS:
				  case FINAL:
				  case S1FINAL:
				  case S2FINAL:
						break;
				  default:
						warning( "bad switch cgoto %d state %d", "плохой switch cgoto %d состояние %d", curpos, s );
						break;
#endif DEBUG
				}
			}
		}
#ifdef DEBUG
		if( debug ){
			printf( ediag("State %d jumps to:\n\t",
				      "Состояние %d переходы на :\n\t"), s );
			charc = 0;
			for( i = 1; i < NCH; i++ ){
				if( symbol[C(i)] )
					allprint( i );
				if( charc > LINESIZE ){
					charc = 0;
					printf( "\n\t" );
				}
			}
			putchar( '\n' );
		}
#endif DEBUG
		/* for each char, calculate next state */
		n = 0;
		for( i = 1; i < NCH; i++ ){
			if( symbol[C(i)] ){
				nextstate( s, i );         /* executed for each state, transition pair */
				xstate = notin( stnum );
				if( xstate == -2 )
					warning( "bad state %d %o", "плохое состояние %d %o", s, i );
				else if( xstate == -1 ){
					if( stnum >= nstates )
						error( "Too many states (%%n)",
						       "Слишком много состояний (%%n)" );
					add( state, ++stnum );
#ifdef DEBUG
					if( debug )
						pstate( stnum );
#endif DEBUG
					tch[C(n)] = i;
					tst[C(n++)] = stnum;
				}else{          /* xstate >= 0 ==> state exists */
					tch[C(n)] = i;
					tst[C(n++)] = xstate;
				}
			}
		}
		tch[C(n)] = 0;
		tst[C(n)] = -1;
		/* pack transitions into permanent array */
		if( n > 0 )
			packtrans( s, tch, tst, n, tryit );
		else
			gotof[s] = -1;
	}
	fprintf( fout, "0};\n" );
	return;
}
	/*      Beware -- 70% of total CPU time is spent in this subroutine -
		if you don't believe me - try it yourself ! */
nextstate( s, c )
int      s;
int      c;
{
	register int     j;
	register int    *newpos;
	register char   *temp;
	register char   *tz;
		 int    *pos;
		 int     i;
		 int    *f;
		 int     num;
		 int     curpos;
		 int     number;

	c = C(c);

	/* state to goto from state s on char c */
	num = *state[s];
	temp = tmpstat;
	pos = state[s] + 1;
	for( i = 0; i < num; i++ ){
		curpos = *pos++;
		j = name[curpos];
#ifdef DEBUG
		if( debug )
			printf( "nextstate: i=%d j=%o c=%o curpos=%d\n", i, j, c, curpos );
#endif
		if( j  < NCH  && j == c ||
		    j == RSTR && c == right[curpos] ||
		    j == RCCL && member( c, left[curpos] ) ){
#ifdef DEBUG
			if( debug )
				printf( "OK\n" );
#endif
			f = foll[curpos];
			number = *f;
			newpos = f+1;
			for( j = 0; j < number; j++ )
				temp[*newpos++] = 2;
		}
	}
	j = 0;
	tz = temp + tptr;
	while( temp < tz ){
		if( *temp == 2 ){
			j++;
			*temp++ = 1;
		}else
			*temp++ = 0;
	}
	count = j;
	return;
}

notin( n )    /* see if tmpstat occurs previously */
int      n;
{
	register int    *j;
	register int     k;
	register char   *temp;
		 int     i;

	if( count == 0 )
		return( -2 );
	temp = tmpstat;
	for( i = n; i >= 0; i-- ){      /* for each state */
		j = state[i];
		if( count == *j++ ){
			for( k = 0; k < count; k++ )
				if( !temp[*j++] )
					break;
			if( k >= count )
				return( i );
		}
	}
	return( -1 );
}

packtrans( st, tch, tst, cnt, tryit )
int      st;
char     tch[NCH];
int      tst[NCH];
int      cnt;
int      tryit;
{
	/* pack transitions into nchar, nexts */
	/* nchar is terminated by '\0', nexts uses cnt, followed by elements */
	/* gotof[st] = index into nchr, nexts for state st */

	/* sfall[st] =  t implies t is fall back state for st */
	/*              == -1 implies no fall back */

	int cmin, cval, tcnt, diff, p, *ast;
	register int i,j,k;
	char *ach;
	int go[NCH], temp[NCH], c;
	int swork[NCH];
	char cwork[NCH];
	int upper;

	rcount =+ cnt;
	cmin = -1;
	cval = NCH;
	ast = tst;
	ach = tch;
	/* try to pack transitions using ccl's */
	if( !optim )
		goto nopack;          /* skip all compaction */
	if( tryit ){      /* ccl's used */
		for( i = 1; i < NCH; i++ ){
			go[C(i)] = temp[C(i)] = -1;
			symbol[C(i)] = 1;
		}
		for( i = 0; i < cnt; i++ ){
			go[C(tch[C(i)])] = tst[C(i)];
			symbol[C(tch[C(i)])] = 0;
		}
		for( i = 0; i < cnt; i++ ){
			c = U(match[C(tch[C(i)])]);
			if( go[C(c)] != tst[C(i)] || c == U(tch[C(i)]) )
				temp[C(tch[C(i)])] = tst[C(i)];
		}
		/* fill in error entries */
		for( i = 1; i < NCH; i++ )
			if( symbol[C(i)] )
				temp[C(i)] = -2;     /* error trans */
		/* count them */
		k = 0;
		for( i = 1; i < NCH; i++ )
			if( temp[C(i)] != -1 )
				k++;
		if( k < cnt ){     /* compress by char */
#ifdef DEBUG
			if( debug )
				printf( ediag( "used compression %d,  %d vs %d\n",
					       "исп. сжатие  %d,  %d vs %d\n"), st, k, cnt );
#endif DEBUG
			k = 0;
			for( i = 1; i < NCH; i++ )
				if( temp[C(i)] != -1 ){
					cwork[C(k)] = i;
					swork[C(k++)] = ( temp[C(i)] == -2 ? -1 : temp[C(i)] );
				}
			cwork[C(k)] = 0;
#ifdef PC
			ach = cwork;
			ast = swork;
			cnt = k;
			cpackflg[st] = TRUE;
#endif PC
		}
	}
	for( i = 0; i < st; i++ ){    /* get most similar state */
				/* reject state with more transitions, state already represented by a third state,
					and state which is compressed by char if ours is not to be */
		/* if( sfall[i] != -1 ) continue;
		   if( cpackflg[st] == 1 ) if( !( cpackflg[i] == 1 ) ) continue; */
		if( sfall[i] != -1 || ( cpackflg[st] == 1 && cpackflg[i] != 1 ) ){
			continue;
		}
		p = gotof[i];
		if( p == -1 ) /* no transitions */
			continue;
		tcnt = nexts[p];
		if( tcnt > cnt )
			continue;
		diff = 0;
		k = 0;
		j = 0;
		upper = p + tcnt;
		while( ach[C(j)] && p < upper ){
			while( U(ach[C(j)]) < U(nchar[p]) && ach[C(j)] ){
				diff++;
				j++;
			}
			if( ach[C(j)] == 0 )
				break;
			if( U(ach[C(j)]) > U(nchar[p]) ){
				diff = NCH;
				break;
			}
			/* ach[j] == nchar[p] */
			if( ast[C(j)] != nexts[++p] || ast[C(j)] == -1 || ( cpackflg[st] && ach[C(j)] != match[C(ach[C(j)])] ) )
				diff++;
			j++;
		}
		while( ach[C(j)] ){
			diff++;
			j++;
		}
		if( p < upper )
			diff = NCH;
		if( diff < cval && diff < tcnt ){
			cval = diff;
			cmin = i;
			if( cval == 0 )
				break;
		}
	}
	/* cmin = state "most like" state st */
#ifdef DEBUG
	if( debug )
		printf( ediag( "case st %d for st %d diff %d\n",
			       "выбор st %d для st %d разл %d\n"), cmin, st, cval );
#endif DEBUG
#ifdef PS
	if( cmin != -1 ){ /* if we can use st cmin */
		gotof[st] = nptr;
		k = 0;
		sfall[st] = cmin;
		p = gotof[cmin]+1;
		j = 0;
		while( ach[C(j)] ){
			/* if cmin has a transition on c, then so will st */
			/* st may be "larger" than cmin, however */
			while( U(ach[C(j)]) < U(nchar[p-1]) && ach[C(j)] ){
				k++;
				nchar[nptr] = ach[C(j)];
				nexts[++nptr] = ast[C(j)];
				j++;
			}
			if( nchar[p-1] == 0 )
				break;
			if( U(ach[C(j)]) > U(nchar[p-1]) ){
				warning( "bad jump %d %d", "плохой переход %d %d", st, cmin );
				goto nopack;
			}
			/* ach[j] == nchar[p-1] */
			if( ast[C(j)] != nexts[p] || ast[C(j)] == -1 || ( cpackflg[st] && ach[C(j)] != match[C(ach[C(j)])] ) ){
				k++;
				nchar[nptr] = ach[C(j)];
				nexts[++nptr] = ast[C(j)];
			}
			p++;
			j++;
		}
		while( ach[C(j)] ){
			nchar[nptr] = ach[C(j)];
			nexts[++nptr] = ast[C(j++)];
			k++;
		}
		nexts[gotof[st]] = cnt = k;
		nchar[nptr++] = 0;
	}else{
#endif PS
nopack:
	/* stick it in */
		gotof[st] = nptr;
		nexts[nptr] = cnt;
		for( i = 0; i < cnt; i++ ){
			nchar[nptr] = ach[C(i)];
			nexts[++nptr] = ast[C(i)];
		}
		nchar[nptr++] = 0;
#ifdef PS
	}
#endif PS
	if( cnt < 1 ){
		gotof[st] = -1;
		nptr--;
	}else
		if( nptr > ntrans )
			error( "Too many jumps (%%a)",
			       "Слишком много переходов (%%a)" );
	return;
}

#ifdef DEBUG
pstate( s )
int      s;
{
	register int    *p;
	register int     i;
	register int     j;

	printf( ediag( "State %d:\n","Состояние %d:\n"), s );
	p = state[s];
	i = *p++;
	if( i == 0 )
		return;
	printf( "%4d", *p++ );
	for( j = 1; j < i; j++ ){
		printf( ", %4d", *p++ );
		if( j%30 == 0 )
			putchar( '\n' );
	}
	putchar( '\n' );
	return;
}
#endif DEBUG

member( d, t )
int      d;
char    *t;
{
	register int     c;
	register char   *s;

	c = d;
	s = t;
	c = U(cindex[C(c)]);
	while( *s )
		if( *s++ == c )
			return( 1 );
	return( 0 );
}

#ifdef DEBUG
stprt( i )
int      i;
{
	register int     p;
	register int     t;

	printf( ediag("State %d:","Состояние %d:"), i );
	/* print actions, if any */
	t = atable[i];
	if( t != -1 )
		printf( ediag(" end"," конец") );
	putchar( '\n' );
	if( cpackflg[i] == TRUE )
		printf( ediag("back char\n",
			      "используется возврат на символ\n") );
	if( sfall[i] != -1 )
		printf( ediag("can't back state %d\n",
			      "нельзя вернуть состояние %d\n"), sfall[i] );
	p = gotof[i];
	if( p == -1 )
		return;
	printf( ediag("(%d jumps)\n", "(%d переходов)\n"), nexts[p] );
	while( nchar[p] ){
		charc = 0;
		if( nexts[p+1] >= 0 )
			printf( "%d\t", nexts[p+1] );
		else
			printf( "err\t" );
		allprint( nchar[p++] );
		while( nexts[p] == nexts[p+1] && nchar[p] ){
			if( charc > LINESIZE ){
				charc = 0;
				printf( "\n\t" );
			}
			allprint( nchar[p++] );
		}
		putchar( '\n' );
	}
	putchar( '\n' );
	return;
}
#endif DEBUG

acompute( s )     /* compute action list = set of poss. actions */
int      s;
{
	register int    *p;
	register int     i;
	register int     j;
		 int     cnt;
		 int     m;
		 int     temp[300];
		 int     k;
		 int     neg[300];
		 int     n;

	k = 0;
	n = 0;
	p = state[s];
	cnt = *p++;
	if( cnt > 300 )
		error( "Too many positions for  one state",
		       "Слишком много позиций для одного состояния" );
	for( i = 0; i < cnt; i++ ){
		if( name[*p] == FINAL )
			temp[k++] = left[*p];
		else if( name[*p] == S1FINAL ){
			temp[k++] = left[*p];
			if( left[*p] > NACTIONS )
				error( "Too many right contexts",
				       "Слишком много правых контекстов" );
			extra[left[*p]] = 1;
		}else if( name[*p] == S2FINAL )
			neg[n++] = left[*p];
		p++;
	}
	atable[s] = -1;
	if( k < 1 && n < 1 )
		return;
#ifdef DEBUG
	if( debug )
		printf( ediag( "end %d actions", "конец %d действий:"), s );
#endif DEBUG
	/* sort action list */
	for( i = 0; i < k; i++ )
		for( j = i + 1; j < k; j++ )
			if( temp[j] < temp[i] ){
				m = temp[j];
				temp[j] = temp[i];
				temp[i] = m;
			}
	/* remove dups */
	for( i = 0; i < k-1; i++ )
		if( temp[i] == temp[i+1] )
			temp[i] = 0;
	/* copy to permanent quarters */
	atable[s] = aptr;
#ifdef DEBUG
	fprintf( fout, ediag("/* actions for state %d */",
			     "/* действия для состояния %d */"), s );
#endif DEBUG
	putc( '\n', fout );
	for( i = 0; i < k; i++ )
		if( temp[i] != 0 ){
			fprintf( fout, "%d,\n", temp[i] );
#ifdef DEBUG
			if( debug )
				printf( "%d ", temp[i] );
#endif DEBUG
			aptr++;
		}
	for( i = 0; i < n; i++ ){               /* copy fall back actions - all neg */
		fprintf( fout, "%d,\n", neg[i] );
		aptr++;
#ifdef DEBUG
		if( debug )
			printf( "%d ", neg[i] );
#endif DEBUG
	}
#ifdef DEBUG
	if( debug )
		putchar( '\n' );
#endif DEBUG
	fprintf( fout, "0,\n" );
	aptr++;
	return;
}

#ifdef DEBUG
pccl()
{
	/* print character class sets */
	register int     i;
	register int     j;

	printf( ediag( "char classes overlap\n","пересечение классов символов\n") );
	for( i = 0; i < ccount; i++ ){
		charc = 0;
		printf( ediag( "class %d:\n\t","класс %d:\n\t"), i );
		for( j = 1; j < NCH; j++ )
			if( cindex[C(j)] == i ){
				allprint( j );
				if( charc > LINESIZE ){
					printf( "\n\t" );
					charc = 0;
				}
			}
		putchar( '\n' );
	}
	charc = 0;
	printf( ediag("found:\n", "найдено:\n") );
	for( i = 0; i < NCH; i++ ){
		allprint( match[C(i)] );
		if( charc > LINESIZE ){
			putchar( '\n' );
			charc = 0;
		}
	}
	putchar( '\n' );
	return;
}
#endif DEBUG

mkmatch()
{
	register int     i;
		 char    tab[NCH];

	for( i = 0; i < ccount; i++ )
		tab[C(i)] = 0;
	for( i = 1; i < NCH; i++ )
		if( tab[C(cindex[C(i)])] == 0 )
			tab[C(cindex[C(i)])] = i;
	/* tab[i] = principal char for new ccl i */
	for( i = 1; i < NCH; i++ )
		match[C(i)] = tab[C(cindex[C(i)])];
	return;
}

layout()
{
	/* format and output final program's tables */
	register int     i;
	register int     j;
	register int     k;
		 int     top;
		 int     bot;
		 int     startup;
		 int     omin;

	startup = 0;
	for( i = 0; i < outsize; i++ )
		verify[i] = advance[i] = 0;
	omin = 0;
	yytop = 0;
	for( i = 0; i <= stnum; i++ ){       /* for each state */
		j = gotof[i];
		if( j == -1 ){
			stoff[i] = 0;
			continue;
		}
		bot = j;
		while( nchar[j] )
			j++;
		top = j - 1;
#ifdef DEBUG
		if( debug ){
			printf( ediag( "State %d: (layout)\n","Состояние %d: (layout)\n"), i );
			for( j = bot; j <= top; j++ ){
				printf( "  %o", nchar[j] );
				if( j%10 == 0 )
					putchar( '\n' );
			}
			putchar( '\n' );
		}
#endif DEBUG
		while( verify[omin+ZCH] )
			omin++;
		startup = omin;
#ifdef DEBUG
		if( debug )
			printf( "bot,top %d, %d startup begins %d\n", bot, top, startup );
#endif DEBUG
		if( chset ){
			do{
				startup =+ 1;
				if( startup > outsize - ZCH )
					error( "%d>%d output table overflow.\nTry to increase %%O",
					       "%d>%d переполнение выходной таблицы.\nПопробуйте задать %%O побольше",
						startup, outsize-ZCH );
				for( j = bot; j <= top; j++ ){
					k = startup + ctable[U(nchar[j])];
					if( verify[k] )
						break;
				}
			}while( j <= top );
#ifdef DEBUG
			if( debug )
				printf( " startup will be %d\n", startup );
#endif DEBUG
			/* have found place */
			for( j = bot; j <= top; j++ ){
				k = startup + ctable[U(nchar[j])];
				if( ctable[U(nchar[j])] <= 0 )
					printf( "j %d nchar %d ctable.nch %d\n", j, U(nchar[j]), ctable[U(nchar[k])] );
				verify[k] = i+1;                        /* state number + 1*/
				advance[k] = nexts[j+1]+1;              /* state number + 1*/
				if( yytop < k )
					yytop = k;
			}
		}else{
			do{
				startup =+ 1;
				if( startup > outsize - ZCH )
					error( "%d>%d output table overflow.\nTry to increase %%O",
					       "%d>%d переполнение выходной таблицы.\nПопробуйте задать %%O побольше",
						startup, outsize-ZCH );
				for( j = bot; j <= top; j++ ){
					k = startup + U(nchar[j]);
					if( verify[k] )
						break;
				}
			}while( j <= top );
			/* have found place */
#ifdef DEBUG
	if( debug )
		printf( " startup going to be %d\n", startup );
#endif DEBUG
			for( j = bot; j <= top; j++ ){
				k = startup + U(nchar[j]);
				verify[k] = i+1;          /* state number + 1*/
				advance[k] = nexts[j+1]+1;/* state number + 1*/
				if( yytop < k )
					yytop = k;
			}
		}
		stoff[i] = startup;
	}

	/* stoff[i] = offset into verify, advance for trans for state i */
	/* put out yywork */
	fprintf( fout, "#define YYTYPE %s\n", stnum+1 > NCH ? "int" : "char" );
	fprintf( fout, "struct yywork { YYTYPE verify, advance; } yycrank[] ={\n" );
	for( i = 0;i <= yytop; i += 4 ){
		for( j = 0; j < 4; j++ ){
			k = i + j;
			if( verify[k] )
				fprintf( fout, "%d,%d,\t", verify[k], advance[k] );
			else
				fprintf( fout, "0,0,\t" );
		}
		putc( '\n', fout );
	}
	fprintf( fout, "0,0};\n" );

	/* put out yysvec */

	fprintf( fout, "struct yysvf yysvec[] ={\n" );
	fprintf( fout, "0,\t0,\t0,\n" );
	for( i = 0; i <= stnum; i++ ){  /* for each state */
		if( cpackflg[i] )
			stoff[i] = -stoff[i];
		fprintf( fout, "yycrank+%d,\t", stoff[i] );
		if( sfall[i] != -1 )
			fprintf( fout, "yysvec+%d,\t", sfall[i] + 1 );       /* state + 1 */
		else
			fprintf( fout, "0,\t\t" );
		if( atable[i] != -1 )
			fprintf( fout, "yyvstop+%d,", atable[i] );
		else
			fprintf( fout, "0,\t" );
#ifdef DEBUG
		fprintf( fout, "\t\t/* state %d */", i );
#endif DEBUG
		putc( '\n', fout );
	}
	fprintf( fout, "0,\t0,\t0};\n" );

	/* put out yymatch */

	fprintf( fout, "struct yywork *yytop = yycrank+%d;\n", yytop );
	fprintf( fout, "struct yysvf *yybgin = yysvec+1;\n" );
	if( optim ){
		fprintf( fout, "char yymatch[] ={\n" );
		if( chset == 0 ){ /* no chset, put out in normal order */
			for( i = 0; i < NCH; i += 8 ){
				for( j = 0; j < 8; j++ ){
					int      fbch;

					fbch = U(match[C( i + j )]);
					if( printable( fbch ) && fbch != '\'' && fbch != '\\' )
						fprintf( fout, "'%c' ,", fbch );
					else
						fprintf( fout, "0%-3o,", fbch );
				}
				putc( '\n', fout );
			}
		}else{
			int *fbarr;

			fbarr = myalloc( 2*NCH, sizeof( *fbarr ) );
			if( fbarr == 0 )
				error( "No space for inverting char table",
				       "Нет места для инвертирования таблицы символов", 0 );
			for( i = 0; i < ZCH; i++ )
				fbarr[i] = 0;
			for( i = 0; i < NCH; i++ )
				fbarr[ctable[i]] = ctable[U(match[C(i)])];
			for( i = 0; i < ZCH; i += 8 ){
				for( j = 0; j < 8; j++ )
					fprintf( fout, "0%-3o,", fbarr[i+j] );
				putc( '\n', fout );
			}
			cfree( fbarr, 2*NCH, 1 );
		}
		fprintf( fout, "0};\n" );
	}
	/* put out yyextra */
	fprintf( fout, "char yyextra[] ={\n" );
	for( i = 0; i < casecount; i += 8 ){
		for( j = 0; j < 8; j++ )
			fprintf( fout, "%d,", i+j<NACTIONS ?
				extra[i+j] : 0 );
		putc( '\n', fout );
	}
	fprintf( fout, "0};\n" );
	return;
}

shiftr( a, n )
int     *a;
int      n;
{
	int      i;

	for( i = n; i >= 0; i-- )
		a[i+1] = a[i];
}

upone( a, n )
int     *a;
int      n;
{
	int      i;

	for( i = 0; i <= n ; i++ )
		a[i]++;
}

#ifdef PP
padd( array, n )
int    **array;
int      n;
{
	register int     i;
	register int    *j;
	register int     k;

	array[n] = nxtpos;
	if( count == 0 ){
		*nxtpos++ = 0;
		return;
	}
	for( i = tptr - 1; i >= 0; i-- ){
		j = array[i];
		if( j && *j++ == count ){
			for( k = 0; k < count; k++ )
				if( !tmpstat[*j++] )
					break;
			if( k >= count ){
				array[n] = array[i];
				return;
			}
		}
	}
	add( array, n );
	return;
}
#endif PP
@


1.5
log
@выдать полезную рекомендацию при обломе.
@
text
@d3 3
d19 1
a19 1
static char rcsid[] = "$Header: sub2.c,v 1.4 88/10/21 18:48:47 abs Exp $";
d933 4
a936 7
				if( startup > outsize - ZCH ){
					error( "%d>%d output table overflow",
					       "%d>%d переполнение выходной таблицы",
						startup, outsize-ZCH, ZCH );
					error( "try to increase %%O",
					   "попробуйте задать %%O побольше");
				}
d960 4
a963 7
				if( startup > outsize - ZCH ){
					error( "%d>%d output table overflow",
					       "%d>%d переполнение выходной таблицы",
					       startup, outsize-ZCH  );
					error( "try to increase %%O",
					   "попробуйте задать %%O побольше");
				}
@


1.4
log
@чуть расширена полезная диагностика на случай облома.
@
text
@d3 3
d16 1
a16 1
static char rcsid[] = "$Header: sub2.c,v 1.3 87/03/22 21:06:55 avg Exp $";
d930 1
a930 1
				if( startup > outsize - ZCH )
d933 4
a936 1
						startup, outsize-ZCH );
d960 1
a960 1
				if( startup > outsize - ZCH )
d964 3
@


1.3
log
@Неправильно обрабатывались русские буквы
в строках (тип RSTR).
@
text
@d3 4
d13 1
a13 1
static char rcsid[] = "$Header: sub2.c,v 1.2 86/12/28 20:30:24 avg Exp $";
d928 3
a930 2
					error( "output table overflow",
					       "переполнение выходной таблицы" );
d955 3
a957 2
					error( "output table overflow",
					       "переполнение выходной таблицы" );
@


1.2
log
@Версия для ДЕМОС 2.0
@
text
@d2 4
a5 1
 * $Log$
d9 1
a9 1
static char rcsid[] = "$Header$";
d403 2
d412 4
d419 4
d711 1
a711 1
			      "используется возврат на символ\n"9 );
@


1.1
log
@Версия из МНОС РЛ 1.2
@
text
@d2 1
a2 5
 * МНОС РЛ 1.2
 * lex - построитель лексических анализаторов
 *	Версия для СМ-4 и т.п. - Антонов В.Г.
 *				( ИПК Минавтопрома, ВМК МГУ )
 * Последнее изменение: 03.09.85
d4 5
@


1.0
log
@Initial revision
@
text
@d1 19
a19 6
# include "ldefs.c"
cfoll(v)
	int v;
	{
	register int i,j,k;
	char *p;
d21 10
a30 4
	if(i < NCH) i = 1;	/* character */
	switch(i){
		case 1: case RSTR: case RCCL: case RNCCL: case RNULLS:
			for(j=0;j<tptr;j++)
d32 1
d34 11
a44 11
			follow(v);
# ifdef PP
			padd(foll,v);		/* packing version */
# endif
# ifndef PP
			add(foll,v);		/* no packing version */
# endif
			if(i == RSTR) cfoll(left[v]);
			else if(i == RCCL || i == RNCCL){	/* compress ccl list */
				for(j=1; j<NCH;j++)
					symbol[j] = (i==RNCCL);
d46 2
a47 2
				while(*p)
					symbol[*p++] = (i == RCCL);
d49 4
a52 4
				for(j=1;j<NCH;j++)
					if(symbol[j]){
						for(k=0;p+k < pcptr; k++)
							if(cindex[j] == *(p+k))
d54 3
a56 2
						if(p+k >= pcptr)*pcptr++ = cindex[j];
						}
d58 3
a60 2
				if(pcptr > pchar + pchlen)
					error("Too many packed character classes");
d62 7
a68 9
				name[v] = RCCL;	/* RNCCL eliminated */
# ifdef DEBUG
				if(debug && *p){
					printf("ccl %d: %d",v,*p++);
					while(*p)
						printf(", %d",*p++);
					putchar('\n');
					}
# endif
d70 2
d73 2
a74 2
		case CARAT:
			cfoll(left[v]);
d76 5
a80 2
		case STAR: case PLUS: case QUEST: case RSCON: 
			cfoll(left[v]);
d82 6
a87 3
		case BAR: case RCAT: case DIV: case RNEWE:
			cfoll(left[v]);
			cfoll(right[v]);
d89 4
a92 4
# ifdef DEBUG
		case FINAL:
		case S1FINAL:
		case S2FINAL:
d94 4
a97 4
		default:
			warning("bad switch cfoll %d",v);
# endif
		}
d99 3
a101 2
	}
# ifdef DEBUG
d103 6
a108 3
	{
	register int i,k,*p;
	int j;
d110 3
a112 3
	printf("pos\tchars\n");
	for(i=0;i<tptr;i++)
		if(p=foll[i]){
d114 5
a118 6
			if(j >= 1){
				printf("%d:\t%d",i,*p++);
				for(k=2;k<=j;k++)
					printf(", %d",*p++);
				putchar('\n');
				}
d120 1
d122 11
a132 7
	}
# endif
add(array,n)
  int **array;
  int n; {
	register int i, *temp;
	register char *ctemp;
d135 1
a135 1
	array[n] = nxtpos;		/* note no packing is done in positions */
d137 2
a138 2
	for(i=0;i<tptr;i++)
		if(ctemp[i] == TRUE)
d141 2
a142 2
	if(nxtpos >= positions+maxpos)
		error("Too many positions %s",(maxpos== MAXPOS?"\nTry using %p num":""));
d144 9
a152 6
	}
follow(v)
  int v;
	{
	register int p;
	if(v >= tptr-1)return;
d154 3
a156 2
	if(p == 0) return;
	switch(name[p]){
d158 2
a159 2
		case RSTR:
			if(tmpstat[p] == FALSE){
d162 1
a162 1
				}
d164 4
a167 3
		case STAR: case PLUS:
			first(v);
			follow(p);
d169 4
a172 2
		case BAR: case QUEST: case RNEWE:
			follow(p);
d174 8
a181 7
		case RCAT: case DIV: 
			if(v == left[p]){
				if(nullstr[right[p]])
					follow(p);
				first(right[p]);
				}
			else follow(p);
d183 3
a185 2
		case RSCON: case CARAT: 
			follow(p);
d187 5
a191 5
# ifdef DEBUG
		default:
			warning("bad switch follow %d",p);
# endif
		}
d193 8
a200 5
	}
first(v)	/* calculate set of positions with v as root which can be active initially */
  int v; {
	register int i;
	register char *p;
d202 11
a212 4
	if(i < NCH)i = 1;
	switch(i){
		case 1: case RCCL: case RNCCL: case RNULLS: case FINAL: case S1FINAL: case S2FINAL:
			if(tmpstat[v] == FALSE){
d215 1
a215 1
				}
d217 4
a220 3
		case BAR: case RNEWE:
			first(left[v]);
			first(right[v]);
d222 3
a224 3
		case CARAT:
			if(stnum % 2 == 1)
				first(left[v]);
d226 1
a226 1
		case RSCON:
d229 3
a231 3
			while(*p)
				if(*p++ == i){
					first(left[v]);
d233 1
a233 1
					}
d235 5
a239 2
		case STAR: case QUEST: case PLUS:  case RSTR:
			first(left[v]);
d241 5
a245 4
		case RCAT: case DIV:
			first(left[v]);
			if(nullstr[left[v]])
				first(right[v]);
d247 5
a251 5
# ifdef DEBUG
		default:
			warning("bad switch first %d",v);
# endif
		}
d253 15
a267 8
	}
cgoto(){
	register int i, j, s;
	int npos, curpos, n;
	int tryit;
	char tch[NCH];
	int tst[NCH];
	char *q;
d269 13
a281 5
	if(ratfor){
		fprintf(fout,"blockdata\n");
		fprintf(fout,"common /Lvstop/ vstop\n");
		fprintf(fout,"define Svstop %d\n",nstates+1);
		fprintf(fout,"integer vstop(Svstop)\n");
d283 1
a283 13
	else fprintf(fout,"int yyvstop[] ={\n0,\n");
	while(stnum < 2 || stnum/2 < sptr){
		for(i = 0; i<tptr; i++) tmpstat[i] = 0;
		count = 0;
		if(tptr > 0)first(tptr-1);
		add(state,stnum);
# ifdef DEBUG
		if(debug){
			if(stnum > 1)
				printf("%s:\n",sname[stnum/2]);
			pstate(stnum);
			}
# endif
d285 1
a285 1
		}
d290 1
a290 1
	for(s = 0; s <= stnum; s++){
d294 3
a296 2
		acompute(s);
		for(i=0;i<NCH;i++) symbol[i] = 0;
d298 30
a327 27
		for(i = 1; i<=npos; i++){
			curpos = *(state[s]+i);
			if(name[curpos] < NCH) symbol[name[curpos]] = TRUE;
			else switch(name[curpos]){
			case RCCL:
				tryit = TRUE;
				q = left[curpos];
				while(*q){
					for(j=1;j<NCH;j++)
						if(cindex[j] == *q)
							symbol[j] = TRUE;
					q++;
					}
				break;
			case RSTR:
				symbol[right[curpos]] = TRUE;
				break;
# ifdef DEBUG
			case RNULLS:
			case FINAL:
			case S1FINAL:
			case S2FINAL:
				break;
			default:
				warning("bad switch cgoto %d state %d",curpos,s);
				break;
# endif
d330 4
a333 3
# ifdef DEBUG
		if(debug){
			printf("State %d transitions on:\n\t",s);
d335 4
a338 3
			for(i = 1; i<NCH; i++){
				if(symbol[i]) allprint(i);
				if(charc > LINESIZE){
d340 1
a340 2
					printf("\n\t");
					}
a341 1
			putchar('\n');
d343 3
a345 1
# endif
d348 20
a367 19
		for(i = 1; i<NCH; i++){
			if(symbol[i]){
				nextstate(s,i);		/* executed for each state, transition pair */
				xstate = notin(stnum);
				if(xstate == -2) warning("bad state  %d %o",s,i);
				else if(xstate == -1){
					if(stnum >= nstates)
						error("Too many states %s",(nstates == NSTATES ? "\nTry using %n num":""));
					add(state,++stnum);
# ifdef DEBUG
					if(debug)pstate(stnum);
# endif
					tch[n] = i;
					tst[n++] = stnum;
					}
				else {		/* xstate >= 0 ==> state exists */
					tch[n] = i;
					tst[n++] = xstate;
					}
d370 3
a372 2
		tch[n] = 0;
		tst[n] = -1;
d374 6
a379 4
		if(n > 0) packtrans(s,tch,tst,n,tryit);
		else gotof[s] = -1;
		}
	ratfor ? fprintf(fout,"end\n") : fprintf(fout,"0};\n");
d381 2
a382 2
	}
	/*	Beware -- 70% of total CPU time is spent in this subroutine -
d384 15
a398 5
nextstate(s,c)
  int s,c; {
	register int j, *newpos;
	register char *temp, *tz;
	int *pos, i, *f, num, curpos, number;
d403 1
a403 1
	for(i = 0; i<num; i++){
d406 3
a408 3
		if(j < NCH && j == c
		|| j == RSTR && c == right[curpos]
		|| j == RCCL && member(c,left[curpos])){
d412 1
a412 1
			for(j=0;j<number;j++)
a413 1
			}
d415 1
d418 2
a419 2
	while(temp < tz){
		if(*temp == 2){
d422 3
a424 3
			}
		else *temp++ = 0;
		}
d427 12
a438 8
	}
notin(n)
  int n;	{	/* see if tmpstat occurs previously */
	register int *j,k;
	register char *temp;
	int i;
	if(count == 0)
		return(-2);
d440 1
a440 1
	for(i=n;i>=0;i--){	/* for each state */
d442 6
a447 6
		if(count == *j++){
			for(k=0;k<count;k++)
				if(!temp[*j++])break;
			if(k >= count)
				return(i);
			}
a448 1
	return(-1);
d450 10
a459 3
packtrans(st,tch,tst,cnt,tryit)
  int st, *tst, cnt,tryit;
  char *tch; {
d465 1
a465 1
	/*	        == -1 implies no fall back */
d481 16
a496 15
	if(!optim)goto nopack;		/* skip all compaction */
	if(tryit){	/* ccl's used */
		for(i=1;i<NCH;i++){
			go[i] = temp[i] = -1;
			symbol[i] = 1;
			}
		for(i=0;i<cnt;i++){
			go[tch[i]] = tst[i];
			symbol[tch[i]] = 0;
			}
		for(i=0; i<cnt;i++){
			c = match[tch[i]];
			if(go[c] != tst[i] || c == tch[i])
				temp[tch[i]] = tst[i];
			}
d498 3
a500 2
		for(i=1;i<NCH;i++)
			if(symbol[i]) temp[i] = -2;	/* error trans */
d503 9
a511 6
		for(i=1;i<NCH;i++)
			if(temp[i] != -1)k++;
		if(k <cnt){	/* compress by char */
# ifdef DEBUG
			if(debug) printf("use compression  %d,  %d vs %d\n",st,k,cnt);
# endif
d513 7
a519 7
			for(i=1;i<NCH;i++)
				if(temp[i] != -1){
					cwork[k] = i;
					swork[k++] = (temp[i] == -2 ? -1 : temp[i]);
					}
			cwork[k] = 0;
# ifdef PC
d524 1
a524 2
# endif
			}
d526 2
a527 1
	for(i=0; i<st; i++){	/* get most similar state */
d530 5
a534 2
		if(sfall[i] != -1) continue;
		if(cpackflg[st] == 1) if(!(cpackflg[i] == 1)) continue;
d536 2
a537 1
		if(p == -1) /* no transitions */ continue;
d539 2
a540 1
		if(tcnt > cnt) continue;
d545 11
a555 4
		while(ach[j] && p < upper){
			while(ach[j] < nchar[p] && ach[j]){diff++; j++; }
			if(ach[j] == 0)break;
			if(ach[j] > nchar[p]){diff=NCH;break;}
d557 2
a558 1
			if(ast[j] != nexts[++p] || ast[j] == -1 || (cpackflg[st] && ach[j] != match[ach[j]]))diff++;
d560 2
a561 2
			}
		while(ach[j]){
d564 4
a567 3
			}
		if(p < upper)diff = NCH;
		if(diff < cval && diff < tcnt){
d570 2
a571 2
			if(cval == 0)break;
			}
d573 1
d575 7
a581 5
# ifdef DEBUG
	if(debug)printf("select st %d for st %d diff %d\n",cmin,st,cval);
# endif
# ifdef PS
	if(cmin != -1){ /* if we can use st cmin */
d587 1
a587 1
		while(ach[j]){
d590 1
a590 1
			while(ach[j] < nchar[p-1] && ach[j]){
d592 2
a593 2
				nchar[nptr] = ach[j];
				nexts[++nptr] = ast[j];
d595 5
a599 4
				}
			if(nchar[p-1] == 0)break;
			if(ach[j] > nchar[p-1]){
				warning("bad transition %d %d",st,cmin);
d601 1
a601 1
				}
d603 1
a603 1
			if(ast[j] != nexts[p] || ast[j] == -1 || (cpackflg[st] && ach[j] != match[ach[j]])){
d605 3
a607 3
				nchar[nptr] = ach[j];
				nexts[++nptr] = ast[j];
				}
d610 4
a613 4
			}
		while(ach[j]){
			nchar[nptr] = ach[j];
			nexts[++nptr] = ast[j++];
d615 1
a615 1
			}
d618 2
a619 3
		}
	else {
# endif
d624 4
a627 4
		for(i=0;i<cnt;i++){
			nchar[nptr] = ach[i];
			nexts[++nptr] = ast[i];
			}
d629 4
a632 4
# ifdef PS
		}
# endif
	if(cnt < 1){
d635 4
a638 4
		}
	else
		if(nptr > ntrans)
			error("Too many transitions %s",(ntrans==NTRANS?"\nTry using %a num":""));
d640 11
a650 6
	}
# ifdef DEBUG
pstate(s)
  int s; {
	register int *p,i,j;
	printf("State %d:\n",s);
d653 9
a661 7
	if(i == 0) return;
	printf("%4d",*p++);
	for(j = 1; j<i; j++){
		printf(", %4d",*p++);
		if(j%30 == 0)putchar('\n');
		}
	putchar('\n');
d663 10
a672 7
	}
# endif
member(d,t)
  int d;
  char *t;	{
	register int c;
	register char *s;
d675 15
a689 10
	c = cindex[c];
	while(*s)
		if(*s++ == c) return(1);
	return(0);
	}
# ifdef DEBUG
stprt(i)
  int i; {
	register int p, t;
	printf("State %d:",i);
d692 9
a700 4
	if(t != -1)printf(" final");
	putchar('\n');
	if(cpackflg[i] == TRUE)printf("backup char in use\n");
	if(sfall[i] != -1)printf("fall back state %d\n",sfall[i]);
d702 4
a705 3
	if(p == -1) return;
	printf("(%d transitions)\n",nexts[p]);
	while(nchar[p]){
d707 7
a713 6
		if(nexts[p+1] >= 0)
			printf("%d\t",nexts[p+1]);
		else printf("err\t");
		allprint(nchar[p++]);
		while(nexts[p] == nexts[p+1] && nchar[p]){
			if(charc > LINESIZE){
d715 1
a715 3
				printf("\n\t");
				}
			allprint(nchar[p++]);
d717 1
a717 1
		putchar('\n');
d719 3
a721 1
	putchar('\n');
d723 16
a738 7
	}
# endif
acompute(s)	/* compute action list = set of poss. actions */
  int s; {
	register int *p, i, j;
	int cnt, m;
	int temp[300], k, neg[300], n;
d743 11
a753 6
	if(cnt > 300)
		error("Too many positions for one state - acompute");
	for(i=0;i<cnt;i++){
		if(name[*p] == FINAL)temp[k++] = left[*p];
		else if(name[*p] == S1FINAL){temp[k++] = left[*p];
			if (left[*p] >NACTIONS) error("Too many right contexts");
d755 2
a756 2
			}
		else if(name[*p] == S2FINAL)neg[n++] = left[*p];
d758 1
a758 1
		}
d760 6
a765 4
	if(k < 1 && n < 1) return;
# ifdef DEBUG
	if(debug) printf("final %d actions:",s);
# endif
d767 3
a769 3
	for(i=0; i<k; i++)
		for(j=i+1;j<k;j++)
			if(temp[j] < temp[i]){
d773 1
a773 1
				}
d775 3
a777 2
	for(i=0;i<k-1;i++)
		if(temp[i] == temp[i+1]) temp[i] = 0;
d780 12
a791 11
# ifdef DEBUG
	if(!ratfor)fprintf(fout,"/* actions for state %d */",s);
# endif
	putc('\n',fout);
	for(i=0;i<k;i++)
		if(temp[i] != 0){
			ratfor ? fprintf(fout,"data vstop(%d)/%d/\n",aptr,temp[i]) : fprintf(fout,"%d,\n",temp[i]);
# ifdef DEBUG
			if(debug)
				printf("%d ",temp[i]);
# endif
d793 3
a795 3
			}
	for(i=0;i<n;i++){		/* copy fall back actions - all neg */
		ratfor ? fprintf(fout,"data vstop(%d)/%d/\n",aptr,neg[i]) : fprintf(fout,"%d,\n",neg[i]);
d797 10
a806 8
# ifdef DEBUG
		if(debug)printf("%d ",neg[i]);
# endif
		}
# ifdef DEBUG
	if(debug)putchar('\n');
# endif
	ratfor ? fprintf(fout,"data vstop (%d)/0/\n",aptr) : fprintf(fout,"0,\n");
d809 5
a813 3
	}
# ifdef DEBUG
pccl() {
d815 5
a819 3
	register int i, j;
	printf("char class intersection\n");
	for(i=0; i< ccount; i++){
d821 6
a826 6
		printf("class %d:\n\t",i);
		for(j=1;j<NCH;j++)
			if(cindex[j] == i){
				allprint(j);
				if(charc > LINESIZE){
					printf("\n\t");
a827 1
					}
d829 3
a831 2
		putchar('\n');
		}
d833 5
a837 5
	printf("match:\n");
	for(i=0;i<NCH;i++){
		allprint(match[i]);
		if(charc > LINESIZE){
			putchar('\n');
a838 1
			}
d840 2
a841 1
	putchar('\n');
d843 13
a855 10
	}
# endif
mkmatch(){
	register int i;
	char tab[NCH];
	for(i=0; i<ccount; i++)
		tab[i] = 0;
	for(i=1;i<NCH;i++)
		if(tab[cindex[i]] == 0)
			tab[cindex[i]] = i;
d857 2
a858 2
	for(i = 1; i<NCH; i++)
		match[i] = tab[cindex[i]];
d860 4
a863 2
	}
layout(){
d865 8
a872 2
	register int i, j, k;
	int  top, bot, startup, omin;
d874 1
a874 1
	for(i=0; i<outsize;i++)
d878 1
a878 1
	for(i=0; i<= stnum; i++){	/* for each state */
d880 1
a880 1
		if(j == -1){
d883 1
a883 1
			}
d885 2
a886 1
		while(nchar[j])j++;
d888 7
a894 10
# if DEBUG
		if (debug)
			{
			printf("State %d: (layout)\n", i);
			for(j=bot; j<=top;j++)
				{
				printf("  %o", nchar[j]);
				if (j%10==0) putchar('\n');
				}
			putchar('\n');
d896 5
a900 2
# endif
		while(verify[omin+ZCH]) omin++;
d902 6
a907 5
# if DEBUG
		if (debug) printf("bot,top %d, %d startup begins %d\n",bot,top,startup);
# endif
		if(chset){
			do {
d909 13
a921 10
				if(startup > outsize - ZCH)
					error("output table overflow");
				for(j = bot; j<= top; j++){
					k=startup+ctable[nchar[j]];
					if(verify[k])break;
					}
				} while (j <= top);
# if DEBUG
			if (debug) printf(" startup will be %d\n",startup);
# endif
d923 8
a930 8
			for(j = bot; j<= top; j++){
				k = startup + ctable[nchar[j]];
				if (ctable[nchar[j]]<=0)
				 printf("j %d nchar %d ctable.nch %d\n",j,nchar[j],ctable[nchar[k]]);
				verify[k] = i+1;			/* state number + 1*/
				advance[k] = nexts[j+1]+1;		/* state number + 1*/
				if(yytop < k) yytop = k;
				}
d932 2
a933 2
		else {
			do {
d935 9
a943 7
				if(startup > outsize - ZCH)
					error("output table overflow");
				for(j = bot; j<= top; j++){
					k = startup + nchar[j];
					if(verify[k])break;
					}
				} while (j <= top);
d945 10
a954 9
# if DEBUG
	if (debug) printf(" startup going to be %d\n", startup);
# endif
			for(j = bot; j<= top; j++){
				k = startup + nchar[j];
				verify[k] = i+1;			/* state number + 1*/
				advance[k] = nexts[j+1]+1;		/* state number + 1*/
				if(yytop < k) yytop = k;
				}
d956 1
d958 1
a958 1
		}
d962 7
a968 21
	if(ratfor){
		fprintf(fout, "define YYTOPVAL %d\n", yytop);
		rprint(verify,"verif",yytop+1);
		rprint(advance,"advan",yytop+1);
 		shiftr(stoff, stnum); 
		rprint(stoff,"stoff",stnum+1);
 		shiftr(sfall, stnum); upone(sfall, stnum+1);
		rprint(sfall,"sfall",stnum+1);
		bprint(extra,"extra",casecount+1);
		bprint(match,"match",NCH);
 		shiftr(atable, stnum);
		rprint(atable,"atable",stnum+1);
		return;
		}
	fprintf(fout,"# define YYTYPE %s\n",stnum+1 > NCH ? "int" : "char");
	fprintf(fout,"struct yywork { YYTYPE verify, advance; } yycrank[] ={\n");
	for(i=0;i<=yytop;i=+4){
		for(j=0;j<4;j++){
			k = i+j;
			if(verify[k])
				fprintf(fout,"%d,%d,\t",verify[k],advance[k]);
d970 1
a970 3
				fprintf(fout,"0,0,\t");
			}
		putc('\n',fout);
d972 3
a974 1
	fprintf(fout,"0,0};\n");
d978 20
a997 17
	fprintf(fout,"struct yysvf yysvec[] ={\n");
	fprintf(fout,"0,\t0,\t0,\n");
	for(i=0;i<=stnum;i++){	/* for each state */
		if(cpackflg[i])stoff[i] = -stoff[i];
		fprintf(fout,"yycrank+%d,\t",stoff[i]);
		if(sfall[i] != -1)
			fprintf(fout,"yysvec+%d,\t", sfall[i]+1);	/* state + 1 */
		else fprintf(fout,"0,\t\t");
		if(atable[i] != -1)
			fprintf(fout,"yyvstop+%d,",atable[i]);
		else fprintf(fout,"0,\t");
# ifdef DEBUG
		fprintf(fout,"\t\t/* state %d */",i);
# endif
		putc('\n',fout);
		}
	fprintf(fout,"0,\t0,\t0};\n");
d1000 15
a1014 16
	
	fprintf(fout,"struct yywork *yytop = yycrank+%d;\n",yytop);
	fprintf(fout,"struct yysvf *yybgin = yysvec+1;\n");
	if(optim){
		fprintf(fout,"char yymatch[] ={\n");
		if (chset==0) /* no chset, put out in normal order */
			{
			for(i=0; i<NCH; i=+8){
				for(j=0; j<8; j++){
					int fbch;
					fbch = match[i+j];
					if(printable(fbch) && fbch != '\'' && fbch != '\\')
						fprintf(fout,"'%c' ,",fbch);
					else fprintf(fout,"0%-3o,",fbch);
					}
				putc('\n',fout);
d1016 1
d1018 1
a1018 2
		else
			{
d1020 13
a1032 14
			fbarr = myalloc(2*NCH, sizeof(*fbarr));
			if (fbarr==0)
				error("No space for char table reverse",0);
			for(i=0; i<ZCH; i++)
				fbarr[i]=0;
			for(i=0; i<NCH; i++)
				fbarr[ctable[i]] = ctable[match[i]];
			for(i=0; i<ZCH; i+=8)
				{
				for(j=0; j<8; j++)
					fprintf(fout, "0%-3o,",fbarr[i+j]);
				putc('\n',fout);
				}
			cfree(fbarr, 2*NCH, 1);
d1034 1
a1034 1
		fprintf(fout,"0};\n");
d1036 2
d1039 8
a1046 8
	fprintf(fout,"char yyextra[] ={\n");
	for(i=0;i<casecount;i=+8){
		for(j=0;j<8;j++)
			fprintf(fout, "%d,", i+j<NACTIONS ?
				extra[i+j] : 0);
		putc('\n',fout);
		}
	fprintf(fout,"0};\n");
d1048 5
a1052 19
	}
rprint(a,s,n)
  char *s;
  int *a, n; {
	register int i;
	fprintf(fout,"block data\n");
	fprintf(fout,"common /L%s/ %s\n",s,s);
	fprintf(fout,"define S%s %d\n",s,n);
	fprintf(fout,"integer %s (S%s)\n",s,s);
	for(i=1; i<=n; i++)
		{
		if (i%8==1) fprintf(fout, "data ");
		fprintf(fout, "%s (%d)/%d/",s,i,a[i]);
		fprintf(fout, (i%8 && i<n) ? ", " : "\n");
		}
	fprintf(fout,"end\n");
	}
shiftr(a, n)
	int *a;
d1054 4
a1057 3
int i;
for(i=n; i>=0; i--)
	a[i+1]=a[i];
d1059 4
a1062 2
upone(a,n)
	int *a;
d1064 4
a1067 3
int i;
for(i=0; i<=n ; i++)
	a[i]++;
d1069 10
a1078 23
bprint(a,s,n)
 char *s,  *a;
 int  n; {
	register int i, j, k;
	fprintf(fout,"block data\n");
	fprintf(fout,"common /L%s/ %s\n",s,s);
	fprintf(fout,"define S%s %d\n",s,n);
	fprintf(fout,"integer %s (S%s)\n",s,s);
	for(i=1;i<n;i=+8){
		fprintf(fout,"data %s (%d)/%d/",s,i,a[i]);
		for(j=1;j<8;j++){
			k = i+j;
			if(k < n)fprintf(fout,", %s (%d)/%d/",s,k,a[k]);
			}
		putc('\n',fout);
		}
	fprintf(fout,"end\n");
	}
# ifdef PP
padd(array,n)
  int **array;
  int n; {
	register int i, *j, k;
d1080 1
a1080 1
	if(count == 0){
d1083 2
a1084 2
		}
	for(i=tptr-1;i>=0;i--){
d1086 5
a1090 4
		if(j && *j++ == count){
			for(k=0;k<count;k++)
				if(!tmpstat[*j++])break;
			if(k >= count){
a1092 1
				}
d1095 2
a1096 1
	add(array,n);
d1098 2
a1099 2
	}
# endif
@
