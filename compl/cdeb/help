          CDEB - ДИАЛОГОВЫЙ ОТЛАДЧИК ЯЗЫКОВ C И FORTRAN-77


                         ПРИМЕНЕНИЕ

Отладчик cdeb позволяет отлаживать программы, написанные на языках C и
FORTRAN-77 по шагам в терминах исходного языка, т.е. выполнять их по
отдельным операторам, просматривать значения переменных в произвольный
момент выполнения программы, обнаруживать операторы, вызывающие аварийные
события в программе и т.д. Он помогает быстро обнаруживать ошибки
кодирования, нарушения логики работы программы и причины аварийных событий
в программе.


                 ОСНОВНЫЕ ВОЗМОЖНОСТИ ОТЛАДЧИКА

Отладчик позволяет:

    a). Приостановить выполнение программы в произвольной точке, т.е. перед
выполением заданного оператора, при вызове заданной функции, при вызове
функции на заданной глубине рекурсии;

    б). Приостановить выполнение программы по аварийным событиям, по
изменению заданной переменной, по заданному значению заданной переменной, в
произвольный момент времени по нажатию спецклавиши;

    в). Просматривать текст приостановленной программы в произвольной
последовательности;

    г). Посмотреть и изменить состояние приостановленной программы, т.е.:
смотреть и изменять значения переменных и массивов, смотреть стек вызовов
функций, изменить оператор, с которого продолжится выполение программы
после дальнейшего запуска;

    д). Выполнять программу по шагам, т.е. останавливая ее перед выполением
каждого оператора;

    е). Запустить программу дальше, задав точку или условия останова.

    ж). Отлаживать экранную программу с другого терминала.

Вся отладка идет в терминах исходного языка, т.е. операторы показываются в
том виде, в котором они написаны в тексте программы, точки останова
задаются указанием строк текста программы (а не адреса машинной
инструкции), за один шаг выполняется целиком оператор исходного языка.
Показ и модификация переменных идет в формате, зависящем от их типа. При
просмотре переменных разрешается использовать операцию индексации [...] и
операции языка C  * и & . Для отладки C-программ предусмотрена возможность
просматривать содержимое памяти по заданным адресам и регистров.

Отладчик позволяет отлаживать программы, состоящие из нескольких модулей
(файлов) написанных на разных языках.


                        ПРИНЦИПЫ РАБОТЫ

Для отладки с помощью cdeb-а программы должны быть специальным образом
подготовлены - откомпилированы C или FORTRAN компилятором с ключом "-d".
При этом компиляторы вставляют в отлаживаемую программу команды,
необходимые для работы отладчика. Отладчик пользуется также таблицей имен
переменных, подготавливаемой ассемблером и редактором связей. Отладчик
запускает готовую программу и управляет ее выполнением с помощью системного
вызова ptrace. Если программа состоит из нескольких файлов, то часть файлов
может быть откомпилирована в обычном режиме - при этом эти модули будут
выполняться без контроля отладчика.


                        ЗАПУСК ОТЛАЧИКА

Все отлаживаемые файлы программы надо оттранслировать с ключом "-d"
(d маленькое). При этом значащая часть имен этих файлов (до ".c" или до
".f") не должна быть длиннее 8 букв. Исходные текстовые файлы программ
(имя.c или имя.f) должны находиться в текущем каталоге (их использует
отладчик для показа текста).

Затем необходимо запустить команду cdeb по формату:

        cdeb  имя.отлаживаемой.программы  [ее.параметры]

Отладчик запускает отлаживаемую программу, передавая ей указанные параметры
командной строки, останавливает ее перед выполнением первого оператора
программы, показывает этот оператор и ждет ввода директивы.

При необходимости программы откомпилированные в отладочном режиме (с ключом
"-d") можно запускать и без отладчика (но работать они будут в 2-3 раза
медленнее, чем в обычном режиме).


                ОБЩЕЕ ОПИСАНИЕ ПРОЦЕССА ОТЛАДКИ

Отлаживаемая программа может находиться в двух состояниях:

    a). Она приостановлена. При этом работает отладчик - он воспринимает
директивы пользователя и позволяет просматривать и изменять переменные в
программе, просматривать текст программы, запустить программу на
выполнение. В этом состоянии отладчик помнит, перед выполнением какой
строки была остановлена программа (на экране эта строка показывается с
маркером ">"). При запуске программы она продолжается с того оператора, на
котором была остановлена.

    б). Программа запущена (соответствующей директивой отладчика). При этом
отладчик неактивен и программа выполняется как в обычном режиме до тех пор
пока не произойдет одно из следующих событий:
        В программе произойдет аварийное событие (напр., деление на 0);
        Программа дойдет до выполнения указанной при запуске строки;
        Произойдет вызов указанной при запуске функции (подпрограммы);
        Измениться значение указанной переменной (массива);
        Значение указанной переменной станет равным заданному;
        Пользователь "вручную" вызовет отладчик, нажав клавишу СУ-\.
При этом программа останавливается, вызывается отладчик, он показывает
причину останова (при аварийном событии в программе), номер строки и сам
оператор, перед выполнением которого была остановалена программа. Отладчик
ждет очередной директивы.


                   ФОРМАТ ДИРЕКТИВ ОТЛАДЧИКА

Когда отладчик ждет очередной директивы, он выдает приглашение ":". Перед
приглашением могут находиться некоторые символы (см.ниже), показывающие
режим отладчика. Директивы набираются только после приглашения (предчтение
не действует).

Несколько директив можно набирать в одной строке, разделяя их запятыми.
Лишние пробелы в директивах не допускаются. В начале строки директив можно
поставить коэффициент повторения в виде: (число)* . При этом вся строка
директив будет выполнена указанное (число) раз. Можно также перед строкой
директив поставить символ "(". При этом отладчик не только выполнит эту
строку, но и запомнит ее. В дальнейшем ее можно будет выполнить, набрав
директиву ")".

Все целые числа считаются 16-ричными, если они начинаются с 0x или 0X,
8-ричными, если они начинаются с 0 и десятичными в остальных случаях.

Можно выделить несколько групп директив: просмотра текста, запуска
программы, модификации и просмотра переменных, разные директивы.

Выполнение любой директивы отладчика можно прервать, нажав СУ-\ или СУ-C.


                  ДИРЕКТИВЫ ПРОСМОТРА ТЕКСТА ПРОГРАММЫ

Строку программы, перед выполением которой она остановлена, назовем
актуальной строкой. Последнюю показанную на экране строку назовем текущей
строкой. При каждой новой остановке программы текущая строка
устанавливается на актуальную.

Общие директивы:

СУ-D            Конец отладки.

?               Показ краткого руководства по директивам отладчика.

Все директивы просмотра текста имеют вид: (номер_строки) [+/- (число)]
Вместо номера строки можно использовать символ ".", который обозначает
актуальную строку. Если указан только номер строки, то отладчик показывает
несколько строк около запрошенной. Показывается номер строки и сама строка.
Актуальная строка (та, перед выполнением которой остановлена программа)
помечена символом ">". Перед 1-ой строкой файла ставится маркер:
<<< имя_файла >>>, после последней строки файла ставится маркер:
<<< end of имя_файла >>>.

После номера строки можно добавить +число или -число, что означает:
"показать еще (число) следующих/предыдущих строк после/перед указанной".
Если номер строки не был указан, то отсчет строк ведется от последней
показанной. Наконец, если использовать просто знаки + и - (без числа), то
это эквивалентно +10 и -10.

Примеры:

.               Показывает группу строку около актуальной.
45              Показывает группу строк около строки номер 45.
4+20            Показывает строки с 4-ой по 24-ую.
40-10           Показывает строки с 30-ой по 40-ю.
.+20            Показывает актуальную строку и следующие 20 строк.
+15             Показывает следующие 15 строк после последней показанной.
-30             Показывает предыдущие 30 строк.
+               Показывает следующие 10 строк вниз.
-               Показывает предыдущие 10 строк


                ДИРЕКТИВЫ УПРАВЛЕНИЯ ХОДОМ ПРОГРАММЫ

При выполнении программы она будет всегда остановлена по аварийному событию
или по нажатию клавиши СУ-\, независимо от того, какой директивой отладчика
программа была запущена. При аварийных событиях программа будет остановлена
ДО выполнения "аварийного" оператора,(т.е. на самом деле программа выполнит
этот оператор,  но  отладчика  обнаружит  ошибку  и  восстановит  состояние
программы (регистры) до выполнения этого оператора).

ВК              Выполнение одного шага программы. Для C шагом считается
                вычисление одного выражения. Так, оператор:
                        if( a+b > c )  d = e - k;
                будет вычислен за два шага, оператор:
                        for( i=0; i<10; ++i, ++k )  a[k] = i;
                - по 3 шага на каждый цикл. Для FORTRAN-а обычно один шаг
                соответствует одному оператору программы, но оператор:
                        if( a.eq.b )  k=p
                будет выполена за 2 шага (если условие истинно).
                Директивой " можно установить режим работы отладчика, при
                котором он останавливается на каждой строке не более 1
                раза. Если в выражении встречается вызов фукнции
                (подпрограммы), то действия зависят от режима отладчика. В
                исходном режиме отладчик не будет входить в функции, т.е.
                они будет выполняться без отладки.

Если набирается несколько директив через запятую, то вместо ВК надо писать
пустую команду, т.е.:

,,,,            Означает 5 пустых команд, т.е. выполнить 5 шагов.
10*,1           Выполнить 10 шагов, показывая после каждого 1-ую строку.

Отладчик имеет 2 флага режима - режим при котором он входит в подпрограммы
и режим, при котором он не останавливается дважды на одной строке. Эти
режимы изменяются командами ' и ". Текущий режим показывается наличием
соответствующих символов перед приглашением.

'               Смена режима '. После 1-ой подачи этой директивы отладчик
                начинает при пошаговой работе входить в вызываемые функции,
                после 2-ого - перестает и т.д. Режим показывается символом
                ' перед приглашением ":".

"               Смена режима ". После 1-ой подачи этой директивы отладчик
                перестает дважды останавливаться на одной строке для
                операторов типа if( a>=b ) c=d;  после 2-ого - снова
                начинает т.д. Режим показывается символом " перед ":".

Программу можно выполнять не только по шагам, но и запустить ее, задав
условие останова. Все такие директивы начинаются с символа ^ (или ~), за
которым идет условие останова. Существуют следующие директивы:

^               Безусловный запуск программы. При необходимости, после
                этого, программа может быть снова остановлена и вызван
                отладчик нажатием клавиши СУ-\. Останов программы может
                произойти и по аварийному событию в программе.

^(число)        Запуск программы с остановом на строке (число) текущего
                файла. По этой директиве программа будет запущена и будет
                выполняться до тех пор, пока не дойдет до выполнения
                оператора в указанной строке. Перед выполнением этого
                оператора она будет остановлена и отладчик запросит
                очередную директиву. При выполнении программа может быть
                остановлена также по аварийному событию или нажатию клавиши
                СУ-\.
                Если программа дошла до выполнения указанной строки, но на
                более высоком уровне рекурсии, то останов произойдет
                только, если установлен режим входа в подпрограммы: '.

^> или >        "Вход" в функцию. Если в выражении, которое будет
                вычисляться на очередном шаге есть вызов функции, то
                отладчик "войдет" в нее и остановится перед ее 1-ой
                строкой, независимо от установленного режима.

^>(имя_фукции)   "Вход" в указанную функцию. Программа запускается и будет
   или           снова остановлена, когда произойдет вызов указанной
>(имя_функции)   функции - перед ее первым оператором.

^< или <        "Выход" из функции (или из блока, имеющего свои локальные
                переменных). Программа запускается и будет остановлена по
                завершении текущей функции (блока).

^имя_переменной Программа запустится, и будет остановлена, когда значение
                данной переменной изменится. Можно контролировать изменения
                даже для массивов. Подробнее о способах задания границ
                массива и размера переменной (в C) см. ниже (модификаторы).

^имя=значение   Программа запустится, и будет остановлена, когда значение
                данной переменной станет равным заданному. Контролировать
                это в действующей версии можно только для переменных типа
                'int' и 'char' (C) или integer*2 и logical (FORTRAN).

В этих 2-х директивах останов программы произойдет после оператора,
изменившего значение контролируемой переменной.


              ДИРЕКТИВЫ ПРОСМОТРА И ИЗМЕНЕНИЯ ПЕРЕМЕННЫХ

Для программ, написанных на FORTRAN'е, отладчику известны типы переменных и
формат просмотра выбирается в соответствии с типом. Для программ на языке C
все переменные по умолчанию считаются int переменными,но можно явно указать
формат выдачи.

Все директивы этой группы требуют указания имени переменной и (при
необходимости) спецификаций (длины, размерности ...)  используемой
переменной. Директивы просмотра имеют формат:

        имя_переменной [модификатор]

или, если желательно посмотреть уже указанную переменную, но с другими
модификаторами, то:

        " " модификатор                 ( начинается с 1 пробела ).

Имя переменной с модификаторами назовем описанием переменной.

Вместо имени переменной можно явно указать адрес используемой ячейки памяти
- в виде: $число, а также номер регистра - %число.

После имени переменной можно дописать следующие модификаторы (в любом
порядке, любое количество - применяются, в-основном,  для  языка  C):
        :               переменная занимает 1 байт (char)
        :число          переменная занимает (число) байт
        *               взять объект, на который указывает "имя"
        &               взять адрес переменной (для регистровых - номер)
        .число          сместиться на (число) байт от "имени"
        +число          то же самое
        -число          сместиться на (число) байт назад от "имени"
        [число]         взять элемент (число) из массива "имя".
                        В C индексы считаются с 0, в FORTRAN'е с 1.
        [число:число]   взять указанную вырезку массива
        [число-число]   то же самое

Примеры:        просматриваемая переменная (в основном они относятся к C)
        a               int a   или  unsigned a
        b:              char b
        c:4             long c  или  float c
        k[5]            6-ое слова массива  int k[]
        d:[0:255]       элементы массива  char d[256]  с 0 по 255-ый
        e.12            поле структуры e, смещенное от начала на 12 байт
        i1&             адрес переменной  int i1  (или номер регистра)
        ptr*:           байт по указателю  char *ptr
        $0200           содержимое слова по адресу 0200
        %6              содержимое регистра 6 (т.е. SP)


ПРОСМОТР ПЕРЕМЕННОЙ. Необходимо набрать строку вида:

        описание_переменной [формат_выдачи]

Отладчик покажет имя переменной и ее значение в указанном формате. Для
вырезок массивов (например, d:[0:255]) будут последовательно показаны все
элементы.

Если в C формат выдачи не указан, то переменная будет показана в одном из
стандартных форматов отладчика: как литера для 'char', как десятичное число
для 'int'  и 'long', как плавающее для 'double' и в виде дампа (т.е.
одновременно 8-ричные числа и их текстовое изображение) для других длин
переменных. Для FORTRAN'а формат выдачи определяется типом переменной.

Формат можно указать либо как стандартный формат 'printf'а
(например: i1%04x), либо одним из символов: $ ' "
        $       выдать переменную в формате дампа
        '       выдать переменную в виде цепочки литер
        "       выдать переменную как строку символов до '\0'
Отладчик по формату выдачи сам определяет длину переменной, поэтому
модификатор длины ( :(число) ) обычно не нужен.

Примеры:          Что покажет отладчик
        i               10
        i%o             12
        i'              '\n\0'
        i"              "\n"
        d[4]'           'a'
        d:[4]%d         141


МОДИФИКАЦИЯ ПЕРЕМЕННОЙ. Чтобы изменить переменную, надо набрать:

        описание_переменной = новое_значение(ия)

или, если надо изменить только что просмотренную переменную, то:

        = новое_значение

В качестве значения можно использовать числа, строки символов в виде 'а',
'ab\n\145', а также строку в кавычках: "abc" (дополняется на конце
символом \0). В FORTRAN-е комплексные числа надо набирать в виде:
(1.2 3.5e-5), а logical переменные как буквы t и f.

Если набрать несколько значений, разделяя их одним пробелом, то они будут
присвоены последовательным элементам массива.

Примеры:
        i1=3                    число 3 записали в слово
        c1:='a'                 букву 'a' записали в байт
        c1:='abc'               буквы 'a','b','c' записали в 3 послед.байта
        c2:="abcd"              записали строку с '\0' на конце
        c2:='a' 'b' 'c' 'd' 0   то же
        d:[0:5]=1 2 3 4 5 6     записали 6 элементов массива
        f:4=1.2e-45             записали 'float' число
        l=t t f t               для logical массива в FORTRAN'е
        c=(1.3 -5.6)            для complex числа (разделять 1 пробелом)


                        РАЗНЫЕ ДИРЕКТИВЫ

Эти директивы начинаются с одного из символов \ или | за которым следует
буква. Букву можно набирать как маленькую, так и большую. За ней могут идти
параметры директивы. Мнемоника этих директив взята по первым буквам
английских слов:

\w              where   Показ актуальной строки.

\d(буква)       display Перенос ввода и вывода отладчика на другой терминал
                - на терминал /dev/tty(буква). Применяется для отладки
                программ с экранным диалогом. Перед подачей этой команды
                необходимо "поздороваться" на другом терминале под своим же
                именем и заблокировать ввод shell'а, например, подав
                команду "sleep 10000".

\s              stack   Показ текущего стека вызовов функций. Показываются
                последовательно самая последняя вызванная функция,
                предыдующая и т.д. с их параметрами (в 8-ичной форме).

\g(число)       goto    Переход на строку (число). Эффект от этой директивы
                такой же, как если бы в программе был выполнен оператор
                'goto' на указанную строку, т.е. изменится номер актуальной
                строки. При запуске программы в дальнейшем ее выполнение
                будет продолжено уже с новой строки. Строка (число)
                обязательно должна находиться в актуальной функции.


АВТОР:  Флеров М.Н., ИПК Минавтопрома, 1985 г.




ПРИЛОЖЕНИЕ:

                   СИНТАКСИС ДИРЕКТИВ ОТЛАДЧИКА

В БНФ формах использованы символы:  ! - альтернатива, [..] - необязательный
элемент, % - начало комментария. Лишние пробелы в директивах не
допускаются. При необходимости в БНФ используются слова: пробел и пусто.

Некоторы терминальные символы считаются общеизвестными, например
десятичное_целое.


строка_директив ::= (целое) * строка_директив   % вып.строку (целое) раз
                !   ( строка_директив           % выполнить и запомнить
                !    директива [, строка_директив ]

целое           ::= десятичное_целое
                !   0 восьмеричное_целое
                !   0x шестнадцатеричное_целое
                !   0X шестнадцатеричное_целое

директива       ::= СУ-D                % конец отладки
                !   пусто               % выполнить один оператор программы
                !   )                   % выполнить запомненную строку_дир.
                !   ?                   % выдать краткое руководство
                !   '                   % смена режима отладчика
                !   показ_текста
                !   просмотр_переменной
                !   модификация_переменной
                !   запуск_программы
                !   разные_директивы

показ_текста    ::= строка [еще_строки] % показ указанного интерв. строк
                !   еще_строки          % показ еще нескольких строк

строка          ::= целое
                !   .                   % обозначает актуальную строку

еще_строки      ::= + целое             % показ (целое) строк вниз
                !   - целое             % показ (целое) строк вверх
                !   +                   % показ 10 строк вниз
                !   -                   % показ 10 строк вверх

просмотр_перем. ::= область [формат]

модификация_пер.::= область = группа_значений

область         ::= переменная [модификаторы]
                !   пробел [модификаторы]       % берем предыдущ. переменн.

переменная      ::= имя                 % в смысле C или FORTRAN'а
                !   $ целое             % адрес ячейки памяти
                !   % целое             % номер регистра

модификаторы    ::= модификатор [модификаторы]

модификатор     ::= :                   % длина переменной 1 байт (char)
                !   : целое             % длина переменной =(целое) байт
                !   *                   % перейти по указателю
                !   &                   % взять адрес переменной
                !   + целое  !  . целое % сместиться на (целое) байт
                !   - целое             % сместиться на -(целое) байт
                !   [целое]             % взять элемент массива
                !   [целое:целое]       % взять вырезку массива
                !   [целое-целое]       %  -"-    -"-    -"-

группа_значений ::= значение [ пробел группа_значений] % в послед.яч.памяти

значение        ::= [знак] целое
                !   [знак] плавающее_число
                !   t   !   f                   % logical число
                !   (плавающее пробел плавающ.) % complex число
                !   " строка_символов "         % дополняется '\0' на конце
                !   ' строка_символов '         % не -"- -"- -"-

формат          ::= % формат_в_смысле_printf'а
                !   "                           % выдать как строку до '\0'
                !   '                           % выдать в символьном виде
                !   $                           % выдать в виде дампа

запуск_программы::= ^                   % безусловный запуск
                !   ^ строка            %  -"- с остановом на (строке)
                !   ^ область           %  -"- -"-  по изменению (области)
                !   ^ область = целое   %  -"- -"-  по значению (области)
                !   [^] > [имя_функции] %  -"- -"-  по вызову функции
                !   [^] <               %  -"- -"-  по выходу из функции

% в следующих директивах допускается вместо символа | использовать \ и
% набирать буквы как маленькими, так и большими. приведена мнемоника
% сокращений

разные_директ.  ::= | g строка          % goto     переход на (строку)
                !   | d буква           % display  на диспл. tty(буква)
                !   | w                 % where    показать актуальную стр.
                !   | s                 % stack    показать стек вызовов
