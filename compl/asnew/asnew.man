






           Производственно-внедренческий кооператив

                     "И Н Т Е Р Ф Е Й С"













                 Диалоговая Единая Мобильная

                     Операционная Система

                         Демос/P 2.1










                   Описание языка Ассемблер

                  (руководство программиста)














                            Москва

                             1988















                         АННОТАЦИЯ

      Описывается  язык  ассемблера  as  и  компилятор  этого
 языка.






























































 1.  ВВЕДЕНИЕ
 Язык as представляет собой ассемблер без возможностей макро-
 расширения.   Он  используется при создании выходного файла,
 содержащего словарь перемещений и полную  таблицу  символов.
 Таким  образом,  выходной  файл  является стандартным файлом
 ввода для программы редактирования связей.  Выходной  формат
 ассемблера  спроектирован  таким образом, что если программа
 не содержит неразрешенных внешних ссылок, то она может  быть
 выполнена без дополнительной обработки редактором связей.

 2.  ВЫЗОВ КОМПИЛЯТОРА

 Формат вызова компилятора as:

     as [-u] [-o output] file ...

 Если указан ключ -u, то все неопределенные символы в ассемб-
 лируемой  программе будут считаться неопределенными внешними
 символами.

      Остальные параметры указывают файлы, которые  объединя-
 ются и ассемблируются. Таким образом, программа может состо-
 ять из нескольких частей, ассемблируемых вместе.

      Результат работы ассемблера по умолчанию  помещается  в
 файл  a.out  в  текущем  каталоге.  Ключ  -o  указывает, что
 результат следует  поместить  в  названный  файл.  Если  нет
 неразрешенных  внешних  ссылок  и не было обнаружено ошибок,
 выходной файл помечается как  выполняемый;  иначе,  если  он
 вообще  создается,  он  помечается  как файл, который нельзя
 выполнить.

 3.  ЛЕКСЕМЫ
 Лексемы ассемблера включают в  себя  идентификаторы  (иногда
 называемые  символами или именами), временные символы, конс-
 танты и операции.

 3.1.  Идентификаторы
 Идентификатор - это последовательность из букв, цифр, точки,
 знака подчеркивания и тильды, не начинающаяся с цифры.  Зна-
 чимыми являются только первые восемь символов.  Если иденти-
 фикатор начинается с тильды, то при его обработке компилято-
 ром ассемблера эта тильда отбрасывается, а в таблице  симво-
 лов появляется уникальная запись, не совпадающая с записями,
 порожденными другими вхождениями этого  идентификатора.  Эта
 особенность  используется  компилятором Си, который помещает
 имена локальных переменных в выходную таблицу  символов,  не
 делая их уникальными.

 3.2.  Временные символы
 Временным символом называют цифру, за которой  следует  одна
 из  букв: 'f' или 'b'. Подробно временные символы рассматри-
 ваются в разделе 8.1.


                            - 3 -










 3.3.  Константы
 Восьмеричная константа - это последовательность цифр.  Цифры
 "8" и "9" используются для представления восьмеричных значе-
 ний 10 и 11. Константа укорачивается до 16 бит и  рассматри-
 вается как двоичное число в дополнительном коде.

      Десятичная константа  -  это  последовательность  цифр,
 заканчивающаяся десятичной точкой ".". Ее величина не должна
 быть более, чем 32768.

      Однолитерная константа состоит из одиночной кавычки, за
 которой  следует любой символ КОИ-8, за исключением перевода
 строки. Кроме  того,  в  однолитерных  константах  допустимы
 некоторые  двухсимвольные  ESC-последовательности, к которым
 относятся знак табуляции, символ новой строки  и  другие  не
 имеющие  графического  изображения символы (см. раздел 8.5).
 Значением константы является код данного символа, помещенный
 в младший байт слова и дополненный нулями слева.

      Двухлитерная константа состоит из двойной  кавычки,  за
 которой  следует  пара  любых  знаков  КОИ-8, кроме перевода
 строки. Вместо каждого  из  знаков  допускается  употреблять
 некоторые ESC-последовательности, к которым относится символ
 новнй строки и другие символы, не имеющие графического изоб-
 ражения.  Значением константы является код первого символа в
 младшем байте слова и код второго - в старшем байте слова.

 3.4.  Операции
 В ассемблере существует несколько однолитерных и  двухлитер-
 ных операций.  Подробно они рассмотрены в разделе 9.1.

 4.  ПРОБЕЛЫ
 Пробелы и знаки  табуляции  могут  быть  свободно  вставлены
 между  лексемами, но не должны использоваться внутри лексем;
 исключение составляют литерные константы. Пробелы или  знаки
 табуляции  необходимы  в  тех  случаях, когда нужно отделить
 друг от друга стоящие рядом идентификаторы или константы.

 5.  КОММЕНТАРИИ
 Знак / указывает, что за ним следует комментарий, продолжаю-
 щийся  до конца строки, в которой этот знак встретился. Ком-
 ментарии игнорируются ассемблером.

 6.  СЕГМЕНТЫ
 Ассемблируемые коды и данные распределяются по трем  сегмен-
 там:  текстовый  сегмент,  сегмент  данных  и  сегмент  bss.
 Ассемблерная программа начинается с текстового  сегмента,  в
 который обычно помещаются выполняемые команды. Система ДЕМОС
 может, если надо,  обеспечить  целостность  текстового  сег-
 мента,  вылавливая  все операции, производящие запись внутрь
 него. Чтобы текстовый сегмент был таким образом  защищен  от
 записи, выданные ассемблером объектные программы должны быть
 обработаны редактором связей ld с использованием  его  ключа


                            - 4 -










 -n.   Все  процессы  выполнения  одной  программы  разделяют
 единственную копию текстового сегмента.

      Сегмент данных доступен для размещения в нем данных или
 команд,  изменяющихся  во  время выполнения программы.  Все,
 что может быть помещено в текстовый сегмент, можно  помещать
 и  в сегмент данных.  В программах с разделяемым, защищенным
 от записи текстовым сегментом, сегмент данных содержит  ини-
 циализированные,  но изменяемые части программы.  Если текс-
 товый сегмент не защищен, сегмент  данных  следует  за  ним;
 если  защищен,  сегмент  данных начинается с ближайшей после
 его конца границы 8К байтов.

      Сегмент bss не может содержать никаких явно инициализи-
 рованных  команд или данных.  Длина сегмента bss, так же как
 текстового сегмента и сегмента данных, определяется маркером
 максимального  значения  счетчика адреса внутри его. Сегмент
 bss на самом деле - расширение сегмента данных и  начинается
 сразу после него.  В начале выполнения программы сегмент bss
 устанавливается в 0.  Обычно сегмент bss создается  операто-
 рами, примером которых может служить:

     lab:.=.+10

 Выгода от использования сегмента bss для участков памяти, не
 нуждающихся  в  инициализации, состоит в том, что в выходной
 файл нет необходимости помещать информацию  о  их  начальных
 значениях.

 7.  СЧЕТЧИК АДРЕСА
 Специальный символ ".", используется как счетчик адреса. Его
 величина  в любой момент равна смещению внутри соответствую-
 щего сегмента начала того оператора, в котором он  появился.
 Ему можно присваивать значения при условии, что текущий сег-
 мент не может измениться на другой. Кроме того, значение "."
 не может быть уменьшено. Если в результате присвоения значе-
 ние счетчика адреса увеличивается, то создается  необходимое
 число нулевых байтов.

 8.  ОПЕРАТОРЫ И МЕТКИ
 Исходная программа состоит из последовательности операторов.
 Операторы  разделяются переводами строки или точками с запя-
 той.  Операторы  бывают  пяти   видов:   пустые   операторы,
 операторы-выражения,   операторы   присваивания,  операторы-
 строки и операторы с ключевыми словами.

      Перед оператором любого вида может стоять одна или нес-
 колько меток.

 8.1.  Метки
 Есть два вида меток: метки-идентификаторы и цифровые  метки.
 Метка-идентификатор - это имя, за которым следует двоеточие.
 В результате употребления метки-идентификатора  этому  имени


                            - 5 -










 присваиваются  текущие  тип и значение счетчика адреса. Если
 это имя уже определено, то первый проход  фиксирует  ошибку.
 Если присвоенное значение "." изменяет определение метки, то
 при втором проходе будет зафиксирована ошибка.

      Цифровая метка - это цифра от 0 до 9, за  которой  сле-
 дует двоеточие. Такие метки служат для определения временных
 символов вида nb и nf , где n-цифра метки. Как  и  в  случае
 меток-идентификаторов  цифровые  метки вызывают присваивание
 текущих типа и значения счетчика адреса "." временному  сим-
 волу. Однако в одной и той же программе могут появиться нес-
 колько цифровых меток с одной и той же цифрой.  Ссылки  вида
 nf  указывают  на  ближайшую цифровую метку "n:" после места
 ссылки. Ссылка вида nb указывает  на  ближайшую  метку  "n:"
 перед  местом ссылки. Они предназначены для экономии места в
 таблице символов ассемблера.

 8.2.  Пустые операторы
 Пустые операторы не содержат ничего, кроме предшествующих им
 меток.  Обычными  примерами  пустых операторов служат пустые
 строки или строки, содержащие только метку. Ассемблер  игно-
 рирует пустые операторы.

 8.3.  Операторы-выражения
 Операторы-выражения - это  арифметические  выражения,  перед
 которыми нет ключевого слова. Ассемблер вычисляет 16-битовое
 значение выражения и помещает его в выходной поток вместе  с
 соответствующими битами смещения.

 8.4.  Операторы присваивания
 Оператор  присваивания  состоит  из  идентификатора,   знака
 равенства  и  выражения. Значение и тип выражения присваива-
 ются идентификатору. При этом не требуется,  чтобы  тип  или
 значение  при  втором  проходе  были бы такими же, как и при
 первом. Переопределение любого символа посредством оператора
 присваивания не является ошибкой.

      При присваивании любой внешний атрибут выражения  теря-
 ется.  Это  означает,  что  невозможно определить глобальный
 символ посредством присваивания к нему и невозможно  опреде-
 лить  символ  как  смещение от нелокально определенного гло-
 бального символа.

      Допускается присваивание  счетчику  адреса.  При  этом,
 однако,  требуется, чтобы тип присваиваемого выражения и "."
 совпадали. Запрещается уменьшать значение ".".  На  практике
 наиболее  распространенное  присваивание  к  "." имеет форму
 .=+n, где n - некоторое число.  результатом такого  присваи-
 вания является генерация n нулевых байтов.






                            - 6 -










 8.5.  Операторы-строки
 Оператор-строка генерирует последовательность байтов, содер-
 жащих символы в коде КОИ-8. Оператор-строка состоит из левой
 строчной кавычки <, последовательности символов КОИ-8, кото-
 рая  не  включает  символа  новой  строки, и правой строчной
 кавычки >. Любой из символов КОИ-8 может быть заменен  двух-
 символьной ESC-последовательностью, служащей для представле-
 ния некоторых неграфических символов, так, как это  показано
 ниже:

     \n nl  (012)
     \s sp  (040)
     \t ht  (011)
     \e eot (004)
     \o nul (000)
     \r cr  (015)
     \a ack (006)
     \р pfx (033)
     \\ \
     \> >

 Последние две последовательности включены  для  того,  чтобы
 можно  было  представить  сам  ESC-символ  и правую строчную
 кавычку. ESC-последовательности можно также  использовать  в
 односимвольных и двухсимвольных константах.

 8.6.  Операторы с ключевыми словами
 В численном отношении операторы с ключевыми  словами  предс-
 тавляют собой наиболее распространенный тип, поскольку боль-
 шинство машинных команд имеют именно такую форму. Оператор с
 ключевым  словом начинается с одного из многих заранее опре-
 деленных ключевых слов ассемблера. Синтаксис остальной части
 оператора определяется этим ключевым словом.

 9.  ВЫРАЖЕНИЯ
 Выражение - это последовательность символов,  представляющих
 значение. Оно строится из идентификаторов, констант, времен-
 ных символов, знаков операций  и  скобок.  Каждое  выражение
 имеет тип.

      Все операции в выражениях  по  своей  природе  являются
 бинарными: если левый операнд отсутствует, то предполагается
 0 абсолютного типа.  Используется арифметика в  дополнитель-
 ном коде с 16 битами точности. Все операции имеют одинаковое
 старшинство и выражения вычисляются строго слева направо  за
 исключением эффекта, определяемого наличием скобок.

 9.1.  Операции в выражениях

 В выражениях употребляются следующие операции:

                если между операндами нет знака операции, это
                то же самое, что и появление знака +;


                            - 7 -










           +    сложение;

           -    вычитание;

           *    умножение;

           \/   деление;

           &    побитовое и;

           |    побитовое или;

           \>   логический сдвиг вправо;

           \<   логический сдвиг влево;

           %    деление нацело;

           !    a!b Значит (a или (не b)), то  есть  операция
                или  между  первым операндом и дополнением ко
                второму (чаще всего используется как  унарная
                операция).

           ^    результат получает значение первого  операнда
                и  тип  второго  (Чаще всего используется для
                определения новых машинных команд с синтакси-
                сом,   идентичным   синтаксису   существующих
                команд).

      Выражения могут  группироваться  с  помощью  квадратных
 скобок. Круглые скобки зарезервированы для обозначения типов
 адресации.

 9.2.  Типы выражений
 Ассемблер имеет дело с некоторым количеством  типов  выраже-
 ний.  Большая  часть  типов  связана  с  ключевыми словами и
 используется для  выбора  подпрограммы,  обрабатывающей  это
 ключевое слово.  В явном виде могут встретиться типы:

 неопределенный
      - при первом появлении каждый символ является неопреде-
        ленным.  Символ  может стать неопределенным, если ему
        присваивается значение неопределенного выражения. При
        втором  проходе попытка ассемблировать неопределенное
        выражение вызовет ошибку, при первом - нет (за исклю-
        чением  того,  что  некоторые ключевые слова требуют,
        чтобы операнды не являлись неопределенными);

 неопределенный внешний
      - символ, объявленный как .globl,  но  не  определенный
        при  текущем  ассемблировании, получает тип неопреде-
        ленный внешний.  Если в программе есть такой  символ,
        то  перед  загрузкой  выход  ассемблера  должен  быть


                            - 8 -










        объединен с другим  модулем,  содержащим  определение
        этого символа, с помощью редактора связей ld;

 абсолютный
      - абсолютные  символы  в  конечном  счете  определяются
        через  константы.  На  их  значение не влияют никакие
        последующие применения редактора связей к  результату
        ассемблирования;

 текстовый
      - значения  символов  текстового  типа  соотносятся   с
        начальным   адресом  текстового  сегмента  программы.
        Если результат ассемблирования компонуется с  другими
        модулями, значения его символов текстового типа могут
        измениться, так как этот модуль не обязательно  будет
        первым  в  выходном  файле  редактора  связей.  Боль-
        шинство символов текстового типа  получают  значения,
        когда  появляются в качестве меток.  В начале ассемб-
        лирования значение "." есть текстовый 0;

 данные
      - величина символа типа данных  соотносится  с  началом
        сегмента  данных  программы. Как и символы текстового
        типа, символы типа данных могут поменять значение  во
        время  последующего  применения редактора связей, так
        как помещаемые в память раньше программы могут  иметь
        сегмент данных. После появления первого оператора

            .data величина

        значение "." равно 0, а тип - данные;

 bss  - величина символа типа  bss  отсчитывается  от  начала
        сегмента  bss  программы. Величина символов типа bss,
        как и символов текстового типа и типа  данных,  может
        измениться  при последующем применении редактора свя-
        зей, так как программы, помещенные в  память  раньше,
        могут иметь сегменты bss. После первого оператора

            .bss

        значение "." равно 0, а тип - bss;

 внешние абсолютный, текстовый, данных или bss
      - символы, объявленные как .globl, но получившие значе-
        ние при ассемблировании как символы абсолютного типа,
        текстового типа, типа данных или типа bss, могут быть
        использованы  точно  так  же, как если бы они не были
        объявлены как .globl. Однако их тип и  значение  дос-
        тупны  редактору связей, так что программа может быть
        загружена вместе с  другими  программами,  в  которых
        содержатся ссылки на эти символы;



                            - 9 -










 регистровый
      - символы r0,...,r5,  fr0,...,fr5,  sp,  pc  определены
        заранее как символы регистров. Они или символы, опре-
        деленные через  них,  используются  для  обращения  к
        шести  регистрам общего назначения, шести регистрам с
        плавающей точкой и двум регистрам специального назна-
        чения.  Использование имен регистров с плавающей точ-
        кой полностью идентично использованию имен  регистров
        общего назначения. Они предусмотрены для целей мнемо-
        ники;

 прочие типы
      - каждое из ключевых слов, известных ассемблеру,  имеет
        свой  тип,  который  используется для выбора подпрог-
        раммы, обрабатывающей оператор с соответствующим клю-
        чевым  словом. Если те же символы используются не как
        ключевые слова, то  они  рассматриваются  ассемблером
        как абсолютные.

 9.3.  Присваивание типов при вычислении выражений
 Если  операнды  объединены  знаком  операции  в   выражение,
 результат  имеет тип, зависящий от типов операндов и от опе-
 рации.  С точки зрения вычисления выражений важными являются
 типы:

     неопределенный;
     абсолютный;
     текстовый;
     данных;
     неопределенный внешний;
     прочие.

 Если один из операндов неопределен,  результат  неопределен-
 ный.  Если  оба  операнда  абсолютные, результат абсолютный.
 Если абсолютный тип сочетается с одним из прочих типов, упо-
 минающихся  выше,  или  с регистровым типом, результат будет
 иметь прочий или регистровый тип. Как следствие, можно  ссы-
 латься  на  r3  как на "r0+3". Если сочетаются операнды двух
 прочих типов, результат будет иметь тип с  большим  номером.
 Прочий  тип  в сочетании с явно упомянутыми в списке типами,
 за исключением абсолютного, действует как абсолютный.

 Правила применения конкретных операций таковы:

         +    если один операнд имеет текстовый, данных,  bss
              или неопределенный внешний тип, результат будет
              иметь тот же тип, а второй операнд должен  быть
              абсолютным;

         -    если первый операнд - переместимый символ текс-
              тового  сегмента,  сегмента данных или сегмента
              bss, то второй операнд должен быть  либо  абсо-
              лютным  (при  этом  результат  будет  иметь тип


                            - 10 -










              первого операнда), либо иметь тот же тип, что и
              первый  (при  этом  результат будет абсолютного
              типа). Остальные сочетания типов запрещены;

         ^    эта операция подчиняется только одному правилу,
              а  именно:  результат получает значение первого
              операнда и тип второго;

         прочие операции
              запрещено применять эти  операции  к  операндам
              любых типов, кроме абсолютных.

 10.  ПСЕВДООПЕРАЦИИ
 Перечисленные ниже ключевые слова вводят операторы,  которые
 либо  оперируют  данные  необычного  формата, либо управляют
 дальнейшими действиями ассемблера.  Метаобозначение:

     [что-то]...

 Свидетельствует, что в указанном  месте  что-то  может  поя-
 виться ноль или более раз.

     .byte Выражение [,выражение]...

 Значения выражений из разделенного запятыми списка усекаются
 до  8 бит и размещаются в последовательных байтах. Этот опе-
 ратор  и  оператор-строка,  упомянутый  выше,  единственные,
 ассемблирующие данные побайтно.

     .even

 Если счетчик адреса "." имеет нечетное значение, он увеличи-
 вается  на единицу, так что следующий оператор будет ассемб-
 лироваться, начиная с границы слова.

     .if Выражение

 Выражение должно быть абсолютным  и  получить  значение  при
 первом  проходе. Если это значение отлично от нуля, оператор
 игнорируется. Если оно равно нулю, то операторы, заключенные
 между  if  и  соответствующим ему игнорируются. Эти условные
 операторы могут быть вложенными. Действие  условного  опера-
 тора  не  распространяется за пределы того входного файла, в
 котором он встретился.

      Операторы игнорируются не полностью:  они  просматрива-
 ются  и  все  встречающиеся  в них имена заносятся в таблицу
 символов.  Таким образом, имена, встречающиеся только внутри
 условного оператора, будут появляться в таблице символов при
 ее распечатке как неопределенные.

     .endif



                            - 11 -










 Этот оператор отмечает конец условно ассемблируемого участка
 программы.

     .globl имя [,имя] ...

 Этот оператор объявляет упомянутые  в  нем  имена  внешними.
 Если  они  в  то же время определены оператором присваивания
 или  как  метки,  то  внутри  программы  они  обрабатываются
 ассемблером  точно  так  же, как если бы оператора .globl не
 было. Однако редактор связей ld может  соединить  эту  прог-
 рамму с другими, ссылающимися на эти символы.

      И наоборот, если эти символы не определены в  ассембли-
 руемой программе, редактор связей может объединить результат
 текущего ассемблирования с модулями, в которых  определяются
 значения данных символов. Есть возможность объявить все сим-
 волы, каким-либо образом оказавшиеся неопределенными,  внеш-
 ними.

     .text
     .data
     .bss

 Эти три псевдооперации заставляют  ассемблер  помещать  свои
 результаты  в  текстовый  раздел, раздел данных или в раздел
 bss соответственно. Ассемблирование начинается с  текстового
 сегмента.  Запрещено  помещать  какие-либо коды или данные в
 раздел bss, но в нем можно  определять  символы  и  сдвигать
 счетчик адреса "." посредством присваивания.

     .comm имя, выражение

 При условии, что указанное имя не  определено  где-нибудь  в
 другом месте, этот оператор эквивалентен следующим:

     .globl имя
     имя = выражение ^ имя

 то есть имя получает тип неопределенное внешнее  и  значение
 выражения.  На  самом  деле  при текущем ассемблировании имя
 ведет себя как неопределенное внешнее, однако редактор  свя-
 зей  ld  рассматривает  такой случай как особый, так что все
 внешние символы, не определенные никаким другим  способом  и
 имеющие  ненулевое  значение,  помещаются в сегмент bss, где
 оставляется достаточное для размещения выражения число  бай-
 тов.  Все  символы, определенные таким способом, размещаются
 раньше всех других ячеек сегмента bss.

 11.  МАШИННЫЕ КОМАНДЫ
 Из-за довольно сложной структуры команд  и  типов  адресации
 СМ-4,  синтаксис  операторов,  порождающих машинные команды,
 весьма разнообразен.



                            - 12 -










 11.1.   Адреса  исходных  данных  и  результатов  выполнения
 команд
 Синтаксис адресов исходных данных и  результатов  выполнения
 команд  одинаков. Каждый из них должен иметь одну из следую-
 щих форм, где reg - символ регистра,  а  expr  -  какое-либо
 выражение.

     Синтаксис   к-во   режим
                 слов   адресации
     reg          0     00+reg
     (reg)+       0     20+reg
     -(reg)       0     40+reg
     expr(reg)    1     60+reg
     (reg)        0     10+reg
     *reg         0     10+reg
     *(reg)+      0     30+reg
     *-(reg)      0     50+reg
     *(reg)       1     70+reg
     *expr(reg)   1     70+reg
     expr         1     67
     $expr        1     27
     *expr        1     77
     *$expr       1     37

 колонка к-во слов содержит количество  порождаемых  адресных
 слов.  Колонка  режим  адресации  содержит  восьмеричный код
 режима адресации.  Обратите внимание: режим *reg  эквивален-
 тен (reg); *(reg) порождает индексирующее слово, а именно 0;
 адреса, состоящие только из одного выражения, ассемблируются
 как  ссылки  относительно  счетчика  команд рс независимо от
 типа выражения. Для того, чтобы сделать  ссылку  абсолютной,
 используется  форма  *$  expr,  однако  дальнейшая косвенная
 адресация невозможна.

 11.2.  Простые машинные команды
 Следующие команды определяются как абсолютные символы:

     clc    sec
     clv    sen
     clz    sev
     cln    sez

 и, таким образом, не требуют никакого  специального  синтак-
 сиса. Аппаратные средства СМ-4 позволяют объединять вместе с
 помощью операции или несколько команд  класса  очистить  или
 несколько  команд класса установить. Это может быть выражено
 следующим образом:

     clc|clv






                            - 13 -










 11.3.  Переходы
 Команды перехода в качестве  операнда  принимают  выражение.
 Оно  должно  находиться  в  том же сегменте, что и ссылки на
 него. Оно не может быть неопределенным внешним и его  значе-
 ние  не  может более чем на 254 байта отличаться от текущего
 положения счетчика адреса.

     br      blos
     bne     bvc
     beg     bvs
     bge     bhis
     blt     bec   (=bcc)
     bgt     bcc
     ble     blo
     bpl     bcs
     bmi     bes   (=bcs)
     bhi

 Команды bes (переход при ошибке) и bec (переход при отсутст-
 вии  ошибки) предназначены для проверки бита ошибки, возвра-
 щаемого после обращения к системе, то  есть  на  самом  деле
 бита c.

 11.4.  Расширенные команды перехода
 За следующими символами должно следовать  выражение,  предс-
 тавляющее  адрес  из  того  же сегмента, в котором находится
 ".". Если  адрес  перехода  достаточно  близок,  порождается
 команда типа branch, если адрес слишком далеко, используется
 команда jmp:

     jbr     jlos
     jne     jvc
     jeg     jvs
     jge     jhis
     jlt     jec
     jgt     jcc
     jle     jlo
     jpl     jcs
     jmi     jes
     jhi


 11.5.  Команды с одним операндом
 Следующие  символы  -  это  имена  однооперандных   машинных
 команд:

     clr  clrb  com  comb  inc  incb
     dec  decb  neg  negb  adc  adcb  sbc  sbcb  ror
     rorb  rol  rolb  asr  asrb  asl  aslb  jmp  swab
     tst  tstb





                            - 14 -










 11.6.  Команды с двумя операндами
 Следующие команды  принимают  в  качестве  операндов  адреса
 исходного  данного  и  результата  общего  вида, разделенные
 запятой:

     mov  movb  cmp  cmpb  bit  bitb  bic  bicb  bis
     bisb  add  sub


 11.7.  Разные команды
 Синтаксис следующих команд  более  специальный.   Здесь  reg
 обозначает  имя  регистра, src и dst - адреса исходного дан-
 ного и результата общего вида, а expr - выражение:

     jsr  reg, dst
     rts  reg
     sys  expr
     ash  src, reg (=als)
     ashc src, reg (=alsc)
     mul  src, reg (=mpy)
     div  src, reg (=dvd)
     xor  reg, dst
     sxt  dst
     mark expr
     sob  reg, expr

 sys - это другое имя для команды trap. Оно используется  при
 кодировани  обращений  к  системе.   Значение  его  операнда
 должно помещаться в  6  битов.   Выражение  в  команде  mark
 должно  помещаться в 6 битов, а в команде sob - быть из того
 же сегмента, что и ".", не должно быть внешним  неопределен-
 ным, должно быть меньше "." и находиться не далее, чем в 510
 байтах от ".".

 11.8.  Команды процессора с плавающей точкой
 Определяются следующие команды с плавающей  точкой,  имеющие
 такой синтаксис:


















                            - 15 -










     cfce
     setf
     setd
     seti
     setl
     clrf  fdst
     ncgf  fdst
     absf  fdst
     tstf  fsrc
     movf  fsrc, freg  (=ldf)
     movf  freg, fdst  (=stf)
     movif src,  freg  (=ldcif)
     movfi freg, dst  (=stcfi)
     movof fsrc, freg  (=ldcdf)
     movfo freg, fdstr (=stcfd)
     movie src,  freg  (=ldexp)
     movei freg, dst   (=stexp)
     addf  fsrc, freg
     subf  fsrc, freg
     mulf  fsrc, freg
     divi  fsrc, freg
     cmpf  fsrc, freg
     modf  fsrc, freg
     ldfps src
     stfps dst
     stst  dst

 fsre,  fdst  и  freg  обозначают  адрес  исходного  данного,
 результата  и регистр с плавающей точкой соответственно.  Их
 синтаксис идентичен синтаксису соответствующих  элементов  с
 фиксированной  точкой, однако следует обратить внимание, что
 freg может быть лишь плавающим регистром с номером от  0  до
 3.

      Имена некоторых операций изменены для того, чтобы  дос-
 тичь  аналогии с соответствующими операциями с фиксированной
 точкой. Единственно необычной является команда movf, которая
 превращается  либо  в stf, либо в ldf в зависимости от того,
 является ли первый операнд регистром. Надо заметить, что ldf
 устанавливает признаки условий для операций с плавающей точ-
 кой, а stf - нет.

 12.  СИМВОЛ ..
 Символ ".." - это счетчик перемещения. Перед тем, как каждое
 порожденное  ассемблером  слово  попадает  в выходной поток,
 текущее значение этого символа прибавляется к нему, если это
 слово  ссылается  на  ячейку  в текстовом сегменте, сегменте
 данных или сегменте bss. Если выходное слово является  адре-
 суемым  относительно счетчика команд рс словом, которое ссы-
 лается на абсолютную ячейку, то из него вычитается  значение
 ".."




                            - 16 -










      Таким образом,  значение  ".."  можно  считать  адресом
 начальной точки программы.

      Начальное значение символа ".." равно нулю и его  можно
 изменить с помощью операции присваивания

      Такого рода действия иногда необходимы.  Однако  риско-
 ванно  было  бы менять значение ".." посреди ассемблируемого
 модуля или поступать так с программой, которая  потом  будет
 загружаться  загрузчиком,  имеющим собственные предположения
 относительно "..".

 13.  ОБРАЩЕНИЯ К СИСТЕМЕ
 Имена операторов обращения к  системе  не  являются  заранее
 опрeделенными. Их можно найти в файле

     /usr/include/sys.s


 14.  ДИАГНОСТИКА
 Если входной файл не может быть прочитан, его имя, за  кото-
 рым  следует знак вопроса, выводится и ассемблирование прек-
 ращается. Если обнаружена синтаксическая  или  семантическая
 ошибка,  печатается  признак  ошибки,  состоящий  из  одного
 знака, номер строки и имя входного файла, в котором встрети-
 лась  ошибка.  Ошибки, обнаруженные на первом проходе, вызы-
 вают отмену второго прохода.  Возможны следующие ошибки:

         )    - неправильная расстановка скобок;

         ]    - неправильная расстановка скобок;

         >    - строка неверно заканчивается;

         *    - неправильное применение косвенной адресации;

         .    - неверное присвоение значения символу ".";

         a    - ошибка адресации;

         b    - адрес перехода нечетен или слишком удален;

         e    - ошибка в выражении;

         f    - ошибка в локальном символе типа 'f' или 'b';

         g    - неизвестный  ассемблеру   знак   во   входном
                потоке;

         i    - посредине  условного   оператора   встретился
                конец файла;




                            - 17 -










         m    - неоднократно определенный символ  в  качестве
                метки;

         o    - слово размещается по нечетному адресу;

         p    - ошибка в фазе - значение "." различно на пер-
                вом и втором проходе;

         r    - ошибка перемещения;

         u    - неопределенный символ;

         x    - синтаксическая ошибка.










































                            - 18 -










                          СОДЕРЖАНИЕ



     АННОТАЦИЯ .........................................    2

 1.  ВВЕДЕНИЕ ..........................................    3

 2.  ВЫЗОВ КОМПИЛЯТОРА .................................    3

 3.  ЛЕКСЕМЫ ...........................................    3
 3.1.  Идентификаторы ..................................    3
 3.2.  Временные символы ...............................    3
 3.3.  Константы .......................................    4
 3.4.  Операции ........................................    4

 4.  ПРОБЕЛЫ ...........................................    4

 5.  КОММЕНТАРИИ .......................................    4

 6.  СЕГМЕНТЫ ..........................................    4

 7.  СЧЕТЧИК АДРЕСА ....................................    5

 8.  ОПЕРАТОРЫ И МЕТКИ .................................    5
 8.1.  Метки ...........................................    5
 8.2.  Пустые операторы ................................    6
 8.3.  Операторы-выражения .............................    6
 8.4.  Операторы присваивания ..........................    6
 8.5.  Операторы-строки ................................    7
 8.6.  Операторы с ключевыми словами ...................    7

 9.  ВЫРАЖЕНИЯ .........................................    7
 9.1.  Операции в выражениях ...........................    7
 9.2.  Типы выражений ..................................    8
 9.3.  Присваивание типов при вычислении выражений .....   10

 10. ПСЕВДООПЕРАЦИИ ....................................   11

 11. МАШИННЫЕ КОМАНДЫ ..................................   12
 11.1. Адреса исходных данных и  результатов  выполнения
       команд ..........................................   13
 11.2. Простые машинные команды ........................   13
 11.3. Переходы ........................................   14
 11.4. Расширенные команды перехода ....................   14
 11.5. Команды с одним операндом .......................   14
 11.6. Команды с двумя операндами ......................   15
 11.7. Разные команды ..................................   15
 11.8. Команды процессора с плавающей точкой ...........   15

 12. СИМВОЛ ..  ........................................   16

 13. ОБРАЩЕНИЯ К СИСТЕМЕ ...............................   17


                            - 19 -










 14. ДИАГНОСТИКА .......................................   17






















































                            - 20 -



