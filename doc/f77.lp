
            дддд   ееееее   м     м    oooo     сссс
           д   д   е        мм   мм   o    o   с    с
          д    д   е        м м м м   o    o   с    с
          д    д   еееее    м  м  м   o    o   с
          д    д   е        м     м   o    o   с
          д    д   е        м     м   o    o   с    с
         дддддддд  ееееее   м     м    oooo     сссс



          демосдемосдемосдемосдемосдемосдемосдемосде
          емосдемосдемосдемосдемосдемосдемосдемосдем
          мо                                      мо
          ос                                      ос
          сд        ОПЕРАЦИОННАЯ СИСТЕМА          сд
          де                                      де
          ем               ДЕМОС                  ем
          мо                                      мо
          ос                                      ос
          сд                                      сд
          де             Версия 1.0               де
          ем                                      ем
          мо                                      мо
          сдемосдемосдемосдемосдемосдемосдемосдемосд
          демосдемосдемосдемосдемосдемосдемосдемосде







                 ОПИСАНИЕ ЯЗЫКА ФОРТРАН-77







                  Руднев Алексей Петрович












                       МОСКВА - 1985









                                                           1













   Данный документ содержит описание языка  программирования
Фортран-77   системы   ДЕМОС.   Рассматриваются  элементы  и
конструкции языка, функциональное  назначение  операторов  и
структура программы.

















































                                                           1




                        1. ВВЕДЕНИЕ


   Данный документ предназначен для  ознакомления  с  языком
программирования Фортран-77. В документе описываются как об-
щие характеристики языка, закрепленные в международном стан-
дарте на язык Фортран-77, так и особенности языка Фортран-77
операционной системы ДЕМОС. В тексте абзацы,  относящиеся  к
версии языка в ОС ДЕМОС, выделены, например:


   В операционной системе ДЕМОС программы на Фортране-77   |
могут  использоваться  совместно  с программами на языке   |
Си.                                                        |


   Более подробное описание особенностей реализации языка  в
операционной  системе  приводится в руководстве программиста
[1].

   По языку Фортран-77 имеется обширная литература. При под-
готовке  данного  документа широко использовалась книга [2],
можно рекомендовать для чтения также описание  языка  Форекс
на  ЭВМ  БЭСМ-6  [3]. При изучении Фортрана-77 полезно также
иметь описание языков Фортран (например, [4]), и Си [5].




































2




           2.  ОБЩИЕ СВЕДЕНИЯ О ЯЗЫКЕ ФОРТРАН-77


   Фортран - это язык программирования,  который  разрабаты-
вался   для  приложений,  связанных  с  обработкой  числовых
данных, текстов и файлов.

   Язык  Фортран-77  является  дальнейшим  развитием   языка
Фортран.  За незначительным исключением, он не исключает ис-
пользования программ на старом диалекте Фортрана, но  значи-
тельно расширяет возможности языка в следующих направлениях:
ввод/вывод, средства описания данных, снятие ряда  ограниче-
ний,  параметризация  констант, новые операторы управления и
ряд разнообразных расширений. Ниже перечислены основные  от-
личия  Фортрана-77 от языка Фортран (по стандарту 1966 года,
ISO/P 1539-72).


   2.1. Ввод-вывод


   При вводе-выводе обеспечивается:

   - работа с файлами последовательного и прямого доступа;

   - передача данных в свободном формате;

   - внутренняя передача данных (из одной области  оператив-
     ной памяти в другую);

   - инструкции для открытия ("open") и  закрытия  ("close")
     файлов,  а также для получения информации о состоянии и
     свойствах файла ("inquire");

   - обмен данными со стандартным системным устройством  без
     явного указания номера канала;

   - спецификации формата, управляющие  табуляцией,  выводом
     знака и вводом пробелов.


   2.2. Описание данных


   Описание данных включает:

   - описание текстовых цепочек фиксированной длины, над ко-
     торыми  допускаются  операции  конкатенации, вычисление
     длины, взятие подцепочки, присваивания и операции отно-
     шений;

   - описание символических констант;

   - сохранение значений переменных и массивов от одного об-
     ращения к подпрограмме до следующего;

   - указание имени главной программы;




                                                           3

   - указание правила для неявного определения типов  (опре-
     деление типа по первой букве типа);

   - использование отрицательных,  нулевых  и  положительных
     выражений  -  констант  целого  типа в описаниях границ
     мас- сивов, допускается от одного до семи измерений;

   - использование имен массивов, текстовых подцепочек и не-
     явных циклов в инструкции "data";

   - использование имен массивов и  текстовых  подцепочек  в
     инструкции "equivalence".


   2.3. Описание подпрограмм


   Описание подпрограмм включает:

   - указание нескольких точек входа в подпрограмму;

   - указание нескольких точек возврата из подпрограмм;

   - различие внешних и  стандартных  (встроенных)  подпрог-
     рамм;

   - указание универсальных имен для стандартных функций;

   - описание функций без аргументов;

   - описание нескольких модулей "block data".

   Употребление целых  выражений  вместо  целых  значений  в
конструкциях:

   - индексы массивов;

   - управляющие параметры цикла "do" и неявного цикла;

   - номера меток в вычислительных инструкциях "goto";

   - номера каналов в  инструкциях  "backspace",  "endfile",
     "rewind".


   2.4. Прочие возможности


   К прочим возможностям относятся:

   - циклы "do" и неявные циклы, которые могут выполняться 0
     раз и иметь отрицательный шаг;

   - использование метки формата в инструкции "assign";

   - указание последовательности десятичных цифр или тексто-
     вой цепочки в инструкциях "pause" и "stop";

   - использование имени модуля "block  data"  в  инструкции
     "external";




4

   - использование выражений двойной точности, целого и  ве-
     щественного  типов  в качестве параметров циклов "do" и
     неявных циклов в списках ввода-вывода;

   - инструкции   "if-структурная",   "elseif",   "else"   и
     "endif",  позволяющие программировать обработку условий
     без использования меток.



   - возможность отменять неявное определение типов  пе-   |
     ременных при помощи оператора "implicit undefined";   |

   - управление размещением переменных в памяти при  по-   |
     мощи описателей "static" и "automatic";               |

   - оператор вставки файла "include".                     |















































                                                           5




                  3. СПОСОБ ОПИСАНИЯ ЯЗЫКА


   Для описания языка Фортран-77 используются синтаксические
обозначения - набор метаязыковых обозначений и символов.

   Металингвистическая переменная служит для обозначения не-
которого  понятия языка. Она может представлять собой после-
довательность прописных букв, между которыми может быть раз-
делитель "подчеркивание"; в конце может иметься индекс.

   Металингвистическая связка служит для  обозначения  самой
себя и записывается в виде последовательности строчных букв,
знаков препинания и специальных литер. Например, в конструк-
ции:

                        assign S to I


ключевые слова assign и to являются связками, S и I -  пере-
менными.

   Пара скобок [ ] указывает на то, что заключенные в скобки
синтаксические элементы могут быть опущены.

   Символ повторения - три точки  -  означает,  что  стоящий
перед  ними  необязательный элемент может быть повторен нуль
или более раз подряд.

   Синтаксический элемент - последовательность  металингвис-
тических переменных и связок, заключенных в скобки.

   Кавычками в тексте выделяются названия операторов и  клю-
чевые слова, например: инструкция "data".


   3.1. Основные понятия языка Фортран-77


Последовательность
   - множество элементов, упорядоченное  путем  установления
     взаимно  однозначного соответствия с числами 1,2,...,n.
     Последовательность может быть пустой, т.е. не содержать
     ни одного элемента.

Список
   - непустая последовательность  синтаксических  элементов,
     разделенных  запятыми. Синтаксические элементы в списке
     называются членами списка.

Отрезок памяти
   - последовательность единиц памяти.

Единица памяти
   - об'ем памяти, необходимой для хранения элемента  данных
     определенного  класса.  В числовой единице памяти может
     храниться элемент данного целого, вещественного или ло-
     гического  типа.  В текстовой единице памяти может хра-
     ниться  одна  литера  некоторого  текстового   элемента


6

     данных.

Ассоциирование
   - идентификация одного и того же  об'екта  в  программной
     компоненте  или в исполняемой программе при помощи раз-
     личных имен. Оно может появиться в результате использо-
     вания    общей    памяти,   либо   действия   оператора
     "equivalence", либо при подстановке  фактических  пара-
     метров.

Статус определенности
   - в любой момент времени каждая  переменная,  массив  или
     подцепочка  находятся  в одном из состояний "определен"
     или "неопределен".

Выбор значения переменной
   - выбором значения переменной, массива или подцепочки на-
     зывается  появление  этого  об'екта в такой инструкции,
     при выполнении которой используется  значение  об'екта.
     При  выборке  значение об'екта доступно для использова-
     ния, но не изменяется. Переменная, массив или подцепоч-
     ка должны быть определены в момент выбора их значения.










































                                                           7




         4.  ЭЛЕМЕНТЫ И ОСНОВНЫЕ КОНСТРУКЦИИ ЯЗЫКА



   4.1. Набор символов Фортрана-77


   Алфавит Фортрана-77 состоит из букв, цифр  и  специальных
литер. Для записи программ на языке Фортран-77 используются:

   - Буквы латинского алфавита от a до z;

   - Цифры от "0" до "9".

   Следующие специальные литеры:

        пробел;
     =  знак равенства;
     +  плюс;
     -  минус;
     *  звездочка;
     /  наклонная черта;
     (  левая скобка;
     )  правая скобка;
     ,  запятая;
     .  Десятичная точка;
     $ денежный знак;
     '  кавычка;
     :  двоеточие.

   Специальные литералы, отличные от указанных  выше,  могут
встретиться только в текстовых литералах, холлеритовских или
в комментариях.

   Специальная литера может быть, например, знаком операции,
литерой  в  текстовом литерале, входить в числовую константу
или использоваться для других целей в языке Фортран-77.


   В Фортране-77 ОС ДЕМОС могут использоваться как  про-   |
писные,   так  и  строчные  буквы  латинского  алфавита.   |
Существует два режима работы компилятора: в  стандартном   |
режиме  прописные латинские буквы в идентификаторах счи-   |
таются эквивалентными соответствующим  строчным  буквам;   |
можно задать режим, в котором прописные и строчные буквы   |
различаются, в этом случае все ключевые слова должны за-   |
писываться строчными буквами.                              |

   Русские  буквы  могут  использоваться   в   текстовых   |
константах и в форматах.                                   |











8

   4.1.1. Отношение следования


   Отношение следования - это отношение,  которое  позволяет
упорядочивать  текстовые  цепочки.  Отношение следования для
букв и для цифр следующее: 'пробел', цифры '0'-'9',  пропис-
ные  буквы 'A'-'Z', строчные буквы 'a'-'z'. Отношение следо-
вания для специальных литер не устанавливается.


   4.1.2. Пробелы и символы табуляции


   В инструкциях Фортрана-77 пробел  является незначащей ли-
терой  и учитывается только в текстовых литералах и холлери-
товских константах; в остальных случаях  пробелы  можно  ис-
пользовать без ограничений для улучшения внешнего вида прог-
раммы. Особым образом используется  пробел  для  обеспечения
необходимого  формата  инструкции. Например, колонки 1-5 на-
чальной строки инструкции должны содержать либо метку,  либо
только пробелы.


   Наряду с пробелом  для  улучшения  читаемости  текста   |
можно  использовать  символ табуляции; при печати текста   |
символ табуляции заполняет пробелами колонки от  текущей   |
до  ближайшей колонки с номером, кратным 8. Символ табу-   |
ляции в     1-5     колонках означает также,  что  длина   |
текущей строки не ограничена 72 символами.                 |



   4.2. Идентификаторы


   Имя - это последовательность литер.  Ключевые  слова  ис-
пользуются  для  идентифиткации  инструкций  языка или в ка-
честве разделителей. Имена и ключевые слова вместе называют-
ся идентификаторами.


   4.2.1. Имена


   Имя - это последовательность литер,  которой  программист
обозначает  такие  об'екты  своей программы, как переменная,
массив, программная компонента, помеченный общий  блок.  Имя
должно  содержать  от  1  до  6 букв или цифр и начинаться с
буквы.


   4.2.2. Ключевые слова


   Ключевое слово - это  последовательность  литер,  которая
используется  либо  для  идентификации  инструкций  в  языке
Фортран-77, либо в качестве разделителей внутри  инструкций.
Примерами  ключевых слов, идентифицирующих инструкцию, явля-
ются слова "real", "format" и "read". Два примера разделите-
лей - слова "to" и "then".




                                                           9

   Ключевые слова записываются строчными  буквами,  если   |
трансляция  проводится  в  режиме различения прописных и   |
строчных букв.                                             |



   4.3. Структура инструкции


   Программная компонента представляет  собой  упорядоченную
совокупность  строк. Строка состоит из 72 текстовых позиций,
пронумерованных последовательно слева направо числами  от  1
до 72 и называемых колонками. Различаются строки комментари-
ев, начальные строки и строки продолжения.


   Допускаются длинные строки (больше 72 символов).        |



   4.3.1. Строки комментариев


   Строка комментария определяется по  одному  из  следующих
признаков:

1)  в первой колонке стоит буква "c" или "C";

2)  в первой колонке стоит звездочка;

3)  строка состоит из пробелов.

   Строки комментариев с буквой "с" ("C") или  звездочкой  в
колонке  1  могут  содержать произвольную последовательность
литер.

   Строки комментариев могут располагаться  в   любом  месте
программной  компоненты,  и не влияют на программу. Одна или
более строк комментариев могут быть  помещены  перед  первой
строкой  программной  компоненты,  между  двумя инструкциями
Фортрана-77, между начальной строкой и первой  строкой  про-
должения или между двумя строками продолжения.


   Комментарии могут также записываться в конце строк  с   |
инструкциями, для этого в конце инструкции перед коммен-   |
тарием ставится  признак  комментария  "!".  Комментарии   |
могут  записываться  также в 73-80 колонках строки (если   |
только строка не содержит признаков  "длинного"  формата   |
строки:  символов  табуляции  в 1-5 позициях или символа   |
"&" в 1 позиции).                                          |



   4.3.2. Начальная  строка


   Первая, и, возможно, единственная строка, в которой  рас-
полагается инструкция языка Фортран-77, называется начальной
строкой. Колонки с первой по пятую начальной  строки  должны
содержать либо только пробелы, либо метку инструкции. Колон-
ка 6 должна  быть  либо  пустой,  либо  содержать  цифру  0.


10

Инструкция  языка  Фортран-77 или ее часть размещается в ко-
лонках с 7-й по 72-ю. Оставшиеся колонки, если таковые  име-
ются,  могут быть либо пустыми, либо могут служить для иден-
тификации и содержать порядковый номер инструкции.


   Вместо группы пробелов в колонках 1-5 может быть  за-   |
писан  символ  табуляции.  В этом случае длина строки не   |
ограничивается 72 символами, а может быть  произвольной;   |
инструкция языка начинается сразу за символом табуляции.   |



   4.3.3. Строки продолжения


   Строка продолжения содержит продолжение инструкции  языка
Фортран-77 и имеет следующие признаки:

1)  колонки с 1-й по 5-ю должны содержать пробелы;

2)  колонка 6 содержит литеру, отличную от нуля и пробела.

   Колонка 6 часто используется для нумерации строк  продол-
жения.  Колонки  с  7-й по 72-ю в строке продолжения, так же
как и в начальной строке, содержат некоторую часть  инструк-
ции  языка, а остальные колонки, если таковые имеются, могут
быть либо пустыми, либо могут использоваться для идентифика-
ции и содержать порядковый номер инструкции.


   В качестве признака продолжения может также использо-   |
ваться  символ "&" в первой колонке; в этом случае длина   |
строки продолжения не ограничена 72 символами.             |



   4.3.4. Инструкции языка Фортран-77


   Инструкция языка Фортран-77, располагается в  колонках  с
7-й  по 72-ю начальной строки и в строках продолжения, кото-
рых не должно быть более 19. Таким образом, инструкция может
иметь  длину до 1320, т.е. 20*66, литер. Но в это максималь-
ное число входят также пробелы, которые могут встречаться  в
записи инструкций и игнорируются процессором.


   В случае строк произвольной длины инструкция  начина-   |
ется  сразу после символа табуляции (или символа "&" для   |
строк продолжения) и продолжается до конца строки. Общая   |
длина  инструкции в этом случае не должна превышать 1320   |
символов.                                                  |


   Каждая инструкция языка  должна начинаться с новой  стро-
ки, если только она не входит в состав логической инструкции
"if", структура которой всегда включает некоторую инструкцию
Фортрана-77.

   Инструкция "end" обозначает конец программной компоненты.



                                                          11

   4.3.5. Метки


   Метки являются средством отметить какую  либо  инструкцию
языка  с  тем, чтобы на нее можно было сослаться в некоторой
другой инструкции. Метка помещается в колонки с 1-й  по  5-ю
начальной  строки  и  содержит от 1 до 5 цифр, из которых по
крайней мере одна должна отличаться от нуля.

   Метка может располагаться в любых колонках с номерами  от
1  до 5. Пробелы и старшие нули игнорируются при определении
значения метки.


   Вместо  группы  пробелов  между  меткой   и   началом   |
инструкции  (в  колонках  1-5) может записываться символ   |
табуляции; в этом случае строка может быть  произвольной   |
длины (точнее, до 1320 символов).                          |


   Областью действия метки является программная  компонента,
в  которой  встретилась метка. Нельзя отмечать метками, име-
ющимиодинаковое значение, несколько инструкций. В инструкции
Фортрана-77  метка  необязательна. Но только на инструкцию с
меткой можно сослаться в какой-либо другой инструкции языка.
Инструкция может быть помечена, даже если на нее нет ссылок.


   4.3.6. Форма инструкции в Фортране-77


   Все инструкции, за исключением инструкции присваивания  и
функции-формулы,  начинаются с ключевого слова. По ключевому
слову процессор распознает тип инструкции.  Например:

       инструкция          пояснение
 real apple(50)      ключевое слово real
 goto 400            ключевое слово goto
 if(r**2-х.lt.eps)   ключевые слова if и
 return              return
 r=.5*(х/r+r)        ключевого слова нет;
                     это инструкция
                     присваивания


   4.3.7. Программная компонента


   Инструкции в Фортране-77 группируются в программные  ком-
поненты.  Программная компонента - это либо главная програм-
ма, либо подпрограмма. Рамками программной компоненты  огра-
ничивается  область  действия имен и меток, так что компиля-
тор, обрабатывая  одну  программную  компоненту,  ничего  не
будет знать об об'ектах, описанных в другой программной ком-
поненте, если только это не предусмотрено явно.

   Программная компонента представляет собой  последователь-
ность  инструкций   и,  возможно,  комментариев. Программная
компонента всегда заканчивается инструкцией end.





12

   4.3.8. Главная программа


   Главная программа - это программная  компонента,  которой
передается  управление,  когда  процессор начинает выполнять
исполняемую программу. Главная программа отличается от  дру-
гих программных компонент тем, что она начинается с инструк-
ции "program", либо тем, что она  начинается  с  инструкции,
отличной от "function", "subroutine" или "block data".


   4.3.9. Подпрограммы


   Подпрограмма - это программная компонента, которой  пере-
дается  управление,  когда  в главной программе или в другой
подпрограмме встречается инструкция, содержащая обращение  к
функции, или вызов данной подпрограммы. Подпрограмма распоз-
нается по первой инструкции, которая должна быть инструкцией
"function"   или   "subroutine".   Инструкции  "function"  и
"subroutine" описывают соответственно подпрограмму-функцию и
подпрограмму.


   4.3.10. Процедуры


   Сегмент программы, выполняющей некоторое действие,  назы-
вается процедурой. В Фортране-77 различаются три вида проце-
дур:  внешние  процедуры,  функции-формулы   и   стандартные
функции.

Внешняя процедура - это функция  или  подпрограмма,  которая
обрабатывается (т.е. компилируется или интерпретируется) не-
зависимо от программных компонент, в которых есть  обращения
к ней.

Функция-формула - это одна инструкция,  содержащая  описание
функции,  которое обрабатывается в рамках программной компо-
ненты, где встретилась эта инструкция.

Стандартная функция - это подпрограмма вычисления  некоторой
функции,  например квадратного корня или синуса, которая оп-
ределяется как составная часть языка Фортран-77.

   Внешняя  процедура  может  быть  написана  не  только  на
Фортране.  Данное  определение  допускает обращения из прог-
раммных компонент, написанных на Фортране,  к  подпрограммам
написанным  на  языке  ассемблера или на других языках более
высокого уровня.


   Обеспечивается возможность вызывать  из  программ  на   |
Фортране-77  программы,  написанные  на  языках Си и ас-   |
семблера, и наоборот, вызывать программы на Фортране  из   |
Си - программ.                                             |








                                                          13

   4.3.11. Программные компоненты block data


   Программную компоненту, первой инструкцией которой  явля-
ется инструкция "block data", называют обычно "подпрограммой
данных". Подпрограмма данных не может содержать  исполняемых
инструкций и служит для инициализации общей памяти.


   4.3.12. Исполняемая программа


   Исполняемая программа состоит из главной программы и нес-
кольких  (возможно, ни одной) внешних процедур и подпрограмм
данных. Исполняемая программа не может содержать более одной
главной  программы,  но  может  содержать по одной или более
компонент следующих видов:

   - функция;

   - подпрограмма;

   - подпрограмма данных;

   - внешняя процедура на другом языке.

   Главная программа исполняемой программы не  может  содер-
жать  инструкций  "entry" или "return". Выполнение программы
заканчивается, если в  какой-нибудь  программной  компоненте
выполнится  инструкция "stop" или если выполнится инструкция
"end" в главной программе.


   4.3.13. Порядок инструкций в программной компоненте


   При написании программы на Фортран-77  следует  учитывать
что:

1)  строки комментариев можно помещать в любом  месте  прог-
    раммы, но до инструкции "end";

2)  инструкция  "program",  "function",   "subroutine"   или
    "blockdata"  должна  быть первой инструкцией программной
    компоненты;

3)  инструкции "parameter" могут чередоваться с инструкциями
    "implicit"  и  другими  инструкциями описания, но должны
    предшествовать инструкциям "data", т.к. указанные в  ней
    значения присваиваются переменным перед началом выполне-
    ния программной компоненты;

4)  функции-формулы должны располагаться перед  исполняемыми
    инструкциями;

5)  инструкция "format" может помещаться в любом месте прог-
    раммной компоненты;

6)  инструкция "entry" может помещаться в любом месте  прог-
    раммной компоненты, но не в теле цикла и не в промежутке
    между  инструкцией  "if структурная"  и  соответствующей
    инструкцией "end if";


14


7)  все описательные инструкции (т.е. инструкции  "iмрliсit"
    и  другие  инструкции описания) должны помещаться раньше
    инструкций "data", функций-формул и исполняемых инструк-
    ций;

8)  все инструкции-формулы должны предшествовать первой  ис-
    полняемой инструкции;

9)  инструкции "data" можно размещать где угодно,  но  после
    всех   инструкций   "parameter",   "implicit"  и  других
    инструкций описания, и перед исполняемыми инструкциями;

10) инструкции "implicit" должны предшествовать всем  другим
    инструкциям    описания,   за   исключением   инструкций
    "parameter";

11) инструкция описания (т.е. инструкция "implicit" или дру-
    гая  инструкция  описания), содержащая описание типа для
    имени, которое будет  использовано  как  имя  параметра,
    должна  располагаться раньше инструкции "parameter", со-
    держащей описание этого параметра;

12) инструкция "parameter", содержащая  описание  некоторого
    параметра,  должна располагаться раньше всех инструкций,
    в которых встречается (используется) имя этого  парамет-
    ра.

   Данные правила применимы лишь к тем программным компонен-
там, в которых допускаются и реально используются инструкции
указанных видов.

                                                  Таблица 1.
               Допустимый порядок инструкций
                       в Фортране-77

         _________________________________________
         |         инстр. program, function,     |
         |         subroutine, block data        |
         |_______________________________________|
         |строки | инстр.   | инстр.   | инстр.  |
         |ком-   | format и | parameter| implicit|
         |мен-   | entry    |__________|_________|
         |тари-  |          |  инстр.  | функции |
         |ев     |          |  data    | формулы |
         |       |__________|__________|_________|
         |       |            исполняемые        |
         |       |            инструкции         |
         |_______|_______________________________|
         |      инструкция end                   |
         |_______________________________________|


   4.4. Оператор вставки текста



   В Фортране-77 ОС ДЕМОС  введен  оператор  подстановки   |
текста:                                                    |





                                                          15

      include 'ФАЙЛ'                                       |

где ФАЙЛ - это имя файла ОС  ДЕМОС.  Оператор  "include"   |
заменяется  на  содержимое файла 'ФАЙЛ' и может стоять в   |
любом месте программы. Как правило, эта возможность  ис-   |
пользуется для подстановки описаний общих переменных или   |
для определения параметров. Оператор  позволяет  собрать   |
часть  описаний,  повторяющуюся в нескольких программных   |
компонентах, в один файл, а не размножать ее по несколь-   |
ким файлам с текстами программ.                            |






















































16




                     5. ЭЛЕМЕНТЫ ДАННЫХ



   5.1. Типы данных


   В Фортране-77 допускаются явно шесть типов данных:

   - целый;

   - вещественный;

   - двойной точности;

   - комплексный;

   - логический;

   - текстовый.


   В ОС ДЕМОС имеются дополнительные типы данных:          |

   - короткий целый "integer*2";                           |

   - комплексный двойной точности "double complex";        |

   - короткий логический "logical*1".                      |


Кроме того, в инструкциях "format" можно использовать холле-
ритовский тип данных.

   Типом  обладают  об'екты  трех  видов:  константы,  имена
данных  и  процедуры. Тип константы определяется способом ее
написания.

   Тип имени данных определяется либо явно в инструкции опи-
сания типа, либо неявно одним из следующих способов:

   - по первой букве идентификатора. Если первая буква - од-
     на  из букв i, j, к, l, m или n, то тип - целый. В про-
     тивном случае тип вещественный;

   - с помощью инструкции "implicit", которая изменяет  пра-
     вило неявного определения типа по умолчанию.

   Тип определяется неявно лишь в  тех  случаях,  когда  от-
сутствует явное описание типа. Имя данных служит для обозна-
чения переменной, массива  или  параметра.  Параметр  -  это
константа, которой при помощи инструкции "parameter" присво-
ено имя.

   Тип могут иметь процедуры трех  видов:  внешняя  функция,
функция-формула и стандартная функция. Типом внешней функции
или функции-формулы определяется тип элемента данных,  полу-
чающегося  в результате обращения к функции в каком-либо вы-
ражении. Тип внешней функции или функции-формулы определяет-


                                                          17

ся  типом  ее  имени,  который может быть описан либо явно в
инструкции описания типа, либо неявно по первой букве имени,
если  нет  явного  описания  типа. Так же, как имена данных,
имена функций, начинающиеся с букв i, j, к, l, м или  n,  по
умолчанию  имеют  целый  тип.  Имена,  начинающиеся с других
букв, по умолчанию имеют вещественный тип. Для  того,  чтобы
изменить  это  правило определения типов по умолчанию, можно
воспользоваться инструкцией "implicit". Явное описание  типа
внешней   функции   может  содержаться  также  в  инструкции
"function".

   Стандартные функции имеют универсальные имена, которые не
требуют  ни  явного, ни неявного определения типа. Тип стан-
дартной функции определяется типом ее аргументов. Тип  стан-
дартной  функции  описывать необязательно, но явное описание
ее типа допускается.

   В целом понятие типа применимо к тем  значениям,  которые
могут использоваться в выражениях, т.е. к константам, именам
данных и к функциям. Метка в языке Фортран-77 - это уникаль-
ная целая положительная константа, не имеющая типа.


   Имеется возможность заблокировать  механизм  неявного   |
определения  типа  при запуске компилятора; при этом все   |
не описанные явно переменные получат тип "неопределен".    |



   5.2. Константы и значения


   Константа - это некоторое значение, которое не изменяется
в  процессе  выполнения программы. Константа может принадле-
жать к арифметическому,  логическому  или  текстовому  типу.
Значение  - это элемент данных, связанный с переменной, эле-
ментом массива, обращением к функции или выражением, которые
могут встретиться в процессе выполнения программы. Например,
переменная может быть определена или не определена. Значени-
ем  определенной переменной является элемент данных, который
был ей присвоен в результате выполнения  инструкции  присво-
ения, инициализации данных  или инструкции ввода.

   Способ написания константы (ее внешний вид) определяет  и
ее  значение,  и  ее  тип. При помощи инструкций "parameter"
константе можно присвоить имя, но имя одной константы нельзя
использовать  при формировании другой константы. Встречающи-
еся внутри констант пробелы игнорируются и не влияют на зна-
чения  констант, за исключением текстовых констант, заключа-
емых в кавычки.

   Арифметическая константа может  быть  одного  из  четырех
типов: целого, вещественного, двойной точности и комплексно-
го. Арифметическая константа может быть со  знаком  или  без
знака.  Константа  со  знаком  имеет  в начале знак плюс или
минус и обозначает соответственно положительное или  отрица-
тельное число. Константа без знака не имеет знака в начале и
обозначает положительное число. Константа с возможным знаком
может  быть  без  знака или со знаком. Константы с возможным
знаком могут быть двойной точности, целого  и  вещественного
типов.



18


   Имеется также тип "комплексный двойной точности".       |



   5.2.1. Целые константы


   Элемент данных целого типа есть точное представление  не-
которого  целого  числа.  Об'ектом  целого типа в может быть
константа, параметр, целая переменная, элемент целого масси-
ва,  результат  обращения  к функции или значение выражения.
Элемент данных целого типа занимает  одну  числовую  единицу
памяти в отрезке памяти и может принимать положительное, от-
рицательное или нулевое значение.

   Целая константа может обозначать  положительное,  отрица-
тельное  или  нулевое  значение и записывается в виде знака,
который может  отсутствовать,  и  цепочки  десятичных  цифр,
воспринимаемой  как  десятичное  число. Примеры правильной и
неправильной записи целых констант:

    Правильная запись
    целых констанат

    0
    75
    +230
    -9342605

    Неправильная запись
    целых констант
    54. (содержит десятичную
        точку)
    3,216,193 (содержит запятые
    -2.236 (содержит десятичную
           точку и дробную
           часть)

   Максимальная величина элемента данных целого типа опреде-
ляется размером числовой единицы памяти.


   5.3. Вещественные константы


   Вещественная константа  может  обозначать  положительное,
отрицательное или нулевое значение и записывается в одной из
трех форм:

1)  базовая вещественная константа;

2)  базовая вещественная константа с порядком  вещественного
    числа;

3)  целая константа с порядком вещественного числа.

   Базовая вещественная константа состоит из знака,  который
может  отсутствовать, и цепочки десятичных цифр с десятичной
точкой. Целая константа была определена ранее.  Порядок  ве-
щественного  числа состоит из буквы "e" и целой константы со
знаком или без знака, обозначающей показатель степени  числа


                                                          19

10, на которую умножается константа.

   Значением вещественной константы является значение  базо-
вой  вещественной константы, а если присутствует порядок, то
значение базовой вещественной или целой константы умножается
на  степень числа 10, показатель которой записан после буквы
"e". Вещественная константа  воспринимается  как  десятичное
число.

   Примеры правильной  и  неправильной  записи  вещественных
констант:

 Правильная запись    значения констант
 вещественных
 констант

 -1,5           -1,5
 3е5            +300000 (т.е.3*10**5)
 -7.45е-14      -7.45*10**(-14)
 5.             +5

 Неправильная запись
 вещественных констант

 5         (нет ни точки, ни порядка)
 1,234.5   (содержит запятую)
 .123-3    (отсутсвует обозначение
           порядка е)
 -6.1е     (отсутствует целая константа
           после буквы е)

   Максимальная величина и точность  вещественной  константы
определяются  размером  числовой  единицы  памяти и способом
представления  чисел  в  машине.  Целая  часть  вещественной
константы  может  содержать  цифр  больше, чем это позволяет
точность  приближения  для  соответствующего   вещественного
числа, свойственная данному процессору.


   5.3.1. Константы с двойной точностью


   Элемент данных двойной точности есть некоторое  приближе-
ние  вещественного числа, зависящее, как и для вещественного
типа, от способа представления данных в процессоре. Различие
между вещественными данными и данными двойной  точности сос-
тоит в том, что элемент  данных  двойной  точности  содержит
больше значащих цифр, чем элемент данных вещественного типа.

   К данным типа двойной точности в Фортране-77 могут  отно-
ситься  константа,  параметр,  переменная  двойной точности,
элемент массива  двойной  точности,  результат  обращения  к
функции и значение выражения. Элемент данных двойной точнос-
ти занимает две числовые единицы памяти в отрезке  памяти  и
может  принимать  положительное,  отрицательное  или нулевое
значение.

   Константа двойной точности может  обозначать  положитель-
ное, отрицательное или нулевое значение и записывается в од-
ной из двух форм:




20

1)  базовая вещественная константа, за которой следует поря-
    док числа двойной точности;

2)  целая константа, за которой следует порядок числа  двой-
    ной точности.

   Порядок числа двойной точности состоит из буквы d и целой
константы  со  знаком или без знака, содержащей одну или две
цифры и обозначающей показатель степени числа 10, на которую
умножается константа.

   Значение константы двойной точности равно значению  базо-
вой вещественной или целой константы, умноженному на степень
числа 10, показатель которой записан после буквы d. Констан-
та двойной точности воспринимается как десятичное число.

   Примеры правильной и неправильной записи констант двойной
точности:

    Правильная запись  Значения констант
    констант двойной
    точности

    1d2                +100
 .123456789101112do     +123456789101112
    6.89d-8            +6.89*10**(-8)
    -4.d+16            -4*10**16

    Неправильная
    запись констант
    двойной точности

 -1.2345678910       (отсутствует
                     обозначение порядка)
 .123456789101112ео  (неправильное
                     обозначение  порядка)
 .123,456,789d5      (встречаются запятые)
 .123'456'789d5      (встречаются
                     кавычки)
 7.8912d             (после буквы d
                     нет целой константы)

   Максимальная величина и точность константы  двойной  точ-
ности определяются размером числовой единицы памяти и спосо-
бом  представления  данных  двойной  точности.  Целая  часть
константы  двойной точности может содержать цифр больше, чем
позволяет точность приближения соответствующего вещественно-
го числа в процессоре.


   5.3.2. Комплексные константы


   Элемент данных комплексного типа есть приближение некото-
рого  комплексного числа, зависящее от способа представления
вещественных данных в процессоре. Об'ектом комплексного типа
могут быть константа, параметр, комплексная переменная, эле-
мент комплексного массива, результат обращения к  функции  и
значение выражения. Элемент данных комплексного типа занима-
ет две подряд  стоящие  единицы  памяти  в  отрезке  памяти,
представляющие пару значений вещественного типа. Первая ком-
понента пары представляет действительную часть, а  вторая  -


                                                          21

мнимую часть элемента данных.

   Комплексная константа представляет собой пару  веществен-
ных или целых констант, разделенных запятыми и заключенных в
скобки. Первая константа этой пары обозначает действительную
часть,  а  вторая  -  мнимую часть константы. Каждая из двух
целых или вещественных констант  может  быть  положительной,
отрицательной или нулевой. Примеры правильной и неправильной
записи комплексных констант:

 Правильная запись          Значения
 комплексных
 констант

 (4.61,-6.81)               4.61-6.811
 (-10,5)                    -10+5i
 (.4е2,-31е-1)              40-0.031i

 Неправильная запись
 комплексных
 констант

 (9,1.231)           (неправильно записана
                     вторая
                     константа)
 (2е3,4d5)           (константа двойной
                     точности)

   Комплексная константа всегда хранится  в  виде  пары  ве-
щественных значений.


   В ОС ДЕМОС допускаются комплексные константы  двойной   |
точности.                                                  |



   5.3.3. Логические константы


   Элемент данных логического типа может может использовать-
ся  для обозначения одного из значений: "истина" или "ложь".
Об'ектом логического типа может  быть  константа,  параметр,
логическая  переменная, элемент логического массива, резуль-
тат обращения к функции и значение выражения. Элемент данных
логического  типа  занимает  в  отрезке памяти одну числовую
единицу памяти.

   Логическая константа может задавать значение "истина" или
"ложь" следующим образом:

    логическая      логическое значение
    константа
    .true.              истина
    .false.             ложь

слова true и false должны быть окружены точками.







22

   5.3.4. Текстовые константы


   Элемент данных текстового типа представляет собой цепочку
из  одной  или более литер.  Об'ектом текстового типа  может
быть  константа,  параметр,  текстовая  переменная,  элемент
текстового массива, результат обращения к функции и значение
выражения. Каждая литера текстового элемента данных занимает
одну текстовую единицу памяти в отрезке памяти.  Смежные ли-
теры  текстового  элемента  данных  занимают  соответственно
смежные единицы памяти в отрезке памяти.

   Литеры, входящие в состав текстового элемента данных, пе-
ренумерованы  последовательно  слева направо целыми числами,
начиная с 1, причем в цепочке может быть представлена  любая
литера,  включая пробел и кавычку, которая служит также раз-
делителем. Длина  текстового  элемента  данных  равна  числу
литер  в  константе или в отрезке памяти, в котором хранится
этот элемент данных.

   Текстовая последовательность представляет собой  последо-
вательность  литер,  заключенную  в  кавычки. Кавычки служат
признаками начала и конца константы и не являются ее частью,
а  все  литеры  между  кавычками  входят в состав константы.
Кавычка в текстовой константе  представляется  в  виде  пары
подряд  стоящих  кавычек,  не разделенных пробелами. Примеры
правильной и неправильной записи констант:

    Правильная запись
    текстовых констант           длина

    'чай на двоих'                12
    'don''t'                       5
    '54 right+/'                  10

    Неправильная
    запись текстовых
    констант

    5htitle        (не заключена в кавычки)
    -теа for two-  (не заключена в
                   кавычки)
    'all right     (нет кавычки справа)
    ''             (текстовая константа
                   не может иметь
                   нулевую длину)

Длина текстовой константы должна быть больше нуля.


   В качестве ограничителя текстовых констант может  ис-   |
пользоваться  любая из кавычек " и '. Если константа на-   |
чалась с простой кавычки ', то и закрываться она  должна   |
такой  же  кавычкой ', а двойная кавычка может входить в   |
константу как обычный символ. Напротив,  если  константа   |
началась  с двойной кавычки ", то закрываться она должна   |
такой же кавычкой ", а кавычка ' может входить в нее как   |
обычный символ.                                            |

   В константе распознаются специальные  символы,  запи-   |
санные  по  правилам языка Си: \n - символ новой строки,   |
\r - символ возврата каретки, \b - символ "шаг назад"  и   |


                                                          23

др. [6].                                                   |



   5.3.5. Холлеритовские константы


   Холлеритовский тип данных определяется в языке Фортран-77
для  совместимости с существующими системами. Область приме-
нения этого типа ограничена: допускаются константы  холлери-
товского  типа,  но и они могут использоваться только в ряде
специально оговоренных случаев.

   Холлеритовская константа  представляет  собой  последова-
тельность литер вида:

                         NhXXXX...X
                            N литер


где N-ненулевая целая константа без знака, а буквами X обоз-
начены  произвольные символы. Длина холлеритовской константы
равна n, значение константы  состоит  из  N  литер,  стоящих
после  буквы  h.  Примеры  правильной  записи холлеритовских
констант:

    Правильная запись        Длина
    холлеритовских констант

    11htea for two             11
    5hdont                     5
    10hall, right              10

   Длина холлеритовской константы всегда равна N -  значению
целой ненулевой константы без знака, стоящей перед буквой h.
В программе на Фортране-77  холлеритовская  константа  может
встречаться  только в инструкции "data", в списке аргументов
в инструкции "call" и в инструкции "format".

   Холлеритовская константа  может  храниться  как  значение
целой, логической или вещественной переменной. Если перемен-
ной присваивается холлеритовское значение, то она становится
неопределенной как арифметическая или логическая переменная.
Холлеритовское значение можно присвоить переменной при помо-
щи инструкции "data", например:

       integer aname
       data aname/4hjohn/


или при помощи инструкции read, например:

       logical big
       read (5,9000)big
9000   format(а4)


   Способ выполнения присваивания холлеритовских значений  в
Фортране-77  зависит от числа литер, которые можно поместить
в одну числовую единицу памяти. Обозначим  это  число  через
len.  Пусть  число  литер  в элементе данных холлеритовского
типа равно n. Если n>len, то записываются правые  len  литер


24

холлеритовского значения, если n<len, то холлеритовский эле-
мент данных при записи дополняется справа len-n пробелами.


   Холлеритовские  константы  в  ОС  ДЕМОС    равноценны   |
текстовым  константам  и  могут использоваться наравне с   |
ними.                                                      |

























































                                                          25




                    6. СTРУКТУРЫ ДАННЫХ



   6.1. Переменные


   Переменная - это об'ект, обладающий следующими  атрибута-
ми:

   - имя;

   - тип;

   - значение.

   Имя фиксируется как имя переменной,  если оно упоминается
в  инструкции описания типа, либо если оно определяется где-
либо в программе. Тип переменной  устанавливается  явно  или
неявно. Нельзя выбирать значение переменной, пока она не оп-
ределена при помощи инструкции ввода, инициализации  данных,
инструкции присваивания или в результате ассоцирования с пе-
ременной или элементом массива, которые были определены.


   В ОС ДЕМОС переменные,  связанные  с  общей  памятью,   |
инициализируются  нулями,  если инициализация их не была   |
задана явно.                                               |



   6.2. Текстовые подцепочки


   Текстовая подцепочка - это последовательность расположен-
ных  подряд  литер,  входящих  в  состав некоторого элемента
данных текстового типа. Подцепочка не может  быть  пустой  и
имеет текстовой тип, так что ее можно использовать в тексто-
вых выражениях. Для того, чтобы определить или выбрать  зна-
чение  подцепочки, подцепочку необходимо специфицировать при
помощи имени подцепочки.


   6.2.1. Обращение к подцепочке


   Подцепочка специфицируется при помощи "вырезки из  цепоч-
ки", которую можно  задать в одной из форм:

        V([E1]:[E2])
        A(S[,S]...)([E1]:[E2])


где

V  - имя текстовой перменной;





26

A  - имя текстового выражения, называемые граничными выраже-
     ниями подцепочки;

S  - индекс.

   Выражение E1 определяет крайнюю левую  текстовую  позицию
подцепочки  относительно "родительского" текстового элемента
данных, а E2-крайнюю  правую  позицию.  Так,  запись  с(i:j)
обозначает подпоследовательность литер текстовой перменной с
с-й по j-ю; d(3,2) (i:j) обозначает последовательность литер
с 1-ой по j-ую текстового элемента данных, расположенного во
2-ом столбце и 3-ей строке текстового массива d. Например:

      character avt*8,bldg(10,5)*12
      avt='variable'
      bldg(2,4)='wine forone'

значением текстовой подцепочки  с  именем  avt  (5:8)  будет
"able",  а  значением подцепочки bldg(2,4)(6:8) будет "for".
(в инструкции описания типа character описывается  текстовая
переменная avt длиной 8 и текстовый массив bldg, каждый эле-
мент которого имеет длину 12).  Длина  текстовой  подцепочки
равна E2-E1+1.


   6.2.2. Граничные выражения подцепочки


   ВыраженияE1 и E2 в имени подцепочки называются граничными
выражениями подцепочки. Обозначим через len длину "родитель-
ского" текстового элемента данных, тогда в момент  обращения
к подцепочке значения выражений E1 и E2 должны удовлетворять
соотношениям:

                       1<=E1<=E2<=len


   Нельзя опускать ни скобки, окружающие выражения E1 и  E2,
ни разделяющее их двоеточие. Если опущено выражение E1,то по
умолчанию процессор использует значение 1.  Аналогично  если
опущено  E2, то берется значение len. Запись v(:), в которой
опущены оба выражения E1 и  E2,  эквивалентна  просто  v,  а
запись a(s[,s]...)(:) эквивалентна a(s[,s]...).

   В качестве граничного  выражения  подцепочки  допускается
любое  правильно  построенное  целое выражение, при условии,
что он не содержит обращений к функции,  выполнение  которой
может  повлиять  на  значения другого граничного выражения в
том же имени подцепочки.


   6.3. Массивы


   Массив - это набор элементов  данных  одного  и  того  же
типа, занимающих последовательные единицы памяти в некотором
отрезке памяти. Каждый массив обладает следующими  атрибута-
ми:

   - имя массива;




                                                          27

   - тип массива;

   - набор значений, которые мы  будем  называть  элементами
     массива;

   - число измерений;

   - протяженность массива по каждому измерению;

   - нижняя и верхняя границы массива по каждому измерению.

   Можно ссылаться на массив при помощи одного только  имени
массива,  если  имеет  место  указание или определение всего
массива целиком, а можно также ссылаться на  отдельный  эле-
мент  массива,  указав имя массива и соответствующий индекс.
Каждый элемент массива может быть определен или неопределен.


   6.3.1. Имя и тип массива


   Имя массива  должно  удовлетворять  правилам  составления
имен  и  фиксируется  как  имя массива при помощи инструкции
описания массивов,  инструкции  описания  общих  блоков  или
инструкции  описания типа. Все массивы должны быть описаны и
могут иметь любой из упоминавшихся ранее типов - целый,  ве-
щественный,  двойной  точности,  комплексный, логический или
текстовый. Тип массива определяется  либо  явно  в  оператое
описания  типа,  либо  неявно по первой букве имени массива.
Массив может иметь от одного до семи измерений.


   6.3.1. Распределение памяти для массивов


   Память для массива отводится в той программной  компонен-
те,  к  которой он описан, если только он не описан как фор-
мальный  параметр  этой  подпрограммы.  В  последнем  случае
массив  передается  подпрограмме извне в качестве аргумента.
Описания массива в программной  компоненте,  в  которой  для
него  фактически будет отведена память, называется описанием
фактического массива. Описание массива в подпрограмме, в ко-
торую  он  будет  передан как параметр, называется описанием
формального массива. В описании фактического  массива  число
его  измерений  и  размер по каждому измерению не могут быть
переменными. В описании формального массива  размер  массива
по каждому измерению может быть как регулируемым, так и пос-
тоянным.

   Массивы Фортрана-77 располагаются в памяти "по столбцам":
это  означает,  что быстрее всего изменяется самый левый ин-
декс.


   6.3.2. Измерения массива


   Описать массив можно при помощи  инструкций  "dimension",
"common"  или  инструкции описания типа, например, следующим
образом:




28

real ОПИСАТЕЛЬ_МАССИВА[,ОПИСАТЕЛЬ_МАССИВА]..

где ОПИСАТЕЛЬ_МАССИВА имеет вид:

                        A(D[,D]...)

где

A  - имя массива;

D  - описание измерения массива вида:

                          [D1:]D2

здесь

D1
   - нижняя граница;

D2
   - верхняя граница индексов для данного измерения. Если D1
     опущена, то подразумевается значение 1.


   6.3.3. Индекс массива


   Для того чтобы  присвоить  значение  отдельному  элементу
массива  или  выбрать  значение элемента, необходимо указать
индекс элемента. Индекс имеет вид:

                         (S[,S]...)

где

S  - индексное выражение.

   Каждое индексное выражение  является  индексом  по  соот-
ветствующему  измерению, и его значение должно лежать в пре-
делах границ массива по этому измерению. Необходимые для вы-
бора  элемента массива индексные выражения разделяются запя-
тыми и заключаются в скобки. Термин индекс относится ко всей
совокупности индексных выражений вместе с запятыми и скобка-
ми. В качестве индексного выражения допускается  любое  пра-
вильно  построенное целое выражение, не содержащее обращений
к таким функциям, выполнение которых может повлиять на  зна-
чения других индексных выражений в том же индексе.


   6.3.4. Выбор элемента массива


   Для того, чтобы выбрать элемент массива, необходимо  ука-
зать имя элемента массива, которое имеет вид:

                        A(S[,S]...)


где A-имя массива, а буквами S обозначены индексные  выраже-
ния. Число индексных выражений должно совпадать с числом из-
мерений массива, указанным в его дескрипторе. Так, для  мас-



                                                          29

сивов, описанных инструкцией:

                    real a(2,0:3),в(-1:6)

запись a(2,1) будет  обозначать  элемент,  расположенный  во
второй  строке  и  в первом столбце массива a. Это четвертый
элемент отрезка памяти, занимаемого массивом a. Запись  в(1)
относится к элементу массива в, который выбирается при помо-
щи индексного выражения, имеющего  значение  1.  Это  третий
элемент отрезка памяти, занимаемого массивом в.

   Доступ к элементу массива осуществляется при помощи  зна-
чения  индекса, вычисляемого с участием значений границ мас-
сива и соответствующих индексных выражений в  момент  ссылки
на элемент.

















































30




                       7.  ВЫРАЖЕНИЯ


   Выражение - это последовательность операндов, операций  и
скобок, задающая некоторые вычисления. Это могут быть вычис-
ления над числовыми, текстовыми, логическими значениями, вы-
числения отношений. После выполнения этих вычислений получа-
ется значение выражения.  Оно  используется  при  выполнении
операторов Фортрана-77.


   7.1. Арифметические выражения


   Значением арифметического выражения является  число.  Это
значение -  или результат действий над числами, или значение
арифметической константы, арифметического параметра, арифме-
тической  переменной  или  элемента арифметического массива.
Простейший вид  арифметического  выражения -  арифметическая
константа, арифметический параметр, ссылка на арифметическую
перменную, на элемент арифметического массива или  обращение
к  арифметической функции. Используя арифметические операции
и скобки, можно определять сложные последовательности вычис-
лений.


   7.1.1. Арифметические операции


   В Фортране-77 определены пять арифметических операций:

    **    возведение в степень
    /     деление
    *     умножение
    -     вычитание или взятие
          со знаком "минус"
    +     сложение или взятие со знаком
          "плюс".

   Операции + и - можно использовать как с одним,  так  и  с
двумя операндами. Операции *, / и ** - только с двумя.

   Старшинство операций при вычислении арифметических  выра-
жений следующее:

    **        высшее
    * и /
    + и -     низшее

   Правила старшинства означают, что из операций, написанных
в  выражении  последовательно,  раньше выполняются те, стар-
шинство которых выше. Так, в выражении:

                          a+в**с*d

операции выполняются так:





                                                          31

1. b**c
     результат обозначим через х, получим a+х*d

2. х*d
     результат обозначим через y, получим a+y

3. a+y
     получим окончательный результат.

   При вычислении выражения -r**2, где r  равно  3,  получим
результат -9, поскольку взятие со знаком "минус" выполняется
в последнюю очередь.


   7.1.2. Арифметические операнды


   В качестве  арифметических  операндов  должны  задаваться
значения типов: целое, вещественное, с двойной точностью или
комплексное. Существуют  определенные  правила,  описывающие
допустимые  комбинации конкретных операндов в арифметическом
выражении. Значение, используемое в качестве операнда, может
быть значением арифметической константы, арифметического па-
раметра,  арифметической  переменной;  может  быть  получено
ссылкой  на  элемент  арифметического  массива, обращением к
арифметической функции или как промежуточный  результат  при
вычислении  арифметического  выражения.  Можно  сказать, что
операндами арифметических операций должны быть  арифметичес-
кие выражения.


   7.1.3. Структура арифметических выражений


   Один из способов точного задания структуры арифметическо-
го  выражения - иерархическая система определений, начиная с
определения арифметического выражения.

   АРИФМЕТИЧЕСКОЕ  ВЫРАЖЕНИЕ  находится  на  высшем   уровне
иерархии и имеет вид:

        ТЕРМ
        +ТЕРМ
        -ТЕРМ
        АРИФМЕТИЧЕСКОЕ ВЫРАЖЕНИЕ + ТЕРМ
        АРИФМЕТИЧЕСКОЕ ВЫРАЖЕНИЕ - ТЕРМ

   Понятие ТЕРМ определяется ниже. Здесь  утверждается,  что
арифметическое  выражение  может  начинаться со знака "плюс"
или "минус", что последовательные аддитивные операции выпол-
няются  слева  направо,  что  две арифметические операции не
могут следовать друг за другом. Так, например,  в  выражении
a*в-с  подвыражение  a*b  выполняется в первую очередь, пос-
кольку это "АРИФМЕТИЧЕСКОЕ ВЫРАЖЕНИЕ" в смысле  определения,
данного выше. В выражении a+в*с подвыражение в*с выполняется
первым, так  как  в  смысле  данного  выше  определения  это
"ТЕРМ".  Таким  образом,  мы видим, что отношение приоритета
между операциями - удобный, хотя и не обязательный метод оп-
ределения, ту же  информацию можно извлечь из иерархического
представления.




32

   Понятие терма дает возможность  ввести  в  арифметическое
выражение мультипликативные операции. ТЕРМ имеет вид:

    МНОЖИТЕЛЬ
    ТЕРМ/МНОЖИТЕЛЬ
    ТЕРМ*МНОЖИТЕЛЬ

   Понятие "МНОЖИТЕЛЬ" определяется ниже. В этом определении
по  существу утверждается, что последовательные мультиплика-
тивные операции выполняются слева направо. Так, например,  в
выражении a*в/с подвыражение a*в выполняется первым.

   Понятие множителя вводит операцию возведения  в  степень.
МНОЖИТЕЛЬ имеет вид:

    ПРОСТОЕ ВЫРАЖЕНИЕ
    ПРОСТОЕ ВЫРАЖЕНИЕ**МНОЖИТЕЛЬ

   Понятие "простое выражение" определено  ниже.  Здесь  ут-
верждается,  что  множитель  состоит  из  последовательности
простых выражений, разделенных операциями возведения в  сте-
пень. Таким образом, операция возведения в степень имеет на-
ивысший приоритет и  выполняется  раньше  операций  с  более
низким  приоритетом,  таких,  как  умножение или сложение. В
этом определении также  утверждается,  что  последовательные
операции  возведения  в  степень  выполняются справа налево,
поскольку "множитель" в нем-правый операнд. Так, в выражении
a**в**с  подвыражение в**с выполняется в первую очередь, как
если бы выражение было записано в виде a**(в**с).

   Простое выражение является базовой составной частью ариф-
метического  выражения  и  задает правила группировки частей
выражения при помощи скобок. Виды  ПРОСТОГО  АРИФМЕТИЧЕСКОГО
ВЫРАЖЕНИЯ:

АРИФМЕТИЧЕСКАЯ КОНСТАНТА БЕЗ ЗНАКА
АРИФМЕТИЧЕСКИЙ ПАРАМЕТР
ССЫЛКА НА АРИФМЕТИЧЕСКУЮ ПЕРЕМЕННУЮ
ССЫЛКА НА ЭЛЕМЕНТ АРИФМЕТИЧЕСКОГО МАССИВА
ОБРАЩЕНИЕ К АРИФМЕТИЧЕСКОЙ ФУНКЦИИ
(АРИФМЕТИЧЕСКОЕ ВЫРАЖЕНИЕ)


   7.2. Арифметические выражения специального вида


   В Фортране-77 используются два специальных вида арифмети-
ческих  выражений:  "aрифметическое константное выражение" и
"целое константное выражение".

АРИФМЕТИЧЕСКОЕ КОНСТАНТНОЕ ВЫРАЖЕНИЕ
   - правильное арифметическое выражение, в  котором  каждое
     простое   выражение,   в  смысле  определения,  данного
     выше, - либо арифметическая константа,  либо  арифмети-
     ческое  константное  выражение  в скобках. В выражениях
     этого вида запрещено возведение в степень, кроме случа-
     ев, когда показатель степени имеет целый тип.

ЦЕЛОЕ КОНСТАНТНОЕ ВЫРАЖЕНИЕ
   - арифметическое константное выражение, в котором  каждая
     арифметическая  константа  или  арифметический параметр
     имеет целый тип.


                                                          33

   7.2.1. Правила вычисления арифметических выражений


   Арифметическое выражение, каким бы  простым  или  сложным
оно  ни было, имеет тип. Арифметическая константа, например,
имеет тип, определяемый по форме ее записи. Тип  переменной,
элемента  массива, обращения к функции определяется по имени
этого об'екта. Тип выражения определяется типами операндов и
функций, обращения к которым встречаются в выражении.


   7.3. Однотипные выражения


   Однотипным называется выражение,  все  операнды  которого
имеют  один и тот же тип. Тип значения однотипного выражения
совпадает с типом его операндов.


   7.3.1. Выражения со смешением типов


   Выражение со смешением типов - это выражение,  содержащее
операнды двух или более типов. В этом случае для определения
типа значения выражения надо  к  промежуточным  результатам,
которые получаются в процессе вычисления выражения, последо-
вательно применять правила преобразования. Например,  сложе-
ние  вещественного  и  целого  операндов  дает результат ве-
щественного типа. Правила преобразования приведены в таблице
2. Операции преобразования типов процессор выполняет автома-
тически, явно указывать их в программе не нужно.

                                                   Таблица 2
                  Правила преобразования
                    для операций +,-,*,/
I - integer, R - real, C - complex
D - double precision, r(x) - real(x)
d(x) - dble(x), c(x,y) - cmplx(x,y)
          _______________________________________
          | x2 |    I2           |     R2       |
          |x1  |                 |              |
          |____|_________________|______________|
          | I1 | I=I1*I2         | R=r(I1)*R2   |
          | R1 | R=R1*r(I2)      | R=R1*R2      |
          | D1 | D=D1*d(I2)      | D=D1*d(R2)   |
          | C1 | C=C1*c(r(I2),0) | C=C1*c(R2,0) |
          |____|_________________|______________|
          _______________________________________
          | x2 |    D2        |        C2       |
          |x1  |              |                 |
          |____|______________|_________________|
          | I1 | D=d(I1)*D2   |  C=c(r(I1),0)*C2|
          | R1 | D=d(R1)*D2   |  C=c(R1,0)*C2   |
          | D1 | D=D1*D2      |  запрещено      |
          | C1 |  запрещено   |  C=C1*C2        |
          |____|______________|_________________|








34

           Правила преобразования для операции **
         _________________________________________
         | x2 |     I2       |         R2        |
         |x1  |              |                   |
         |____|______________|___________________|
         | I1 | I=I1**I2     |     R=r(I1)**R2   |
         | R1 | R=R1**I2     |     R=R1**R2      |
         | D1 | D=D1**I2     |     D=D1**d(R2)   |
         | C1 | C=C1**I2     |     C=C1**c(R2,0) |
         |____|______________|___________________|
         _________________________________________
         | x2 |    D2         |       C2         |
         |x1  |               |                  |
         |____|_______________|__________________|
         | I1 | D=d(I1)**D2   |  C=c(r(I1),0)**C2|
         | R1 | D=d(R1)**D2   |  C=c(R1,0)**C2   |
         | D1 | D=D1**D2      |  запрещено       |
         | C1 |  запрещено    |  C=C1**C2        |
         |____|_______________|__________________|


Например, инструкции:

       integer i
       real a,с,d
       double precision в
       d=i/(a+в)*(c+1,5)

вызовут следующую последовательность действий:

1)  вещественная переменная a преобразуется к  двойной  точ-
    ности  и  складывается  с в; результат получится двойной
    точности и складывается с в; результат получится двойной
    точности. Назовем его е. Получим:

                       d=i/е*(с+1.5)


2)  целая переменная i преобразуется к  двойной  точности  и
    делится  на  e;   результат  получится двойной точности.
    Назовем его f. Получим:

                        d=f*(с+1.5)


3)  вещественная переменная c  складывается  с  вещественной
    константой  1.5. Результат получится вещественный. Назо-
    вем его g. Получим:

                           d=f*g


4)  вещественный промежуточный результат g  преобразуется  к
    двойной точности и умножается на f1; результат получится
    двойной точности. Назовем его h. Получим:

                            d=h


5)  при выполнении инструкции присваивания значение h  двой-
    ной точности преобразуется к вещественному и запоминает-
    ся в d, чем и заканчивается выполнение инструкции.


                                                          35



   В Фортране-77  ОС  ДЕМОС  введен  дополнительный  тип   |
"double  complex", а все операции над вещественными чис-   |
ламидают результат типа "double precision". В результате  |
снимаются   запреты  на  операции  типа  COMPLEX*DOUBLE,   |
COMPLEX**DOUBLE.                                           |



   7.4. Унарные операции


   Операция с одним операндом называется унарной  операцией.
В  Фортране-77 две унарные операции: взятие со знаком "плюс"
и взятие со знаком "минус",  которые  пишутся  соответсвенно
как  -a  и +a. Тип  результата операции совпадает с типом ее
операнда.


   7.4.1. Целочисленное деление


   Результатом деления целых чисел является значение  целого
типа.  Например, выражение (-5/2) дает результат (-2). Целое
частное вычисляется по следующим правилам:

   - если  абсолютная  величина   математического   частного
     меньше единицы, то результат равен нулю. (например, как
     (-1/3), так и (1/2) дают в результате 0);

   - если  абсолютная  величина   математического   частного
     больше или равна единице, то результат - наибольшее це-
     лое со значением, не превосходящим абсолютной  величины
     математического частного, взятое с тем же знаком, какой
     имеет математическое частное. (например, (-10)/3 дает в
     результате (-3), а (-17)/(-5) дает в результате 3).


   7.4.2. Возведение в степень


   Правило преобразования типов  утверждает,  что  в  случае
применения  арифметической операции к операндам разных типов
тот операнд, тип которого  отличается  от  типа  результата,
преобразуется к типу результата, так что арифметическая опе-
рация выполняется над операндами одного типа. Исключением из
этого  правила  является  операция возведения в степень. При
возведении в целую степень операнда вещественного, с двойной
точностью  или комплексного целый показатель степени не пре-
образуется.

   В случае возведения целого значения в целую степень, т.е.
i1**i2,   результат   при   отрицательном   i2  будет  равен
1/(i1**abs(i2)), где целое частное вычисляется  по  правилам
целочисленного деления.








36

   7.5. Текстовые выражения


   Значением текстового выражения  является  цепочка  литер.
Это  значение - либо результат одной или более операций кон-
катенации над текстовыми значениями, либо значение текстовой
функции,  текстовой константы, текстового параметра, тексто-
вой переменной или  элемента  текстового  массива.  Так  что
простейший  вид  текстового выражения - текстовая константа,
текстовый  параметр, ссылка на текстовую переменную, тексто-
вый  массив  или  подцепочку,  либо  обращение  к  текстовой
функции. Используя операцию конкатенации и скобки, можно оп-
ределять  сложные  последовательности операций над цепочками
литер.


   7.6. Текстовые операции


   В Фортране-77 определена одна текстовая операция - конка-
тенация. Конкатенация двух текстовых операндов C1 и C2 запи-
сывается в виде:

                           C1//C2

и  обозначает  текстовое  значение  C1,  дополненное  справа
текстовым  значением  C2. Таким образом, значение текстового
выражения 'авс'//'123+' - цепочка литер 'авс123+'.


   7.6.1. Текстовые операнды


   Текстовый операнд  должен  задавать  значение  текстового
типа.  Значение,  используемое  в  качестве такого операнда,
может быть значением текстовой константы,  текстового  пара-
метра, текстовой переменной или подцепочки, может быть полу-
чено по ссылке на  текстовый  массив  или  при  обращении  к
текстовой  функции  либо как промежуточный результат при вы-
числении текстового выражения. Поскольку любой способ  полу-
чения  текстового значения подразумевает некоторое текстовое
выражение, можно сказать, что операндами операции конкатена-
ции должны быть текстовые выражения.


   7.6.2. Структура текстовых выражений


   Для задания точного вида текстового выражения использует-
ся  иерархическая  система  определений. ТЕКСТОВОЕ ВЫРАЖЕНИЕ
находится на высшем уровне этой иерархии и имеет вид:

 ПРОСТОЕ ТЕКСТОВОЕ ВЫРАЖЕНИЕ
 ТЕКСТОВОЕ ВЫРАЖЕНИЕ//ПРОСТОЕ
        ТЕКСТОВОЕ ВЫРАЖЕНИЕ


   Данное    определение    утверждает,    что    "текстовое
выражение" -  это либо простое текстовое выражение, либо два
или более простых текстовых выражений,  разделенных  знаками
конкатенации.  Вторая  строка  в определении также означает,
что последовательные операции конкатенации выполняются слева


                                                          37

направо, так что с//d//e эквивалентно (с//d)//e.

   Простое текстовое выражение  является  базовой  составной
частью  текстового выражения и определяет способ группировки
частей выражения  с  использованием  скобок.  Виды  ПРОСТОГО
ТЕКСТОВОГО ВЫРАЖЕНИЯ:

    ТЕКСТОВАЯ КОНСТАНТА
    ТЕКСТОВЫЙ ПАРАМЕТР
    ССЫЛКА НА ТЕКСТОВУЮ ПЕРЕМЕННУЮ
    ССЫЛКА НА ЭЛЕМЕНТ ТЕКСТОВОГО МАССИВА
    ССЫЛКА НА ПОДЦЕПОЧКУ
    ОБРАЩЕНИЕ К ТЕКСТОВОЙ ФУНКЦИИ
    (ТЕКСТОВОЕ ВЫРАЖЕНИЕ)

   Эти правила также означают, что нет подразумеваемых  опе-
раций  конкатенации, так что  a в  воспринимается просто как
переменная aв.


   7.6.3. Текстовые выражения специального вида


   В Фортране-77 имеется один специальный вид текстовых  вы-
ражений: "константное текстовое выражение".

КОНСТАНТНОЕ ТЕКСТОВОЕ ВЫРАЖЕНИЕ
   - правильное текстовое выражение, в котором  все  простые
     текстовые выражения не что иное, как текстовые констан-
     ты или текстовые параметры.


   7.7. Выражения отношения


   Выражение отношения представляет логическое значение, по-
лученное  сравнением  двух арифметических выражений или двух
текстовых выражений. Текстовое выражение нельзя сравнивать с
арифметическими. Выражение отношения может появляться только
в логическом выражении. При этом выражение отношения по  оп-
ределению  само  является логическим выражением, так как оно
всегда принимает логические значения.


   7.7.1. Операции отношения


   В Фортране-77 имеется шесть операций отношения:

    операция       название
    .lt.           меньше
    .le.           меньше или равно
    .eq.           равно
    .ne.           не равно
    .ge.           больше или равно
    .gt.           больше








38

                                                  Таблица 3.
              Вид и смысл операций отношения.

-----------------------------------------------------------
Вид           Смысл
-----------------------------------------------------------
X1.lt.X2   "меньше": выражение принимает значение  "истина",
          если  значение  X1  меньше  значени X2, и "ложь" в
          противном случае
X1.le.X2   "меньше или равно": выражение принимает  значение
          "истина", если значение X1 меньше или равно значе-
          нию X2, и "ложь" в противном случае
X1.eq.X2   "равно": выражение принимает  значение  "истина",
          если  значение  X1  равно  значению X2, и "ложь" в
          противном случае
X1.ne.X2   "не равно": выражение принимает  значение  "исти-
          на",  если  значение  X1  не  равно значению X2, и
          "ложь" в противном случае
X1.ge.X2   "больше или равно": выражение принимает  значение
          "истина", если значение X1 больше или равно значе-
          нию X2, и "ложь" в противном случае
X1.gt.X2   "больше": выражение принимает значение  "истина",
          если  значение  X1  больше значения X2, и "ложь" в
          противном случае
-----------------------------------------------------------

   Каждая операция  подразумевает  наличие  двух  операндов,
описанных в виде:

                  X1 ОПЕРАЦИЯ-ОТНОШЕНИЯ X2

где X1 и X2-операнды (оба арифметические или оба текстовые).


   7.7.2. Операнды операций отношения


   Операнды операций отношения могут быть правильными  ариф-
метическими  или правильными текстовыми выражениями. Приори-
тет операций  таков, что арифметические и текстовые операции
выполняются до операций отношения.


   7.7.3. Вычисление выражений отношения


   Значения выражения отношения - это "истина"  или  "ложь".
Способ вычисления выражения зависит от типов операндов.


   7.7.3.1. Арифметические выражения отношения


   Арифметическое выражение  отношения имеет вид:

                  E1 ОПЕРАЦИЯ-ОТНОШЕНИЯ E2

где E1 и E2-арифметические выражения:  целые,  вещественные,
двойной  точности  или  комплексные,  . ОПЕРАЦИЯ-ОТНОШЕНИЯ -
операция отношения. Операнды E1 и E2 могут быть комплексными
только в случае операций ".eq." или ".ne.".



                                                          39

   Результат арифметического  выражения  отношения  является
истинным,  если упомянутое в нем отношение справедливо. Если
E1 и E2 имеют разные типы, выражение вычисляется по правилу:

              ((E1)-(E2)) ОПЕРАЦИЯ-ОТНОШЕНИЯ 0


где выражение ((E1)-(E2)) вычисляется с учетом правил преоб-
разования типов, а значение 0 имеет тот же тип, что и значе-
ние этого выражения.  Если  ((E1)-(E2))  представляет  собой
неправильное  выражение,  такая форма сравнения недопустима.
Так, нельзя сравнивать комплексное  выражение  с  выражением
двойной точности.


   7.7.3.2. Текстовые выражения отношения


   В случае текстовых операндов сравниваются  двоичные  коды
текстовых  операндов и значение выражения-"истина", если за-
данное отношение между ними выполнено.  Текстовое  выражение
отношения имеет вид:

                  C1 ОПЕРАЦИЯ-ОТНОШЕНИЯ C2


где C1 и C2-текстовые выражения, ОПЕРАЦИЯ-ОТНОШЕНИЯ - опера-
ция отношения.

   Результат текстового выражения отношения зависит от  упо-
рядоченности  кодов литер по возрастанию. Так, C1 меньше C2,
если C1 предшествует C2 в упорядоченной по возрастанию  пос-
ледовательности  кодов.  Проверки на равенство не зависят от
упорядочения литер, так что операции ".eq." и  ".ne."  можно
использовать  на  любой  операционной системе. Результат ос-
тальных операций сравнения зависит от конкретной ОС.


   В ОС ДЕМОС символы упорядочены в соответствии с кодом   |
КОИ-8.                                                     |


   Если текстовые операнды имеют разную длину, более  корот-
кий  операнд  при  сравнении дополняется справа пробелами до
длины более длинного.


   7.8. Логические выражения


   Логическое выражение принимает логическое  значение.  Это
значение - или результат логических вычислений, или значение
логической константы, логического параметра, логической  пе-
ременной  или элемента логического массива. Так что простей-
шая форма логического выражения - логическая константа,  ло-
гический параметр, ссылка на логическую переменную, логичес-
кий массив или обращение к логической функции. Используя ло-
гические  операции и скобки, можно определять сложные после-
довательности вычислений.





40

   7.8.1. Логические операции


   В Фортране-77 определены пять логических операций:

 .not.  ЛОГИЧЕСКОЕ ОТРИЦАНИЕ
 .and.  КОН'ЮНКЦИЯ
 .or.   ДИЗ'ЮНКЦИЯ
 .eqv.  ЛОГИЧЕСКАЯ ЭКВИВАЛЕНТНОСТЬ
 .neqv. ЛОГИЧЕСКАЯ НЕЭКВИВАЛЕНТНОСТЬ

   Логическая операция ".not." используется с одним  операн-
дом;  операции  ".and.",  ".or.",  ".eqv.", ".neqv." требуют
двух операндов.

   Старшинство операций при вычислении логических  выражений
следующее:

    Операция       Старшинство

    .not.          высшее
    .and.
    .or.
    .eqv. и .neqv. низшее

   Правила старшинства означают, что из операций, написанных
последовательно,  раньше выполняются те, старшинство которых
выше. Так, в выражении:

                     q.eqv.r.and.s.or.т

операции на самом деле выполняются в таком порядке:

1. r.and.s
     Результат обозначим через a. Получим q.eqv.a.or.t

2. a.or.t
     Результат обозначим через в. Получим q.eqv.в

3. q.eqv.в
     Получим окончательный результат.

   Аналогично,  вычисление  выражения  .not.u.and.v,  где  u
ложно,  v истинно, дает истинный результат, поскольку опера-
ция отрицания выполняется в первую очередь.

                                                  Таблица 4.
                 Смысл логических операций
                "+" - "истина", "-" - "ложь"
         __________________________________________
         | X1| X2| .not.X2|.and.|.or.|.eqv.|.neqv.|
         |___|___|________|_____|____|_____|______|
         | + | + |    -   |  +  |  + |  +  |  -   |
         | + | - |    +   |  -  |  + |  -  |  +   |
         | - | + |    -   |  -  |  + |  -  |  +   |
         | - | - |    +   |  -  |  - |  +  |  -   |
         |___|___|________|_____|____|_____|______|







                                                          41

   7.8.2. Логические операнды


   Логические операнды должны задавать значения  логического
типа. Значение, используемое в качестве операнда, может быть
значением логической константы, логического параметра, логи-
ческой переменной, элемента логического массива, результатом
обращения к логической функции, результатом выражения  отно-
шения,  либо  промежуточным результатом при вычислении логи-
ческого выражения. Поскольку любой способ получения логичес-
кого  значения подразумевает некоторое логическое выражение,
можно сказать, что  операндами  логических  операций  должны
быть логические выражения.


   7.8.3. Структура логических выражений


   Для задания точного вида логического выражения  использу-
ется иерархическая система опеределений.

   ЛОГИЧЕСКОЕ ВЫРАЖЕНИЕ  находится  на  высшем  уровне  этой
иерархии и имеет вид:

ЛОГИЧЕСКАЯ СУММА
ЛОГИЧЕСКОЕ ВЫРАЖЕНИЕ.eqv.ЛОГИЧЕСКАЯ СУММА
ЛОГИЧЕСКОЕ ВЫРАЖЕНИЕ.neqv.ЛОГИЧЕСКАЯ СУММА


   В этом определении по существу утверждается, что в  логи-
ческом  выражении, содержащем две или более операции .eqv. и
.neqv., логические суммы связываются слева направо (или, что
то же самое, последовательные операции .eqv. и .neqv. выпол-
няются слева направо). Так, в выражении u.eqv.v.neqv.w  опе-
рации  выполняются,  как  если  бы  было  написано (u.eqv.v)
neov.w.

   Понятие логической суммы вводит операцию диз'юнкции,  ко-
торая записывается как .or.; ЛОГИЧЕСКАЯ СУММА имеет вид:

 ЛОГИЧЕСКИЙ ТЕРМ
 ЛОГИЧЕСКАЯ СУММА.or.ЛОГИЧЕСКИЙ ТЕРМ

где понятие "логический терм" определяется ниже. В этом  оп-
ределении утрерждается, что в логическом выражении, содержа-
щем две или более операции .or., логические термы связывают-
ся  слева  направо  (или,  что то же самое, последовательные
операции .or. выполняются слева направо). Так,  в  выражении
"a.or.в.or.с" операции выполняются так, как если бы было на-
писано "(a.or.в).or.с".

   Понятие ЛОГИЧЕСКИЙ ТЕРМ вводит операцию кон'юнкции

 ЛОГИЧЕСКИЙ МНОЖИТЕЛЬ
 ЛОГИЧЕСКИЙ ТЕРМ.and.ЛОГИЧЕСКИЙ МНОЖИТЕЛЬ


   В этом определении утверждается, что в логическом выраже-
нии  с двумя или более операциями .and. логические множители
связываются слева направо. Так,  в  выражении  i.and.j.and.к
операции   выполняются   так,  как  если  бы  было  написано
(i.and.j).and.к.


42


   ЛОГИЧЕСКИЙ МНОЖИТЕЛЬ определяется для  введения  операции
логического отрицания .not. и имеет вид:

 ПРОСТОЕ ЛОГИЧЕСКОЕ ВЫРАЖЕНИЕ
 .not.ПРОСТОЕ ЛОГИЧЕСКОЕ ВЫРАЖЕНИЕ

поскольку .not. в иерархии определений  находится  ниже  ос-
тальных  операций,  операция .not. выполняется перед  .and.,
.or., .eqv. или .neqv.. Так, в выражении ".not.q.or.s.and.t"
операции   выполняются   так,  как  если  бы  было  написано
"(.not.q).or.(s.and.t)".

   Простое логическое выражение является  базовой  составной
частью  логического  выражения  и задает правила группировки
частей  логического  выражения  при  помощи   скобок.   Виды
ПРОСТОГО ЛОГИЧЕСКОГО ВЫРАЖЕНИЯ:

 ЛОГИЧЕСКАЯ КОНСТАНТА
 ЛОГИЧЕСКИЙ ПАРАМЕТР
 ССЫЛКА НА ЛОГИЧЕСКУЮ ПЕРЕМЕННУЮ
 ССЫЛКА НА ЭЛЕМЕНТ ЛОГИЧЕСКОГО МАССИВА
 ОБРАЩЕНИЕ К ЛОГИЧЕСКОЙ ФУНКЦИИ
 ВЫРАЖЕНИЕ ОТНОШЕНИЯ
 (ЛОГИЧЕСКОЕ ВЫРАЖЕНИЕ)

   Можно отметить, что, как и в случаях с другими типами вы-
ражений,  две логические операции, каждая из которых требует
двух операндов, не могут стоять рядом.


   7.8.4. Логические выражения специального вида


   В Фортране-77 есть один специальный вид логического выра-
жения:    логическое   константное   выражение.   ЛОГИЧЕСКОЕ
КОНСТАНТНОЕ ВЫРАЖЕНИЕ - это правильное логическое выражение,
в котором каждое ПРОСТОЕ ЛОГИЧЕСКОЕ ВЫРАЖЕНИЕ  - это:

ЛОГИЧЕСКАЯ КОНСТАНТА
ЛОГИЧЕСКИЙ ПАРАМЕТР
ВЫРАЖЕНИЕ ОТНОШЕНИЯ , в котором каждое
 простое выражение - константное выражение
(ЛОГИЧЕСКОЕ ВЫРАЖЕНИЕ)

   Таким образом, логическое константное выражение может со-
держать арифметические и текстовые константные выражения.


   7.8.5. Замечание о выполнении логических выражений


   Одно из правил Фортрана-77 заключается в том, что процес-
сору  не нужно вычислять все операнды операции и даже выпол-
нять все операции в выражении, если значение выражения можно
определить, не делая этого. Это правило применяется к вычис-
лению любых выражений, но особенно часто оно бывает примени-
мо  к  логическим выражениям, так как их значение истинности
часто зависит от значения одного операнда.





                                                          43

   Например, в выражении:

                      a.lt.в.or.с.gt.d

для истинности выражения достаточно истинности только одного
из  операндов  операции  .or.. Так что, если a меньше в, нет
необходимости вычислять подвыражение с.gt.d, а  выражение  в
целом истинно. Аналогично, в выражении:

                     a.gt.в.and.с.lt.d

для ложности выражения  достаточно  ложности  только  одного
операнда  операции  .and..  Так что, если a не больше в, нет
необходимости вычислять подвыражение с.lt.d, а  выражение  в
целом ложно.


   7.9. Интерпретация и вычисление выражений


   Имеется ряд правил и  соглашений,  касающихся  вычисления
выражений  в целом. Речь идет о старшинстве операций различ-
ных типов, неприкосновенности скобок,  правилах  интерпрета-
ции,  вычисления  функций,  а также о правилах, применимых к
особым типам выражений.


   7.9.1. Старшинство операций различных типов


   Когда в одном выражении  встречаются  операции  различных
типов,  такие,  как  арифметические, отношения и логические,
между ними соблюдается следующая иерархия:

        арифметический     высшее
        текстовый            |
        отношения            V
        логический         низшее

   Так, в выражении  a+в*с.lt.d.and.q  операции  выполняются
так,     как     если    бы    было    написано    выражение
((a+(в*с)).lt.d).and.q. (здесь предполагается, что a,  в,  с
и d - арифметические перменные, q - логическая переменная.)


   7.9.2. Неприкосновенность скобок и правила интерпрета-
          ции


   Неприкосновенность скобок играет  особую роль. В  некото-
рых  случаях  компилятор  может  изменить порядок выполнения
операций в выражении  согласно  правилам  ассоциативности  и
дистрибутивности,  чтобы  минимизировать  время  вычисления.
Выражения в скобках, однако, всегда воспринимаются как  еди-
ный  об'ект.  Использование  скобок,  таким  образом, служит
отправной точкой для сведения воедино правил сочетания  опе-
раций и операндов. Порядок действия правил следующий:

1)  использование скобок;





44

2)  старшинство операций;

3)  выполнение операций возведения в степень внутри множите-
    ля справа налево;

4)  выполнение мультипликативных операций (умножение и деле-
    ние) внутри терма слева направо;

5)  выполнение аддитивных операций (сложение и вычитание)  в
    арифметическом выражении слева направо;

6)  выполнение операций конкатенации в  текстовом  выражении
    слева направо;

7)  выполнение операций кон'юнкции (т.е. ".and.") внутри ло-
    гического терма слева направо;

8)  выполнение операций диз'юнкции (т.е.  ".or.") в логичес-
    кой сумме слева направо;

9)  выполнение  операций  логической  эквивалентности  (т.е.
    ".eqv."  и ".neqv.") в логическом выражении слева напра-
    во.


   7.9.3. Дополнительные правила вычисления выражений


   - В момент ссылки на об'ект  он  должен  быть  определен,
     причем определен значением правильного типа;

   - Операциядолжна быть определена математически (например,
     нельзя вычислить выражение 2./0.).

   - Компилятор  может  производить  математически   эквива-
     лентные преобразования.


   7.9.4. Обращение к функциям


   Чтобы обеспечить однозначность результатов вычислений, на
использовние определенных внешних функций существует некото-
рые ограничения. Ограничения касаются способа их использова-
ния в конкретных выражениях. Вот эти ограничения:

1)  выполнение функции в выражении не должно изменять  ника-
    ких  других об'ектов, входящих в это выражение, ни явным
    присваиванием значения фактическому параметру, ни неявно
    через общую память. Так, например, в выражении:

                      a=в+fcn(в)+с(i)


     функция fcn не должна влиять на значение переменных  в,
     i и массива с;

2)  в  инструкциях,  содержащих  более  одного  обащения   к
    функциям,  функции могут выполняться в любом порядке, за
    исключением следующих случаев:




                                                          45

   - Когда одно обращение к  функции  встречается  в  списке
     фактических параметров другого обращения к функции, как
     в такой инструкции:

                     a=fcna(в+fcnb(с))


     где fcna и  fcnb  -  функции  (здесь  fcnb  выполняется
     раньше fcna);

   - Когда одно обращение к функции встречается в логическом
     выражении  логической  инструкции  "if",  а  другое - в
     инструкции, которая является частью той  же  логической
     инструкции "if", например:

                if(a.and.fcnr(т))a=в+fcnb(с)

где fcnr-функции. (здесь fcnr выполняется раньше fcnb.).

   Основной результат наложения таких ограничений на обраще-
ния  к  функциям  заключается в том, что никакое обращение к
функции не может определить переменную, от  которой  зависит
значение какой-либо другой функции в том же выражении, кроме
вышеупомянутого случая с логической инструкцией "if".


   7.9.5. Вычисление выражений


   Компилялтор может преобразовывать выражение  в  математи-
чески эквивалентное. Как правило, такое преобразование дела-
ется при смешении в выражении операндов различных типов. При
определении типа выражения действуют следующие правила:

   - Тип выражения, содержащего обращение к  функции,  никак
     не связан с типом выражения - фактического параметра из
     списка параметров этой функции.

   - Тип индексного выражения в выражении, содержащем ссылку
     на массив, никак не связан с типом выражения.

   - Вычисление  целых  выражений,  входящих  в  ссылку   на
     текстовую  цепочку, не зависит от того текстового выра-
     жения, в котором они используются.


   7.9.5.1. Эквивалентность выражений


   При преобразовании выражений компилятор использует следу-
ющие правила:

   - могут производиться эквивалентные преобразования  ариф-
     метических  выражений при условии, что соблюдается неп-
     рикосновенность скобок и что целые операнды не смешива-
     ются с операндами других типов так, чтобы мог получить-
     ся неэквивалентный результат.

   - Два логических выражения эквивалентны, если их логичес-
     кие значения равны для всех возможных значений входящих
     в них простых выражений. Так, например, выражение отно-
     шения  "a.gt.в" компилятор  может преобразовать в выра-


46

     жение  "в-a.lt.0.0", если  выполнены  приведенные  выше
     правила вычисления выражений отношения.

   - Два логических выражения эквивалентны, если их логичес-
     кие  значения равны при всех возможных значениях входя-
     щих в них простых выражений. Процессор может  вычислить
     выражение  в  другой форме, если только эта форма логи-
     чески эквивалентна исходной.

   - Приведенное выше  правило  вычисления  операндов  также
     применимо  к  текстовым выражениям. Рассмотим следующий
     пример, в котором длина текстовых переменных с,d и е  -
     две  литеры, а cfcn-функция, принимающая текстовое зна-
     чение:

      character*2 с,d,е,cfcn
      с=d//cfcn(е)


        В этом случае нет  необходимости  вычислять  функцию
     cfcn, поскольку результат присваивания переменной с оп-
     ределяется только переменной d, так как и с, и d  имеют
     длину две литеры.









































                                                          47




            8. ВЫПОЛНЕНИЕ ИНСТРУКЦИЙ ФОРТРАНА-77


   В данном разделе описаны  правила  выполнения  инструкций
Фортрана-77.


   8.1. Последовательность выполнения инструкций


   Последовательность выполнения в  программе  на  Фортране-
77 - это порядок, в котором инструкции выполняются процессо-
ром. Рассмотрим нормальную последовательность  выполнения  и
передачи управления.


   8.1.1. Нормальная последовательность выполнения


   Нормальная  последовательность,  в  которой   выполняются
программы на Фортране-77 - это порядок, в котором они встре-
чаются в главной программе или внешней процедуре. Выполнение
программы  начинается с первой исполняемой инструкции  глав-
ной программы,  с этого места продолжается нормальная после-
довательность  выполнения.  Когда  в  главной  программе или
внешней процедуре встречается обращение к внешней процедуре,
выполнение вызывающей инструкции приостанавливается и выпол-
нение программы продолжается с первой исполняемой инструкции
в  вызывающей  процедуре, следующей сразу же за соответству-
ющей  инструкцией  "function",  "subroutine"  или   "entry".
Выполнение  возвращается из вызванной процедуры к вызывающей
инструкции, если встретилась явная  или  неявная  инструкция
возврата, и нормальное выполнение продолжается с того места,
где оно было приостановлено,  или  с  точки  альтернативного
возврата в вызывающей программе.

   Система осуществляет  нормальное  завершение  исполняемой
программы,  когда выполняется "stop" в главной программе или
во внешней процедуре или когда выполняется инструкция  "end"
в главной программе. Процессор осуществляет ненормальное за-
вершение исполняемой программы, если при его действиях  воз-
никает ситуация, препятствующая дальнейшему выполнению прог-
раммы.


   8.1.2. Передача управления


   Нормальная последовательность выполнения может быть нару-
шена  выполнением одной из нескольких инструкций языка, при-
водящих к передаче управления. При этом нормальная  последо-
вательность  выполнения  прекращается и выполнение программы
возобновляется, начиная с  указанной  инструкции  в  главной
программе  или  внешней  процедуре. Передача управления осу-
ществляется следующими инструкциями:

   - инструкция "goto";




48

   - инструкция "if арифметическая";

   - инструкции "return" и "stop";

   - инструкция ввода-вывода со спецификациями  возврата  по
     ошибке и по концу файла;

   - инструкция "call";

   - логическая инструкция "if", которая  включает  одну  из
     инструкций, упомянутых выше;

   - инструкции "if структурная" и "elseif";

   - инструкция "do";

   - инструкция "end".


   8.2. Исполняемые и неисполняемые инструкции


   Инструкции Фортрана-77 делятся на исполняемые и  неиспол-
няемые.  Исполняемая  инструкция совершает определенное дей-
ствие в выполняемой программе и  является  возможной  частью
последовательности  выполнения. Неисполняемая инструкция за-
дает компилятору некоторую информацию, управляющую  выполне-
нием   программы.   Как  исполняемая,  так  и  неисполняемая
инструкция может иметь метку. Передавать управление по метке
на неисполняемую инструкцию нельзя.


   8.2.1. Список исполняемых инструкций


   Исполняемые инструкции совершают действия по  вычислению,
управлению или действия, связанные с вводом -выводом. К этим
инструкциям относятся:

присваивание
   - позволяет выполнять вычисления  и  определять  значения
     переменных  или  массивов.  Целым переменным может быть
     присвоено  значение  метки   (при   помощи   инструкции
     "assign");

go to
   - передает управление на безусловно заданную,  предписан-
     ную или вычисляемую метку;

if
   - обеспечивает условное ветвление или выполнение инструк-
     ций по значению арифметического или логического выраже-
     ния;

if структурный
   - "if структурный"   - конструкция "if-then-else" обеспе-
     чивает условное выполнение инструкций;

stop и pause
   - завершает или временно  приостанавли-  вает  выполнение
     программы;



                                                          49

do
   - управляет циклами, обеспечивая  итеративное  выполнение
     части программы;

continue
   - не выполняет никаких действий, но может  использоваться
     с  меткой  и, таким образом, указать точку в программе,
     на которую можно сослаться;

read, write и print
   - обеспечивают функции ввода-вывода;



type, accept                                               |
   - аналогичны операторам "print" и "read";               |


rewind, backspace, endfile, open,

close и inquire
   - обеспечивают функции управления вводом-выводом;

call и return
   - позволяют вызвать внешнюю процедуру и  возвратиться  из
     нее;

end
   - используется в качестве физического  конца  программной
     компоненты  и вызывает завершение программы или возврат
     в вызывающую программу  при  выполнении  ее  в  главной
     программе и во внешней процедуре соответсвенно.

   Исполняемые инструкции распадаются на три класса: присва-
ивания, управления и ввода-вывода.


   8.2.1. Список неисполняемых инструкций


   Неисполняемые инструкции не участвуют в формировании пос-
ледовательности  выполнения. К неисполняемым инструкциям от-
носятся:

program, function, subroutine,

entry, block data
   - определяет  начало  программной  компоненты,  позволяет
     дать ей имя и задать управляющую информацию;

 dimension, common,
 equivalense,
 implicit,parameter,
 external,intrinsic,
 save

   - позволяет определять требования к распределению  памяти
     и вводить в употребление имена;

 integer,real,
 double precision,
 complex, logical,


50

 character

   - позволяет задавать типы данных и требования к распреде-
     лению памяти;

data
   - позволяет инициализировать значения переменных  до  вы-
     полнения программы;

format
   - позволяет задать информацию, управляющую редактировани-
     ем при вводе/выводе;

функция-формула
   - позволяет определить внутреннюю  функцию,  сотоящую  из
     однго выражения.



static, automatic                                          |
   - позволяют задавать класс памяти для размещения  ло-   |
     кальных переменных;                                   |

byte                                                       |
   - полностью эквивалентно "character";                   |

include                                                    |
   - подстановка текста из файла ОС ДЕМОС, это скорее не   |
     оператор языка, а указание компилятору.               |


   Неисполняемые инструкции относятся к одному из трех клас-
сов: описания, формата и заголовка подпрограммы.































                                                          51




                   9. ИНСТРУКЦИИ ОПИСАНИЯ


   Инструкции описания содержат информацию для компилятора о
том,  как  работать  с  памятью, как понимать и использовать
идентификаторы,  как  выполнять   инструкции.   Чаще   всего
инструкции  описания используются для задания типов данных и
требований к распределению  памяти.  Инструкции  описания  в
целом  подразделяются  на группы по виду информации, которую
они могут предоставить компилятору.


   9.1. Инструкции описания типа


   Инструкции описания типа используются для  задания  типов
об'ектов  путем отмены неявных спецификаций типа и для зада-
ния размерностей массивов. Если имя упомянуто  в  инструкции
описания  типа,  то  тем  самым тип соответствующего об'екта
задан для всех вхождений этого имени в той программной  ком-
поненте,  где  это  имя  описано.  Каждое  имя может входить
только в одну инструкцию описания типа. Имя главной програм-
мы,  подпрограммы или программной компоненты "block data" не
может встречаться в инструкции описания типа.  В  инструкции
описания  типа  могут  быть описаны типы следующих об'ектов:
переменной, параметра, массива, функции,  формального  пара-
метра процедуры. Инструкцию описания типа можно использовать
и для подтверждения типа, заданного по  умолчанию,  в  целях
документирования.


   9.1.1. Инструкция описания арифметического и  логичес-
          кого типа


   Инструкции описания арифметического  и  логического  типа
имеют вид:

                        ТИП N[,N]...


где  ТИП  -  это  "integer",  "real",  "double   precision",
"complex"  или  "logical",  а N - имя переменной, параметра,
массива,  функции,  формального  параметра  процедуры,   или
дескриптор  массива.  Инструкция  описания типа говорит, что
декларируемый в ней об'ект имеет соответствующий  тип.  Так,
инструкция  "integer" используется для описания об'ектов це-
лого типа, инструкция "real" - вещественных об'ектов и т.д.

   Таким образом инструкции:

    integer acat,i3,for(3,-1:5)
    real j,sum(-5:30),diff(3,8,5),qte
    double precision ident,rslt(100)
    logical q,r(0:10,5),tlist,pflag
    complex оhm(6,-10:10,1,10),bxer

вводят следующие описания:



52

1)  acat и i3 - имена целых. for - массив целых (описание i3
    подтверждает неявное задание типа);

2)  j и qte - имена вещественных; sum и diff -  массивы  ве-
    щественных  (описание  qte  подтверждает неявное задание
    типа);

3)  ident - имя об'екта  двойной  точности;  rslt  -  массив
    двойной точности;

4)  q,tlist и pflag - имена логических об'ектов, r- логичес-
    кий массив;

5)  bxer - имя комплексного, онм - комплексный массив.



   Имеется      дополнительный      описатель       типа   |
"double precision complex".                                |

   Инструкция описания может записываться также в виде:    |

       ТИП*ДЛИНА N[,N]                                     |
       или                                                 |
       ТИП*(ДЛИНА) N[,N]                                   |

где ДЛИНА - целая константа, указывающаа   длину  одного   |
элемента в байтах. Использование скобок обязательно, ес-   |
ли ДЛИНА задана с помощью символической  константы  либо   |
если  имя  первого  идентификатора  в  списке имеет вид:   |
"d<число> или e<число>"  (в  последнем  случае  при  от-   |
сутствии скобок комбинация "ДЛИНА*N будет восприниматься   |
как вещественная константа с указателем степени).          |

Могут использоваться следующие комбинации ТИП*ДЛИНА:       |

integer*2                                                  |
   - описывает об'екты "короткого целого" типа (2  байта   |
     на число);                                            |

integer*4                                                  |
   - описывает об'екты "длинного целого" типа  (4  байта   |
     на число);                                            |

real*4                                                     |
   - описывает об'екты типа "real" (4 байта на число);     |

real*8                                                     |
   - описывает об'екты типа "double precision" (8 байтов   |
     на число);                                            |

complex*8                                                  |
   - описывает об'екты типа "complex"  (по  4  байта  на   |
     действительную и мнимую части);                       |

complex*16                                                 |
   - описывает  об'екты  типа  "double  complex"  (по  8   |
     байтов на действительную и мнимую части комплексно-   |
     го числа);                                            |





                                                          53

logical*1, logical*2,logical*4                             |
   - различные варианты логических  переменных,  отлича-   |
     ющиеся занимаемой памятью.                            |

   ДЛИНА может также  задаваться  для  каждого  имени  в   |
списке  отдельно.  Точный  синтаксис  оператора описания   |
арифметического и логического типа следующий:              |

 ТИП[*ДЛИНА] N[*ДЛИНА][,N[*ДЛИНА]]...                      |

 где                                                       |

ТИП                                                        |
   - один  из  "integer",  "real",  "logical",   "double   |
     precision", "complex", "double complex";              |

ДЛИНА                                                      |
   - либо ЦЕЛАЯ КОНСТАНТА БЕЗ ЗНАКА, либо                  |
     ( ЦЕЛОЕ КОНСТАНТНОЕ ВЫРАЖЕНИЕ ) ;                     |

N  - имя переменной, параметра, массива,  функции,  фор-   |
     мального параметра процедуры или описатель массива.   |



   9.1.2. Инструкция описания текстового типа


   Инструкция описания текстового типа имеет вид:

      character [*ДЛИНА] ИМЯ[,ИМЯ]...


где ДЛИНА -  дескриптор  длины,  задающий  длину  в  литерах
текстовойпеременной, элемента текстового массива, текстового
параметра, результата обращения к текстовой функции,  а  ИМЯ
имеет один из видов:

      N[*ДЛИНА]
      M[(P)][*ДЛИНА]

где N - имя одного из следующих об'ектов: переменной,  пара-
метра,  функции  или фомального параметра процедуры; M - имя
массива, M(P) - дескриптор массива.

   Дескриптор длины может быть целой константой  без  знака,
целым константаным выражением в скобках, имеющим положитель-
ное значение, или звездочкой в скобках.

   Дескриптор длины, следующий за словом "character",  обоз-
начает длину всех упомянтых в инструкции об'ектов, у которых
нет собственного дескриптора длины. Так, в инструкции:

      character*4 list,prefix*1,table(100)*8

содержатся следующие описания:

 list имеет дескриптор длины 4;
 prefix имеет дескриптор длины 1;
 table имеет дескриптор длины 8;




54

   Дескриптор длины, следующий непосредственно за  об'ектом,
относится   только  к  этому  об'екту.  Когда  декларируется
массив,  длина  относится  к  каждому  его  элементу.   Если
дескриптор длины отсутствует, как в инструкции

      character a,в

длина принимается равной единице.

   Дескриптор длины "(*)" означает, что  длина  должна  быть
определена иным образом, и применим только в случаях внешних
функций, формальных параметов внешних процедур  и  текстовых
параметров.  В  остальных  случаях  дескриптор  длины должен
иметь вид целой положительной константы или целого выражения
в  скобках  с  положительным  значением. В случае параметра,
как, например, в

      character sffx*(*)
      parameter(sffx='АВГУСТ')

длина sffx берется из значения в инструкции  "parameter".  В
данном  примере  она  равна 6. В случае описания формального
параметра при определении внешней процедуры, как в случае

      character function delete(a)
      character a*(*)

длина формального параметра  (в  данном  случае  a)  берется
равной  длине  фактического  параметра при вызове процедуры.
Если  фактический  параметр -  имя  массива,  длина  берется
равной  длине  его  элемента.  В  случае имени в определении
внешней функции, например:

      character*(*) function fillup(a,в)

длина имени функции (в данном  случае  fillup)  определяется
длиной, заданной в вызывающей ее программной компоненте.

   Если явный дескриптор длины для внешней функции задан как
в  вызывающей  программной  компоненте,  так  и  в  описании
функции, эти дескрипторы должны быть согласованы, или следу-
ет в описании функции использовать дескриптор (*), как пока-
зано выше. Дескриптор длины  текстовой  функции-формулы  или
формального  параметра текстовой функции-формулы должен быть
всегда целой положительной константой или целым  константным
выражением с положительным значением.


   9.2. Инструкции неявного описания типа


   К этой группе можно отнести три  инструкции:  "implicit",
"parametter" и "dimension". Инструкция "implicit" служит для
изменения или подтверждения правил задания  вещественного  и
целого  типа  по  умолчанию  по  виду имени и для задания по
умолчанию по виду имени других типов. Инструкция "parameter"
используется,   чтобы   дать   константе  имя-идентификатор.
Инструкция "dimension" используется для описания  массива  и
задания его размерности.





                                                          55

   9.2.1. Инструкция implicit


   Данная инструкция имеет вид:

   implicit ТИП(A[,A]...)[,ТИП(A[,A]...)]..

Где ТИП - одно из следующих ключевых слов:

    integer
    real
    double precision
    complex
    logical
    character [*ДЛИНА]

Здесь ключевое слово задает тип данных, A -  это  либо  одна
буква,  либо диапазон букв, разделенный знаком минус. Напри-
мер, инструкция:

      implicit integer(a,x-z),real(w),
     *double precision(в-h,o-v)

устанавливает, что имена, начинающиеся с a, с букв от x до z
будут  по умолчанию относиться к целому типу, имена, начина-
ющиеся с w, по умолчанию будут  относиться  к  вещественному
типу,  имена,  начинающиеся  с  букв  от в до h ; от o до v,
будут относиться к типу "двойная точность".

   Атрибут  ДЛИНА  ключевого  слова  "character"  обозначает
дескриптор длины. Например, следующая инструкция:

 implicit character*8(с)

устанавливает, что имена, начинающиеся с буквы с,
будут по умолчанию относиться к типу character с
дескриптором длины 8.

   Декларация неявного задания типа действует только в  пре-
делах  программной  компоненты,  в  которой она находится, и
может отменяться инструкцией описания типа  или  инструкцией
"function"  в  той  же  подпрограмме.  Инструкция "implicit"
должна предшествовать всем остальным  инструкциям  описания,
кроме  инструкции  "parameter", и не может быть использована
для замены типа встроенных функций.

   В программной компоненте могут встречаться  две  и  более
инструкции  "implicit", но каждая буква может использоваться
для неявного задания типа только один раз.


   В  Фортране-77  ОС   ДЕМОС   возможности   инструкции   |
"implicit" значительно расширены:                          |

1)  При указании типа в инструкции "implicit" может  ис-   |
    пользоваться конструкция вида:                         |

 ТИП*ДЛИНА                                                 |






56

     аналогично оператору описанию арифметического и ло-   |
     гического типов в Фортране-77 ОС ДЕМОС.               |

2)  Инструкция "implicit" может записываться  вперемешку   |
    с  другими  инструкциями  описания, областью ее дей-   |
    ствия является программная единица от  "implicit"  и   |
    до  оператора  "end",  либо  до очередной инструкции   |
    "implicit", если она изменяет трактовку тех же самых   |
    начальных символов.                                    |

3)  Введен новый описатель типа  "undefined"  (неопреде-   |
    лен),   который  может  использоваться  совместно  с   |
    инструкцией "implicit". Так, инструкция:               |

      implicit undefined (A-H,O-Z)                         |

отменяет неявное определение типов для переменных, начи-   |
нающихся с букв A-H или O-Z.                               |

4)  Совместно с инструкцией "implicit"  могут  использо-   |
    ваться    описатели    класса    памяти:   "static",   |
    "automatic".                                           |

   Следует помнить о том, что прописные буквы в  иденти-   |
фикаторах  сводятся  компилятором  к  строчным, если  не   |
указан специальный режим трансляции. В последнем  случае   |
в   операторе  "implict"  разрешается  указывать  только   |
строчные буквы. Однако, в любом режиме, действие  опера-   |
тора  "implicit"  распространяется  и на прописные, и на   |
строчные буквы.                                            |



   9.2.2. Инструкция parameter


   Инструкция "parameter" имеет вид:

      parameter(ПАР=W[,ПАР=W]...)

где ПАР - идентификатор,  W  -  константное  выражение.  Имя
(ПАР) и константное выражение (W) должны быть согласованы по
типу следующим образом:

1)  если тип ПАР - арифметический, W должно  быть  арифмети-
    ческим константным выражением;

2)  если тип ПАР -  логический,  W  должно  быть  логическим
    константным выражением;

3)  если  тип  ПАР -  текстовой,  W  должно  быть  текстовым
    константным выражением;

4)  если в константное выражение входит параметр, он  должен
    быть  определен  ранее  в  предшествующей  или в этой же
    инструкции "parameter";

5)  значение W присваивается параметру ПАР по правилам,  ус-
    тановленным для инструкции присваивания;





                                                          57

6)  параметр должен быть определен в программной  компоненте
    только один раз и в инструкции "parameter";

7)  если к имени параметра не  должно  применяться  исходное
    неявное  задание  типа, тип параметра должен быть описан
    явно в инструкции описания типа или  быть  задан  неявно
    при  помощи  инструкции "implicit". Описание типа, явное
    или   неявное,    должно    предшествовать    инструкции
    "parameter";

8)  текстовые параметры с длиной, отличной от 1, нуждаются в
    дескрипторе   длины   в   инструкции   "character"   или
    "implicit".

   Область действия параметра -  программная  компонента,  в
которой  он  описан.  После того как параметр определен, его
можно использовать как простое выражение  в  выражении  и  в
инструкции data. Параметр нельзя использовать для формирова-
ния комплексной  константы.  Следующий  пример  иллюстрирует
применение инструкции parameter:

      character name*(*),prefix*3
      logical q
      parameter (name='ИАЭ',
     * prefix='tlt',pi=3.141592818,
     * lines=56,q=.false.)

   Константа и параметр, вообще говоря, не являются  взаимо-
заменяемыми. Параметр можно использовать только там, где это
явно разрешено, например в качестве простого выражения в вы-
ражении  или  в инструкции "data". Параметр нельзя использо-
вать,  например,  для  обозначения  текстовой  константы   в
инструкции "format".


   9.2.3. Инструкция dimension


   Инструкция dimension имеет вид:

      dimension M(P)[,M(P)]...

где M(P) - дескриптор массива. Несмотря на то  что  описание
каждого  массива  может встречаться в программной компоненте
только  один  раз,  имя  массива,  описанного  в  инструкции
"dimension", может появляться также без информации о размер-
ности в инструкции описания типа  или  инструкции  "common".
Например:

      dimension a(0:99),list(50,2,-10:10)

информация о размерности массива может быть задана  описате-
лем массива в инструкциях описания типа и "common".











58

   9.3. Распределение памяти


   В Фортране-77 имеются две инструкции,  которые  управляют
распределением  памяти  между  программными  компонентами  и
внутри программной компоненты. Инструкция "common" позволяет
программным  компонентам совместно использовать блок памяти.
Инструкция "equivalence" позволяет связать  разные  имена  с
одной и той же физической памятью.


   9.3.1. Общая память


   Отрезок памяти, состоящий  из  последовательности  единиц
памяти  и  используемый программными компонентами совместно,
называется общей памятью. Принцип работы с ней следующий:

1)  Общая область памяти, доступная  двум  или  более  прог-
    раммным компонентам, вводится в употребление инструкцией
    "common".

2)  Переменные и массивы размещаются в общей области соглас-
    но их расположению в инструкции "common".

3)  переменные и массивы,  находящиеся в общей памяти,  свя-
    зываются между собой согласно их описаниям и инструкциям
    "common" соответствующих программных компонент.

   Использование общей памяти предоставляет  следующие  воз-
можности:

1)  Пространтво, отводимое в памяти под большие таблицы  или
    массивы, можно совместно использовать в нескольких прог-
    раммных компонентах, а не включать таблицу или массив  в
    каждую из них. Таким образом, можно эффективнее расходо-
    вать память.

2)  Большие об'емы данных  можно  передавать  из  вызывающей
    программы  в  подпрограмму,  не используя длинный список
    параметров. Таким образом, повышается эффективность свя-
    зи между подпрограммами. Сведения о месте данных в общей
    памяти можно найти в таблицах распределения.

3)  Использование общей памяти позволяет хорошо организовать
    программу и удобно для программистов.


   9.3.1.1. Статическая и динамическая память


   В Фортране-77 есть статическая и динамическая память.

   Статическая память - это память, которая отводится выпол-
няемой  программе операционной системой перед началом выпол-
нения программы и остается в распоряжении программы в  тече-
ние  всего  времени  выполнения.  Динамическая  память - это
память, которая распределяется при входе в блок и освобожда-
ется при выходе из него.





                                                          59

   Следуещее описание приведено в соответствии со  стан-   |
дартом Фортрана-77, правила выделения памяти в Фортране-   |
77 ОС ДЕМОС приводятся ниже.                               |

В Фортране-77 память, отводимая операционной системой в  го-
ловной  программе  под  переменные  и  массивы, статическая.
Память, отводимая во внешних  процедурах  (т.е.  функциях  и
подпрограммах),  -  динамическая,  если  только  при  помощи
инструкции "save" не задано противное.

   В Фортране-77 имеются два типа общей памяти: непомеченная
и  помеченная.  Непомеченный  общий блок доступен всем прог-
раммным компонентам, где он описан; он  определяется  стати-
чески.  Непомеченный  общий блок не имеет имени, он один для
всей исполняемой программы. Помеченный общий блок  распозна-
ется  по  имени - идентификатору и доступен всем программным
компонентам, где описана общая память  с  таким  именем.  Он
может быть определен статически или динамически в зависимос-
ти от того, где описан.

   Если помеченный общий блок описан в главной программе, он
отводится на все время выполнения программы. Если помеченный
общий блок описан в подпрограмме, но не описан в  вызывающей
еепрограмме, он отводится при входе в программную компоненту
и освобождается при выходе из нее.  Помеченный  общий  блок,
отведенный в программной компоненте, существует при выполне-
нии всех подчиненных вызовов и возвратов.



   В Фортране-77 ОС ДЕМОС действуют  иные  соглашения  о   |
типе  выделяемой  памяти.  Память,  выделяемая под общие   |
блоки, всегда статическая, она сохраняется, если  только   |
не   используется   механизм   загрузки  с  перекрытиями   |
(overlay). Локальные переменные по умолчанию размещаются   |
в  статической  памяти и инициализируются нулем, если не   |
указано противное. Можно разместить локальные переменные   |
в  динамической памяти (то есть в стеке, как это принято   |
в  программах  на  языкк  Си),  описав  их  в  операторе   |
"automatic":                                               |

      automatic N[,N]                                      |

Для принудительного размещения переменных в  статической   |
памяти  служит описатель "static". Описатели "automatic"   |
и  "static"  могут  также  появляться  и   в   операторе   |
"implicit", они могут использоваться для описания масси-   |
вов наравне с оператором "dimension". При этом  перемен-   |
ные, описанные как "automatic", не могут быть элементами   |
общих блоков, или инициализироваться с помощью оператора   |
"data".  Нельзя указывать эквивалентность между перемен-   |
ными различных классов памяти. Действие оператора "save"   |
состоит  в проверке того, что соответствующие переменные   |
расположены   в   статической   памяти   (не   об'явлены   |
"automatic")  и  выдаче  диагностики при нарушении этого   |
требования.                                                |

   Непомеченный общий блок эквивалентен  помеченному  со   |
специальным именем.                                        |





60

   9.3.1.2. Инструкция common


   Инструкция "common" имеет вид:

   common[/[ОБ]/]СПИСОК[[,]/[ОБ]/СПИСОК]...

где ОБ - имя общего блока, СПИСОК - список имен  переменных,
имен  массивов  и  дескрипторов  массивов.  Каждое имя может
встречаться только один раз  в  одной  инструкции  "common".
Формальные  параметры и имена функций не могут встречаться в
инструкции "common". Если имя общего  блока  опущено,  общий
блок считается непомеченным. Если опущено имя первого из об-
щих блоков, описанных в  инструкции  "common",  то  и  соот-
ветствующие косые черточки можно опустить. Список, следующий
за именем общего блока, обозначает элементы данных,  состав-
ляющие этот общий список. Например, инструкция:

      common a,b(5,5)/dbase/name,
     * addr,age/dlist/
      n,work(15),pay(15)


предписывает следующее размещение об'ектов в общей памяти: a
и  b  помещаются  в непомеченный общий блок; name,addr и age
помещаются в общий блок dbase; n,work и pay помещаются в об-
щий блок dlist.

   Переменные и массивы общего блока размещаются в общей па-
мяти  в  том  порядке,  в каком они перечислены в инструкции
"common". Имена переменных и массивов в  программных  компо-
нентах, ссылающихся на один общий блок, не обязаны быть оди-
наковыми. Однако об'екты должны быть согласованы по порядку,
типу и количеству.

   Две последовательные косые черты обозначают  непомеченный
общий блок. Например, в инструкциях:

      common a,b/albl/с,d//е,f
      common/albl/g,h//i,j

переменные a,b,e,f,i и j  помещаются  в  непомеченный  общий
блок в таком именно порядке. Переменные с,d,g и h помещаются
в общий блок, помеченный albl, в таком именно порядке.  Спи-
сок  имен  переменных и массивов, следующих после каждого из
последовательных вхождений имени общего блока,  рассматрива-
ется как продолжение предыдущего описания общего блока.


   9.3.1.3. Организация памяти для общих блоков


   Общий блок состоит из последовательности  единиц  памяти.
Это  единицы памяти об'ектов из списка переменных и массивов
общегоблока в том порядке, в каком они написаны в инструкции
"common".  Число единиц памяти, необходимое для хранения об-
щего блока, называется его размером.

   В выполняемой программе все помеченные общие блоки,  опи-
санные  в  различных программных компонентах под одним и тем
же именем, должны иметь одинаковую длину. Непомеченные общие
блоки,  описанные  в разных программных компонентах выполня-


                                                          61

емой программы, не обязаны иметь одинаковую длину.

   В выполняемой программе все общие блоки  с  одним  именем
имеют общую первую единицу памяти. Тем самым устанавливается
соответсвие между переменными в разных программных компонен-
тах.

   Если текстовая переменная или массив включается  в  общий
блок, этот общий блок должен содержать только текстовые дан-
ные.


   В ОС ДЕМОС такого ограничения нет. Однако  в  случае,   |
если за текстовыми переменными в общем блоке следуют не-   |
текстовые (integer, real,  complex,  double)  требуется,   |
чтобы  общая  длина  текстовых  переменных в байтах была   |
кратна двум (нетекстовые переменные могут размещаться  в   |
памяти только с четного адреса).                           |


   Помеченный общий блок может стать неопределенным при  вы-
полнении  явного  или неявного возврата из внешней процедуры
из-за свойств динамической памяти  Фортрана-77.  Однако  при
тех  же условиях непомеченный общий блок не становится неоп-
ределенным. Об'ектам из помеченного общего блока можно зада-
вать  начальное  значение в инструкции инициализации "data".
Об'екты из непомеченного общего блока, однако, нельзя иници-
ализировать с помощью инструкции "data".


   Приведенных ограничений нет в Фортране-77 ОС ДЕМОС.     |



   9.3.2. Эквивалентность памяти


   Инструкция "equivalence" позволяет отвести под переменные
и  массивы одни и те же единицы памяти. Эта возможность поз-
воляет разными способами ссылаться на одну и ту же  информа-
цию.  Инструкция "equivalence" применима к об'ектам в преде-
лах одной программной компоненты.

   Инструкция equivalence имеет вид:

 equivalence (СПИСОК)[,(СПИСОК)]...

где СПИСОК - это список имен переменных, имен элементов мас-
сивов,  имен массивов и имен текстовых подцепочек. Любое вы-
ражение в индексе или указателе подцепочки должно быть целым
константным  выражением.  Инструкция "equivalence" позволяет
совместить отрезки памяти, занятые об'ектами, имена  которых
упоминаются  в  инструкции "equivalence". Совмещаются первые
единицы памяти элементов из  инструкции  "equivalence",  что
вызывает   совмещение  также  и  других  элементов.  Влияние
инструкции "equivalence" ограничивается только установлением
соответствия между единицами памяти. Эта инструкция никак не
влияет на типы и структуры данных.

   Имена формальных параметров и функций не могут встречать-
ся в инструкции "equivalence".



62

   Если в инструкции "equivalence" встречается имя  массива,
соответствие  устанавливается  точно так же, как если бы был
задан его первый элемент. Если  в  инструкции  "equivalence"
задан элемент массива, число индексных выражений должно быть
равно числу измерений в описании этого массива.


   9.3.2.1. Правила использования инструкции equivalence


   При использовании инструкции "equivalence"  нельзя  зада-
вать  такое  расположение  единиц памяти, которое невозможно
физически. В этот разряд попадают следующие случаи:

1)  инструкция "equivalence" не может задавать многократного
    вхождения  одной и той же единицы памяти в отрезок памя-
    ти, как в случае:

      real х(3),y
      equivalence(х(2),y),(х(3),y)


2)  инструкция "equivalence" не  может  задавать  размещения
    последовательных  единиц памяти в непоследовательных по-
    зициях, как в случае:

      real х(2)
      complex y(2)
      equivalence(х(1),y(1)),(х(2)),y(2))


3)  Совмещение об'екта с элементом общего блока  приводит  к
    тому,  что  об'ект  сам  входит в этот общий блок. Такое
    совмещение может  провести  к  удлинению  общего  блока.
    Однако,  недопустимо  совмещение, при котором общий блок
    должен был бы удлиниться спереди, за  счет  появления  в
    его начале новых элементов.

4)  Цепочки литер можно совместить при помощи эквивалентнос-
    ти только с другими цепочками литер. Цепочки литер можно
    задавать как текстовые переменные, имена текстовых  мас-
    сивов,  имена  элементов  текстовых  массивов  или имена
    текстовых подцепочек. Совмещаются первые единицы памяти,
    занятые  об'ектами,  входящими  в список эквивалентности
    инструкции "equivalence", что приводит также к  совмеще-
    нию других текстовых элементов.

5)  В Фортране-77 одномерный индекс в  списке  "equivalence"
    для  n-мерного массива интерпретируется так, как если бы
    индексное выражение стояло в самой левой позиции, а  не-
    достающие  индексные  выражения принимали значения соот-
    ветствующих нижних границ.


   9.3.3. Индексация массивов


   При управлении памятью  необходимо  вычислять  последова-
тельный  номер,  по которому осуществляется доступ в массив.
Независимо от размерности и границ изменения  индексов  эле-
менты  массива  упорядочены  в  отрезке памяти по столбцам и
представляют собой последовательность элементов  данных.  Во


                                                          63

время выполнения программы процессор всегда перед обращением
к элементу массива преобразует список индексов в  последова-
тельный номер элемента массива. Пример:

      integer l(-5:6,-3: 7)
      ...       l1 m1 l2 m2
      l(2, 4)=1
        i1 i2

Относительный номер элемента l(2,4) будет вычислен так:
 n = (i2-l2)*(m1-l1+1) + (i1-l1) =
 =(4-(-3))*(6-(-5)+1)+(2-(-5))=7*12+7=91


   9.4. Инициализация данных


   Для инициализации переменных  и  элементов  массивов  при
загрузке выполняемой программы может использоваться инструк-
ция "data".  Об'екты  данных,  не  упомянутые  в  инструкции
"data", не определены в момент начала выполнения программы и
должны определяться впоследствии до обращения к ним.


   9.4.1. Инструкция data


   Инструкция data имеет вид:

data СПИМЕН/СПКОНСТ/[[,]СПИМЕН/СПКОНСТ/]...

где СПИМЕН - список  имен  переменных,  массивов,  элементов
массивов,  подцепочек и неявных do-списков, а СПКОНСТ - спи-
сок констант вида:

      A[,A]...

где каждое A - это константа или параметр  либо  коэффициент
повторения  вида N* со следующей за ним константой или пара-
метром, что означает N последовательных вхождений  константы
или  параметра.  Например, запись 4*3.14 эквивалентна списку
3.14,3.14,3.14,3.14. Пример инструкции "data":

      real a(3),в
      integer r,i(4),р
      character *4 list(3)
      logical q
      complex с
      parametr (r=4)
      data a,в/1.23е4,0.,16,0/,
     * i/r*0/,list/2*'abcd',
     * 'done'/,q/.true./,с/(3.4,4.123)/

здесь следующие об'екты определяются  прежде,  чем  начинает
выполняться программа (<- означает определение):

 a(1)<- 1.23е4 ,a(2) <-0. , a(3)  <- 16.  ,
 в   <- 0.     ,i(1) <-0  , i(2)  <-  0   ,
 i(3)<- 0      ,i(4) <-0  ,list(1)<-'abcd',
 list(2)<-'abcd', list(3)<-'done' ,
 q<-.true.,       c<-(3.4 , 4.123)



64


   При использовании инструкции "data" необходимо  придержи-
ваться следующих правил:

1)  число элементов в СПКОНСТ должно  соответствовать  числу
    об'ектов, заданных в СПИМЕН;

2)  формальные параметры, имена функций и об'екты из непоме-
    ченного  общего блока не должны упоминаться в инструкции
    "data";

3)  имена об'ектов из помеченного общего блока могут  упоми-
    наться  в  инструкции "data" только в программной компо-
    ненте "block data".


   В Фортране-77 ОС ДЕМОС инициализация элементов общего   |
блока  может производиться в любой программной компонен-   |
те. При этом не допускается инициализация элементов  од-   |
ного  и того же общего блока в разных программных компо-   |
нентах, если только они не транслируются совместно.        |


   Инициализация данных  достигается  присваиванием  первого
значения  из СПКОНСТ первому об'екту из СПИМЕН, второго зна-
чения из СПКОНСТ второму об'екту из СПИМЕН  и  т.д.  поэтому
тип  об'екта  в СПИМЕН должен быть согласован с соответству-
ющим значением в СПКОНСТ. Если об'ект в  СПИМЕН -  арифмети-
ческий, соответствующее значение в СПКОНСТ должно быть ариф-
метическим.  Если  необходимо,  производится  преобразование
типов.  Если  об'ект  в СПИМЕН - логический, соответствующее
значение в СПКОНСТ должно быть логическим. Аналогично,  если
об'ект   в  СПИМЕН  текстовый,  соответствующее  значение  в
СПКОНСТ должно быть текстовым. Любые выражения,  входящие  в
об'екты из СПИМЕН, такие, как индексы или выражение в подце-
почках, должны быть целыми константными выражениями.

   Если атрибут "длина" текстового об'екта из СПИМЕН  больше
длины  соответствующей текстовой константы, текстовой об'ект
дополняетсяпробелами справа. Если атрибут "длина" текстового
об'екта  из  СПИМЕН  меньше  длины соответствующей текстовой
константы, левые литеры константы сохраняются, а лишние  ли-
теры справа игнорируются. Каждая текстовая константа исполь-
зуется для инициализации одного и только  одного  текстового
об'екта.


   9.4.2. Неявные do-списки


   Элемент СПИМЕН может представлять собой неявный do-список
для инициализации элементов массива. НЕЯВНЫЙ DO-СПИСОК имеет
вид:

      (DO-СП,I=M1,M2[,M3])

где DO-СП - список имен элементов массивов или  неявных  do-
списков,   I,  M1, M2 и M3 задают управляющую инфоормацию, а
именно:





                                                          65

I  - целая переменная, используемая в  качестве  управляющей
     (использование  переменной I не влияет на ее определен-
     ность в программе);

M1
   - начальное значение, заданное целым константным  выраже-
     нием;

M2
   - предельное значение, заданное целым константным выраже-
     нием;

M3
   - значение приращения, заданное целым константным выраже-
     нием. (если M3 опущено, приращение  по умолчанию счита-
     ется равным 1.).

   Число итераций неявного do-списка должно быть положитель-
ным.  Целые  константные  выражения, используемые в качестве
M1, M2 и M3 могут включать управляющие переменные других не-
явных  do-списков.  Примеры инструкций "data" с неявными do-
списками:

      data limit/1000/,(a(i),i=1,25)/25*0./
      data ((a(i,j),j=1,5),i=1,10)/50*1.1/
      data (х(1,i),i=1,100)/100*1.1/
      data ((a(i,j),j=1,1),i=1,3)
     * /4*0.,25.3,4е-6/



   9.4.3. Программная компонента block data


   Программная компонента "block data" дает возможность ини-
циализировать  переменные и массивы из помеченных общих бло-
ков. Структура программной компоненты "block data" такова:

      block data [ПОДПР]
       .
       . Инструкции описания
       .
      end

   По  этой  схеме  программная  компонента   начинается   с
инструкции  "block data",  заканчивается инструкцией "end" и
может  включать  только   следующие   инструкции   описания:
"implicit",   "parameter",  "dimension",  "common",  "save",
"equivalence", "data" и инструкции описания типа. Допускают-
ся  также  строки комментариев. Поскольку программная компо-
нента "block data" обрабатывается независимо   от  остальных
программных  компонент,  при  инициализации любой переменной
или элемента массива из помеченного общего блока надо описы-
вать весь этот общий блок.

   Инструкция "block data" имеет вид

      block data[ПОДПР]

где ПОДПР-имя программной компоненты "block data", в которую
входит эта инструкция. Имя ПОДПР может быть опущено. Оно яв-
ляется внешним именем программной компоненты и  должно  быть


66

уникально.   Так,   никакие   две   программные   компоненты
"block data" не должны иметь одно и то же внешнее имя,  хотя
в  выполняемую  программу может входить более одной подпрог-
раммы "block data". Однако выполняемая  программа  не  может
содержать  более  одной неименованной программной компоненты
"block data". Следующий пример иллюстрирует применение аппа-
рата "block data":

      block data lmdata
      real disp(10,50)
      integer rows,cols
      common/lmat/rows,cols,disp
      data rows, cols/10,50/,
      ((disp(i,j),i=1,10),j=1,50)/500*0.01/
      end

   При помощи программной компоненты "block data" можно ини-
циализировать только переменные и элементы массивов из поме-
ченных общих блоков.


   В ОС ДЕМОС инициализируются элементы любых общих бло-   |
ков.                                                       |



   9.5. Инструкции описания, относящиеся  к подпрограммам


   Инструкции описания применимы в равной  степени  ко  всем
типам программных компонент. Три инструкции относятся только
кподпрограммам: "external", "save" и "intrinsic". Инструкция
"external"  используется для обозначения того, что некоторое
имя - это имя внешней  процедуры  или  формального  парамет-
ра/процедуры. Инструкция "save" позволяет сохранить значения
переменных  и  массивов  после  выполнения  в   подпрограмме
инструкции  "return" или "end" и тем самым оставить их опре-
деленными для последующих вызовов подпрограммы или  для  ис-
пользования  их  как  данных  из  помеченного  общего блока.
Инструкция  "intrinsic"  позволяет  указать,  что  некоторое
имя - это имя стандартной функции.


   9.5.1. Инструкция external


   Инструкция "external" имеет вид:

      external ПРОЦ[,ПРОЦ]...

где ПРОЦ - имя внешней процедуры, имя  формального  парамет-
ра/процедуры   или   программной   компоненты  "block data".
Инструкция "external" часто используется  для  замены  стан-
дартной  функции  внешней процедурой, написанной пользовате-
лем. Кроме того, эта инструкция применяется  для  об'явления
идентификатора  именем  внешней  процедуры,  чтобы его можно
было передать подпрограмме.







                                                          67

      external abfcn
      call anyfcn(a,м,n,abfcn)


   Программная компонента, в которой встретилась  инструкция
"call",   независима   от  abfcn.  Это  имя  без  инструкции
"external" распознается не как имя внешней  функции,  а  как
имя  переменной. Инструкция "external" сообщает компилятору,
что abfcn - внешняя процедура, а не переменная.

   Если же в инструкции  "external"  встретилось  имя  стан-
дартной  функции, то это имя в данной программной компоненте
не будет рассматриваться как имя стандартной функции.


   9.5.2. Инструкция save


   Инструкция "save" имеет вид:

      save[A[,A]...]


где каждое A обозначает один из следующих об'ектов:

1)  имя помеченного общего блока,  перед  и  после  которого
    стоит наклонная черта, например:

      save/lmat/


2)  имя переменной или массива, например:

      save a,в


   Если список не задан,  инструкция  "save"  обрабатывается
так,  как  если  бы  список включал все допустимые об'екты в
этой программной компоненте.

   Действие инструкции "save" заключается в том,  что  пере-
численные в ней переменные, массивы и общие блоки не окажут-
ся неопределенными после выполнения в подпрограмме  инструк-
ции "return" или "end". Если переменная или массив, заданные
в инструкции "save", локализованы в подпрограмме и определе-
ны к моменту выхода из нее, их значения сохраняются к момен-
ту следующего вызова подпрограммы.

   Обычно при выходе из подпрограммы все переменные и масси-
вы  становятся неопределенными. Исключение составляют следу-
ющие случаи:

1)  переменные и массивы, заданные в инструкции "save";

2)  переменные и массивы из непомеченного общего блока,  ко-
    торый связан с главной программой;

3)  переменные и массивы из помеченного общего блока,  кото-
    рый  описан и в подпрограмме, и в вызывающей программной
    компоненте.




68

   Таким образом, состояние  определенности  всех  об'ектов,
описанных  в  главной программе, непрерывно поддерживается в
процессе выполнения всей выполняемой  программы.  Инструкция
"save"  может  встретиться в главной программе, но она ни на
что не повлияет. Формальные параметры и  имена  процедур  не
могут встречаться в инструкции "save".

   В подпрограмме значения переменных и массивов из помечен-
ного  общего  блока  сохраняют свое состояние определенности
после выхода, если помеченный  общий  блок  был  упомянут  в
инструкции "save". Однако при выходе из другой подпрограммы,
вызывающей эту и имеющей доступ к тому же помеченному общему
блоку  без  соответствующей  инструкции "save", переменные и
массивы из помеченного блока потеряют  состояние  определен-
ности. Таким образом, инструкцию "save", в которой задан по-
меченный общий блок, следует включать в каждую подпрограмму,
имеющую доступ к этому общему блоку.

   Каждое имя может встречаться только  в  одной  инструкции
"save" в пределах одной программной компоненты.


   Инструкция "save" в Фортране-77 ОС ДЕМОС не оказывает   |
никакого  действия,  однако  ее использование желательно   |
для   совместимости   с   другими   реализациями   языка   |
Фортран-77.                                                |



   9.5.2.1. Инструкция intrinsic


   Инструкция "intrinsic" имеет вид:

      intrinsic ФУНКЦ[,ФУНКЦ]...

где ФУНКЦ - имя стандартной функции. Если имя упоминается  в
инструкции  "intrinsic", оно тем самым декларируется как имя
стандартной функции. Чаще всего эта инструкция  используется
для  того,  чтобы можно было передать подпрограмме имя стан-
дартной функции, например:

      intrinsic sin
      call dofcn(а,м,n,sin)


При вызове следующей подпрограммы:

      subroutine dofcn(array,rows,cols,fcn)
      real array (rows,cols)
      integer rows,cols
      do 5 i=1,rows
      do 5 j=1,cols
    5 array(i,j)=fcn(array(i,j))
      return
      end

   Подпрограмма применяет функцию к каждому элементу  масси-
ва.   Как   в   случае   инструкции  "external",  инструкция
"intrinsic" не позволяет завести переменную вместо  функции,
заданной  в  качестве  фактического  параметра  в вызывающей
программной компоненте.


                                                          69


   Необходимо помнить, что в пределах одной программной ком-
поненты  никакое  имя  не  может  встречаться одновременно в
инструкциях "intrinsic" и "external".  Стандартные  функции,
реализованные методом генерации вставок в об'ектную програм-
му, не могут упоминаться в инструкции  "intrinsic".  К  этой
категории относятся стандартные функции преобразования типов
(int, ifix, idint, float, sngl, real,  dble,cmplx,  ichar  и
char) и стандартные функции выбора наибольшего и наименьшего
значения (max, max0, amax1, amax0, max1, min,  min0,  amin1,
dmin0  и  min1).  Каждое  имя стандартной функции в пределах
программной компоненты  может  встречаться  только  в  одной
инструкции "intrinsic".

   Появление  имени   стандартной   функции   в   инструкции
"intrinsic" никак не влияет на свойства самого этого имени.
















































70




                10. ИНСТРУКЦИИ ПРИСВАИВАНИЯ


   Инструкция  присваивания  используется  для  присваивания
значения  переменной  или  элементу массива, после чего этот
об'ект становится определенным. В  Фортране-77  имеются  три
вида присваиваний: арифметическое, логическое и текстовое. К
ним вплотную примыкает инструкция "assign", с помощью  кото-
рой  целой  переменной присваивается значение метки инструк-
ции,


   10.1. Арифметическое присваивание


   Арифметическая инструкция присваивания  используется  для
присваивания значения арифметического выражения арифметичес-
кой переменной или элементу массива. Арифметическая инструк-
ция присваивания имеет вид:

      ПЕР=ВЫР

где ПЕР - имя арифметической перемeнной или элемента арифме-
тического  массива, а ВЫР - арифметическое выражение, вычис-
ленное в том месте, где оно встретилось. Тип ПЕР должен быть
целым,  вещественным,  двойной  точности или комплексным. Во
время присваивания меняется только значение об'екта слева от
знака  равенства, а значения об'ектов, входящих в выражение,
сохраняются.  Фортран-77  допускает   преобразование   типов
об'ектов, находящихся по разные стороны знака равенства, как
показано в следующем примере:

      i=5  !(1)
      j=6  !(2)
      a=i*j+1 !(3)

   В инструкциях (1) и (2) i присваивается значение  5  и  j
присваивается значение 6. В инструкции (3) вычисляется целое
значение 31 выражения i*j+1; это значение  преобразуется  из
целого  в вещественное и старое значение a заменяется значе-
нием вещественного типа, равным 31.


   10.2. Логическое присваивание


   Логическая инструкция присваивания используется для прис-
ваивания значения логического выражения логической перемнной
или элементу  массива.  Логическая  инструкция  присваивания
имеет вид:

      ПЕР=ВЫР

где ПЕР - имя логической переменной или элемента логического
массива,  а  ВЫР -  логическое выражение, вычисленное  в том
месте, где  оно  встретилось.  Приведем  примеры  логических
инструкций присваивания:




                                                          71

      logical р,q,r,s,t
      real a,в,с
      integer i,j,к
      character u*5, v*2
      р=.true.
      q=a.gt.b
      r=i.ne.j.and.q
      s=a+b.le.с.and.(i+j)**2+k.gt.15.or.р
      t=v.eq.u(3:5)


   При  логическом  присваивании  значением  выражения   ВЫР
должна быть "истина" или "ложь".


   10.3. Присваивание литерных цепочек


   Текстовая инструкция присваивания используется для  прис-
ваивания значения текстового выражения текстовой переменной,
элементу массива или подцепочке. Текстовая инструкция  прис-
ваивания имеет вид:

      ПЕР=ВЫР

где ПЕР - имя текстовой переменной, элемента текстового мас-
сива или подцепочки, а ВЫР - текстовое выражение. При вычис-
лении текстового выражения ВЫР и присваивании  его  значения
ПЕР  никакая из изменяющихся (т.е определяемых) литерных по-
зиций в ПЕР не должна  использоваться  при  вычислении  ВЫР.
Если  длина  ВЫР  меньше длины ПЕР, значение ВЫР дополняется
справа пробелами до длины ПЕР. Если длина ВЫР  больше  длины
ПЕР,  значение  ВЫР  при  присваивании укорачивается справа.
Примеры текстовых присваиваний:

      character u*5, v*3, w*7
      v='авс'
      u=v//'de'
      w(4:5)=v(2:3)

   Присваивание подцепочке определяет только те литерные по-
зиции, которым делается присваивание.


   10.4. Инструкция assign


   Инструкция assign используется для присваивания целой пе-
ременной значения метки инструкции и имеет вид:

      assign M to I

где M-метка исполняемой инструкции или инструкции format  из
той  же  программной  компоненты, что и инструкция assign, а
I - имя целой переменной. Например:

      assign 5320 to ijump


   Когда целой  переменной  присвовено  значение  метки,  ее
нельзя  использовать  в  качестве арифметической переменной.
Целую переменную, которой была присвоена  метка,  можно  ис-


72

пользовать только в качестве указателя инструкции в инструк-
ции перехода  по  предписанию  или  для  задания  формата  в
инструкции ввода/вывода.

   Целую переменную, которой было присвоено значение  метки,
можно  переопределить  как  арифметическую и соответствующим
образом к ней обращаться.

   Многократное присваивание в одной инструкции и  использо-
вание   знака   присваивания   (т.е.=)  внутри  выражения  в
Фортране-77 не разрешаются.





















































                                                          73




                 11. ИНСТРУКЦИИ УПРАВЛЕНИЯ


   Выполнение инструкции управления влияет на порядок испол-
нения инструкций в программной компоненте. Обычно инструкции
выполняются последовательно  в  том  порядке,  в  каком  они
встречаются в программной  компоненте. Инструкции управления
позволяют изменять такую последовательность.


   11.1. Инструкции перехода


   Инструкции перехода используются для передачи  управления
в  программе на исполняемую инструкцию с меткой, указанной в
соответствующей инструкции перехода. В  Фортране-77  имеются
три типа интрукций перехода: инструкция безусловного перехо-
да, инструкция вычисляемого перехода и  инструкция  перехода
по предписанию.


   11.1.1. Инструкция безусловного перехода


   Инструкция безусловного перехода имеет вид:

      goto M

где M - метка исполняемой инструкции из той  же  программной
компоненты,  что  и инструкция безусловного перехода. Напри-
мер:

      goto 154


   Когда процессор выполняет инструкции безусловного перехо-
да, управление в программе передается на заданную инструкцию
и с этой точки продолжается обычное последовательное  выпол-
нение.


   11.1.2. Инструкция вычисляемого перехода


   Инструкция вычисляемого перехода имеет вид:

      goto(M[,M]...)[,]I

где I - целое выражение, а M - метка исполняемой  инструкции
из  той же программной компоненты, что и инструкция вычисле-
мого перехода. Среди заданных меток могут  быть  повторяющи-
еся.

   Пример инструкции вычисляемого перехода:







74

      goto(100,200,200,250,9000),kjmp+1


   Инструкция вычисляемого перехода выполняется так:

1)  целое выражение, обозначенное выше через i,  вычисляется
    в том месте, где оно встретилось;

2)  управление в программе передается на  инструкцию,  поме-
    ченную  i-й меткой из списка меток в инструкции вычисля-
    емого перехода.

   Точнее, в случае инструкции вычисляемого перехода вида:

      goto(M1,M2,...,MN),I

управление в программе передается на исполняемую  инструкцию
с  меткой  MI,  если  1<=I<=N.  Если I<1 или I>N, выполнение
программы продолжается с инструкции, следующей  за  инструк-
цией вычисляемого перехода.


   11.1.3. Инструкция перехода по предписанию


   Инструкция перехода по предписанию имеет вид:

      goto I[[,](M[,M]...)]

где I - целая пееменная, значение которой-метка, а M - метка
выполняемой инструкции из той же программной компоненты, что
и инструкция перехода по предписанию. Например:

      goto lbrnch,(100,400,14990)


   Когда исполняется инструкция перехода по предписанию, уп-
равление  в программе передается на исполняемую инструкцию с
меткой, значение которой было  присвоено  целой  переменной,
указанной  в  инструкции  перехода по предписанию, и обычное
последовательное выполнение продолжается с этого места. Если
в  инструкции присутсвует заключенный в скобки список меток,
то метка, значение которой присвоено  I,  должна  входить  в
этот  список.  Одна и та же метка может упоминаться в списке
более одного раза.


   11.2. Инструкции условного перехода


   Инструкции "if" в Фортране-77 служат для условного выпол-
нения  частей  программы. Арифметическая инструкция "if" ре-
ализует условное ветвление, логическая инструкция "if" - ус-
ловное  выполнение инструкции. Инструкции "if-then-else" ре-
ализуют условное выполнение фрагментов программы.









                                                          75

   11.2.1. Арифметическая инструкция if


   Арифметическая инструкция "if" имеет вид:

 if(ВЫР) M1, M2,M3

где ВЫР - арифметическое выражение, целое, вещественное  или
с  двойной  точностью, но не комплексное, а M1, M2, M3-метки
исполняемых инструкций из той же программной компоненты, что
и  эта  арифметическая  инструкция  "if". Одну и ту же метку
можно использовать в одной  арифметической  инструкции  "if"
более одного раза. Пример:

      if((a+в)**2-с)100,200,300

арифметическая инструкция "if" выполняется так:


1)  вычисляется выражение ВЫР;

2)  управление передается на инструкцию с меткой M1, M2  или
    M3,  если значение ВЫР соответсвенно отрицательно, равно
    нулю или положительно.

   После передачи управления по одной из заданных меток про-
должается последовательное выполнение программы.


   11.2.2. Логическая инструкция if


   Логическая инструкция "if" имеет вид:

      if(ВЫР)ИНСТР


где ВЫР - логическое выражение, а ИНСТР - любая  исполняемая
инструкция,  кроме  "do", структурной инструкции "if", "else
if","else", "end if", "end" или другой логической инструкции
"if".

Примеры:

      if(r.le.eps) go tо 4320
      if(a.lt.0.)a=0.0
      if(q) call matmpy(а,м,n,в,с)

   Логическая инструкция "if" выполняется следующим образом:

1)  вычисляется логическое выражение ВЫР;

2)  если значение ВЫР истинно, выполняется ИНСТР. Если  зна-
    чение  ВЫР  ложно, выполнение продолжается с инструкции,
    следующей за этой логической инструкцией "if".

   Вычисления логического выражения ВЫР и  выполнение  ИНСТР
независимы в том смысле, что обращение к функции в ВЫР может
влиять на переменные, входящие в состав инструкции ИНСТР.





76

   11.2.3. Конструкция if-then-else


   Структура блока "if-then-else" такова:

  if (ВЫР) then
  [IF БЛОК]
  else
  [ELSE БЛОК]
  end if


где IF БЛОК и ELSE БЛОК  -  одна  или  несколько  инструкций
Фортрана-77.  "else"  и "ELSE БЛОК" могут быть опущены. Воз-
можна и такая структура:

  if(ВЫР) then
  [IF-БЛОК]
  else if (ВЫР) then
  [ELSE-IF-БЛОК]
   .
   .
   .
  [другие ESLE-IF-БЛОКИ]
   .
   .
   .
  else
  [ELSE-БЛОК]
  end if

где опять же ELSE-БЛОК может быть опущен.

   Для  правильного  выполнения  конструкции  "if-then-else"
нужен  способ определять, какие из инструкций "if-then-else"
соответствуют друг другу. Этот механизм называется "уровнем"
инструкции.  Уровень  инструкции S равен n1-n2, где n1-число
структурных инструкций "if" от начала программной компоненты
до  S  включительно,  а n2-число инструкций "end if" в прог-
раммной компоненте до S, но не  включая  S.  Таким  образом,
уровень любой инструкции должен быть положительным или нуле-
вым, уровень структурных инструкций "if",  инструкций  "else
if",  "else"  и  "end if" должен быть положительным. Уровень
инструкции "end" программной компоненты должен быть нулевым.

   В конструкции "if-then-else" имеется структурная инструк-
ция if. Она имеет вид:

if(ВЫР)then

где ВЫР-логическое выражение.  Структурная  инструкция  "if"
выполняется процессором так:

1)  вычисляется логическое выражение ВЫР;

2)  если значение ВЫР  истинно,  выполнение  продолжается  с
    первой  инструкции  IF-БЛОКА. После выполнения последней
    инструкции IF-БЛОКА управление в программе передается на
    следующую  инструкцию "end if" с тем же уровнем, что и у
    соответствующей инструкции "if". Если IF-БЛОК пуст,  уп-
    равление  передается  на следующую инструкцию "end if" с
    тем же уровнем, что и у соответствующей инструкции "if".


                                                          77

    Если  последняя  инструкция  IF-БЛОКА выполняет передачу
    управления в другую часть  программной  компоненты,  эта
    управляющая инструкция выполняется соответствующим обра-
    зом;

3)  если значение ВЫР ложно, выполнение продолжается со сле-
    дующей  инструкции  "else if", "else" или "end if" с тем
    же уровнем, что и у инструкции "if". Управление не может
    быть передано внутрь IF-БЛОКА.

   Инструкция "else if" имеет вид:

      else if (ВЫР)then

где  ВЫР -   логическое   выражение.   Процессор   выполняет
инструкцию "else if" так:

1)  вычисляется логическое выражение ВЫР;

2)  если значение ВЫР  истинно,  выполнение  продолжается  с
    первой  инструкции  ELSE-IF-БЛОКА. После выполнения пос-
    ледней инструкции в ELSE-IF-БЛОКЕ управление  передается
    на следующую инструкцию "end if" того же уровня, что и у
    инструкции "else if". Если ELSE-IF-БЛОК пуст, управление
    передается  на  следующую  инструкцию  "end  if" того же
    уровня, что и у инструкции  "else  if".  Если  последняя
    инструкция ELSE-IF-БЛОКА выполняет передачу управления в
    другую часть  программной  компоненты,  эта  управляющая
    инструкция выполняется соответствующим образом;

3)  если значение ВЫР ложно, выполнение продолжается со сле-
    дующей инструкции "else if", "else" или "end if" того же
    уровня, что и у  инструкции  "else  if".  Управление  не
    может быть передано внутрь ELSE-IF-БЛОКА.

   Инструкция else имеет вид:

      else


   Управление передается в ELSE-БЛОК при ложном значении ло-
гического   выражения  в  структурной  инструкции  "if"  или
инструкции "else if". В противном случае продолжается  обыч-
ное последовательное выполнение программы после соответству-
ющей инструкции "end if". Управление не может быть  передано
снаружи внутрь ELSE-БЛОКА.

   Инструкция "end if" имеет вид:

      endif


   Инструкция  "end  if"   отмечает   окончание   очередного
IF-БЛОКА,  ELSE-БЛОКА или ELSE-IF-БЛОКА и не выполняет ника-
ких действий.

   Для каждой структурной инструкции "if" в программной ком-
поненте должна существовать своя инструкция "end if".






78

   11.3. Инструкция do


   Инструкция "do"  используется  для  задания  управляемого
цикла,  введения управляющей переменной, параметров индекси-
рования и указания границ тела цикла. В Фортране-77 управля-
емый цикл называется "do-циклом". Инструкция "do" имеет вид:

      do M[,]I=ВЫР1,ВЫР2[,ВЫР3]


где

M  - метка последней инструкции тела цикла;

I  - имя целой, вещественной или с двойной  точностью  пере-
     менной, которая в Фортране-77 называется DO-ПЕРЕМЕННОЙ;

ВЫР1
   - целое, вещественное или с двойной точностью  выражение,
     представляющее начальное значение "do-переменной";

ВЫР2
   - целое, вещественное или с двойной точностью  выражение,
     представляющее предельное значение "do-переменной";

ВЫР3
   - целое, вещественное или с двойной точностью  выражение,
     представляющее значение приращения для "do-переменной".

   Пример правильной инструкции "do":

      do 500 u=a+1,sqrt(в),eps/100



   11.3.1. Структура do-цикла


   Тело "do-цикла" состоит из последовательности исполняемых
инструкций,  следующих  за  инструкцией "do" до инструкции с
меткой M включительно. Строение цикла "do" подчиняется  сле-
дующим правилам:

1)  циклы "do" могут быть вложены, но не могут  перекрывать-
    ся;

2)  если структурная  инструкция  "if"  лежит  в  теле  "do-
    цикла",  то  и  соответствующая инструкция "end if" тоже
    должна лежать в теле этого "do-цикла";

3)  если инструкция "do" встречается в "if-блоке", "else-if-
    блоке",  "else-блоке",  то  и  весь "do-цикл" (т.е. тело
    "do-цикла") должен входить целиком в этот блок;

4)  инструкция с меткой M в "do-цикле" не может быть ни  од-
    ной  из следующих инструкций: безусловный переход, пере-
    ход по предписанию, вычисляемый переход,  арифметическая
    или структурная инструкция "if", "else if", "else", "end
    if", "return", "stop", "end" или другие инструкции "do".
    Если инструкция с меткой M - логическая инструкция "if",
    то она может содержать в себе любую исполняемую инструк-


                                                          79

    цию, кроме следующих: "do", "структурная инструкция if",
    "else if", "else", "end if", "end" или другая логическая
    инструкция "if".

   Одна и та же инструкция  может  быть  заключительной  для
двух и более вложенных "do-циклов".


   11.3.2. Выполнение do-цикла


   Назначение "do-цикла" - выполнить исполняемые  инструкции
из  тела  цикла  некоторое число раз. Это число определяется
управляющими параметрами, заданными в инструкции "do".  Про-
цесс выполнения "do-цикла" включает шаги:

1)  выполнение инструкции "do" и вход в "do-цикл";

2)  подсчет числа итераций;

3)  проверка числа итераций;

4)  выполнение инструкций, находящихся в теле "do-цикла";

5)  операции по управлению циклом;

6)  выход из "do-цикла".

   Вход в "do-цикл" осуществляется при выполнении инструкции
"do".  В этот момент вычисляются выражения ВЫР1, ВЫР2 и ВЫР3
и   определяются   соответствующие   управляющие   параметры
par1=ВЫР1,  par2=ВЫР2,  и  par3=ВЫР3. Выражения ВЫР1, ВЫР2 и
ВЫР3 преобразуются к типу переменной I, если типы не  согла-
сованы.  Приращение  par3 не может быть нулем и по умолчанию
равно единице.

   Число итераций получается как значение следующего выраже-
ния:

      мах(int((par2-par1+par3)/par3),0)


   Приращение может быть  положительным  или  отрицательным,
начальное и предельное значения могут принимать соответству-
ющие значения. Если par1>par2, число итераций равно нулю при
par3>0.   Аналогично,  число  итераций   равно  нулю,  когда
par1<par2 и par3<0.

   Обработка цикла начинается  с  проверки  числа  итераций.
Если  оно  равно  нулю, осуществляется выход из "do-цикла" и
выполнение продолжается  с  первой  исполняемой  инструкции,
следующей  за  последней  инструкцией этого "do-цикла". Если
заключительная  инструкция -  общая  для   нескольких   "do-
циклов",  продолжается  обработка  приращений  для остальных
"do-циклов", оканчивающихся данной инструкцией.

   Если число итераций положительно,  инструкции,  составля-
ющие  "do-цикл",  выполняются последовательно, пока не будет
обработана  заключительная  инструкция.  Это  одна  итерация
цикла, после которой требуется произвести приращение.




80

   Процесс обработки приращений включает следующие шаги:

1)  значение переменной цикла изменяется на значение  прира-
    щения par3;

2)  число итераций уменьшается на 1;

3)  повторяется описанная выше процедура обработки цикла.

   Управляющие параметры не могут быть изменены во время вы-
полнения  "do-цикла",  поскольку число итераций определено в
самом начале. Управляющую переменную  нельзя  переопределять
во время выполнения "do-цикла".

   Выход из "do-цикла" происходит тогда, когда число  итера-
ций уменьшится до нуля. Другие причины выхода из "do-цикла":

1)  выполнение инструкции "return" внутри тела "do-цикла";

2)  выполнение инструкции, передающей управление за  пределы
    тела "do-цикла";

3)  выполнение инструкции "stop" или ненормальное завершение
    программы.

   Обращение  к  подпрограмме  из  тела  "do-цикла"  или  из
инструкции  "do"  не влечет выхода из "do-цикла". При выходе
из "do-цикла" переменная цикла сохраняет последнее присвоен-
ное  ей  значение.  Войти  в  "do-цикл"  можно  только через
инструкцию "do".


   В Фортране-77 ОС ДЕМОС имеется дополнительная возмож-   |
ность  установить  режим  трансляции,  при котором любой   |
цикл выполняется хотя бы один раз. Этот режим  использу-   |
ется  для  совместимости с некоторыми реализациями языка   |
Фортран-4, в которых циклы всегда  выполняются  хотя  бы   |
один   раз   (например,   большинство   реализаций   для   |
ОС-IBM/370 или ОС ЕС).                                     |



   11.4. Инструкция continue


   Инструкция "continue" обозначает точку для ссылки в прог-
рамме  на  Фортране, при ее выполнении не происходит никаких
действий. Она имеет вид:

      continue


   Инструкция continue часто используется в качестве  заклю-
чительной инструкции "do-цикла", как в этом примере:

      do 50 i=1,n
      if(х(i).lt.0.)goto 50
      sum=sum+х(1)
      prod=prod*х(i)
50    continue




                                                          81

   11.5. Инструкции stop и pause


   Инструкция "stop" имеет вид:

      stop[N]

где N - целая константа  не  более  чем  из  пяти  цифр  или
текстовая  константа.  Когда  процессор выполняет инструкцию
"stop", выполнение программы завершается, а значение N оста-
ется  доступным и используется так, как предусмотрено реали-
зацией.

   Инструкция "pause" имеет вид:

      pause[N]

где N - целая константа  не  более  чем  из  пяти  цифр  или
текстовая  константа.  Когда  процессор встречает инструкцию
"pause", выполнение программы прекращается,  но  может  быть
возобновлено со следующей инструкции.

   Значение N доступно в целях,  зависящих  от  особенностей
реализации.  Программа не может сама возобновить свою работу
после  инструкции  "pause".  Выполнение  инструкции  "pause"
никак  не  влияет  на  ход  дальнейшего выполнения программы
после того, как оно будет возобновлено.


   11.6. Инструкция end


   Инструкция "end" обозначает физический конец  программной
компоненты.  В главной программе она выполняется так же, как
инструкция  "stop",  а  в  подпрограмме  -  как   инструкция
"return". Инструкция "end" имеет вид:

      end

и записывается в позициях с 7-й  по  72-ю  с  новой  строки.
Никакая  другая  инструкция  не  должна  начинаться  с  букв
"end".






















82




                       12. ВВОД/ВЫВОД



   12.1. Средства ввода и вывода


   Возможности ввода и вывода в Фортране-77 позволяют  прог-
раммисту  осуществлять  более  прямой  контроль над системой
ввода-вывода. Реализация инструкций ввода и вывода для языка
Фортран-77 в большой степени зависит от процессора и от опе-
рационной среды.


   Ниже приведена  общая  структура  ввода/вывода  языка   |
Фортран-77, а мелкие детали реализации ввода/вывода в ОС   |
ДЕМОС описываются в руководстве программиста [1].          |


   В Фортране-77 предполагается, что информация  на  внешних
устройствах и в файлах состоит из единиц информации, называ-
емых "записями". Система ввода-вывода языка Фортран-77 осно-
вывается на том, что в результате исполнения каждой инструк-
ции "read" читается одна запись, а в  результате  исполнения
инструкции  "write"  или "print" записывается или печатается
одна запись. Записью называется последовательность  значений
данных  или  последовательность  литер,  и ей не обязательно
должно  соответствовать  какое-то  определенное   физическое
представление. Под словом "запись" подразумевается "логичес-
кая запись" в противоположность понятию  физической  записи.
При каждом исполнении инструкции "read" открывается доступ к
очередной записи  с  заданного  канала,  который  фактически
может оказаться цепочкой литер в памяти. Об'ем данных, выби-
раемых из вводной записи, определяется списком ввода. Лишние
данные  игнорируются.  Если  в  записи не хватает данных для
списка ввода, то имеет место ошибка. При  каждом  исполнении
инструкции  "write"  или "print" записывается или печатается
одна или более  записей  на  указанное  устройство,  которое
также может оказаться областью в памяти. Об'ем данных, кото-
рые выводятся инструкцией "write" или "print",  определяется
списком вывода и соответствующей спецификацией "format", ес-
ли она есть. Запись может иметь нулевую длину. В Фортране-77
допускаются  записи трех видов: форматные записи, бесформат-
ные записи и записи конца файла.


   12.1.1. Форматные записи


   Форматные записи используются в тех случаях, когда  нужно
прочитать  исходные  данные, напечатать информацию в удобной
для восприятия форме или запомнить данные в некотором  внеш-
нем  представлении, например в виде десятичных цифр в двоич-
ном коде. Данные в форматной записи  редактируются  как  при
вводе, так и при выводе. Длина форматной записи измеряется в
литерах.  Форматную  запись  можно  прочитать  или  записать
только при помощи инструкции форматного ввода-вывода.




                                                          83

   12.1.2. Бесформатные записи


   Бесформатные записи используются  в  тех  случаях,  когда
нужно  запомнить данные на внешнем носителе для последующего
чтения без редактирования. Бесформатные  записи  хранятся  в
некотором  внутреннем,  зависящем  от  ЭВМ,  представлении и
могут содержать   данные любого типа. Длина бесформатной за-
писи  измеряется в единицах, зависящих от процессора, таких,
как байты, слова, и определяется  содержимым  списка  ввода.
Бесформатная  запись  может  быть прочитана или записана при
помощи инструкции бесформатного ввода-вывода.


   12.1.3. Запись конца файла


   Запись конца файла  служит  для  обозначения  логического
конца  файла  данных. Запись этого типа выводится при помощи
инструкции "end file" и  не  содержит  данных.  Если  запись
конца  файла  встречается  в  процессе выполнения инструкции
"read", то возникает ситуация "конец файла".


   12.2. Файлы


   Файл  -  это  последовательность  логических  записей.  В
Фортране-77  различаются  файлы двух видов - внешние и внут-
ренние. Понятие внутреннего файла введено  для  того,  чтобы
задать  перемещение данных из одной области внутренней (опе-
ративной) памяти в другую. Записи в файле должны  быть  либо
все форматные, либо все бесформатные.


   12.2.1. Внешний файл


   Внешний файл - это множество записей, хранящихся на внеш-
нем  носителе, таком, как магнитная лента или файл на диске.
Файлом может быть колода перфокарт, терминальное устройство,
с  которого  пользователь взаимодействует с процессором, или
страница напечатанного текста. Файл может  быть  пустым.  то
есть не не содержать ни одной записи.


   12.2.2. Внутренний файл


   Внутренний файл - это область оперативной памяти, описан-
ной как текстовая переменная, текстовый массив или подцепоч-
ка. В процессе  операции  чтения  или  записи  с  внутренним
файлом  всегда происходит редактирование. Таким образом, эту
возможность можно использовать для преобразования данных  из
одного вида в другой.









84

   12.2.3. Терминология, связанная с файлами


   Поскольку файл определяется как последовательность  запи-
сей,  то между записями существует отношение следования, ко-
торое отражено в следующих определениях:

   - Начальная точка - позиция в файле перед первой  записью
     данных.

   - Конечная точка - позиция в файле после самой  последней
     записи данных.

   - Текущая запись - это понятие, отражающее наличие в опе-
     ративной памяти только из файла записи.

   - Предыдущая запись - запись, расположенная непосредстен-
     но перед текущей позицией в файле. Если текущая позиция
     файла находится в начальной точке, то предыдущей записи
     не существует (другое определение: только что прочитан-
     ная или записанная запись).

   - Следующая запись - запись или позиция записи,  располо-
     женная  непосредственно  после  текущей  позиции файла.
     Если текущая позиция находится в конечной точке  файла,
     то  следующей записи не существует (другое определение:
     запись, которая будет записана или прочитана следующей-
     ).

   Файл может иметь также атрибуты, такие,  как  имя  файла,
права  доступа,  параметры,  описывающие  положение файла на
внешних носителях.


   Реализованы все  описанные в стандарте методы  досту-   |
па.  Кроме  того, имеется возможность работать с файлами   |
просто как с набором байтов, не разбитым на рекорды,  то   |
есть в стиле ОС ДЕМОС: такую возможность дают бесформат-   |
ные файлы, для которых об'явлена длина  записи  1  байт.   |
Кроме того, при форматных обменах с файлами, для которых   |
не указана явно длина записи, записываются и считываются   |
записи  произвольной длины. При этом признаком конца за-   |
писи служит символ "новая строка", как это принято в  ОС   |
ДЕМОС.                                                     |



   12.3. Методы доступа


   Метод доступа определяет порядок, в котором записи  можно
писать  в  файл или читать из файла. Метод доступа в большой
степени зависит от специфики внешнего носителя,  на  котором
расположен  файл,  и  от  способа организации записей внутри
файла.









                                                          85

   12.3.1. Атрибуты доступа


   Имеются два атрибута доступа, которые характеризуют файл:
"sequential"   (последовательный)   и   "direct"   (прямой).
Конкретный файл может иметь либо  один  из  этих  атрибутов,
либо оба в зависимости от типа файла  и от операционной сре-
ды. К файлу с атрибутом "sequential" может быть  осуществлен
последовательный  доступ  при помощи инструкции ввода-вывода
последовательного доступа.  К  файлу  с  атрибутом  "direct"
может  быть  осуществлен доступ при помощи инструкции ввода-
вывода прямого доступа. Атрибуты  доступа  определяют  метод
адресации  записей в файле, который допускает стандарт языка
и который может не отражать реальный способ реализации.

   Файлы с  атрибутом  "sequential"  содержат  записи  конца
файла,  которые  соответствют ситуации конца файла, рассмот-
ренной выше. В файлах, имеющих только атрибут "direct",  нет
записи конца файла.


   12.3.2. Последовательный доступ


   Последовательный доступ  -  это  метод  записи  и  чтения
файла,  когда заранее известна последовательность, в которой
будут происходить обращения к записям файла.  Если  произво-
дится   последовательный   доступ   к   файлу   с  атрибутом
"sequential", например, к файлу на перфокартах или магнитной
ленте,  то записи должны обрабатываться последовательно, от-
сюда  название  -  последовательный   доступ.   Запоминающее
устройство прямого доступа также может быть использовано для
хранения файла с атрибутом "sequential", доступ  к  которому
происходит последовательно. В этом случае записи также чита-
ются и пишутся последовательно при помощи инструкций  после-
довательного  ввода  и  вывода,  а  аппаратура и программное
обеспечение нижнего уровня обеспечивают необходимую обработ-
ку этих инструкций.

   Если последовательный доступ осуществляется к файлу,  об-
ладающему также атрибутом "direct", то записи читаются и пи-
шутся последовательно в соответствии со своими номерами.

   К  внутренним  файлам  возможен  только  последовательный
доступ.


   12.3.3. Прямой доступ


   Прямой доступ - это метод записи и  чтения  файла,  когда
последовательность,  в которой будет происходить обращение к
записям файла, заранее известна. Прямой  доступ  применяется
по  отношению  к  тем файлам, записи которых можно читать  и
писать в произвольном порядке.

   Номер записи - это целое число, которое указывается в тот
момент,  когда  запись выводится в файл прямого доступа. Все
записи в файле с атрибутом "direct" обязаны иметь одинаковую
длину. Вывод прямого доступа в свободном формате не допуска-
ется.



86

   12.3.4. Доступ к внутренним файлам


   Перед началом ввода или вывода текущая позиция внутренне-
го  файла  всегда находится в его начальной точке. Если файл
представляет собой одну текстовую цепочку, то он состоит  из
единственной записи. Если файл является массивом цепочек, то
каждый элемент массива - это отдельная запись. В этом случае
в  спецификацию  формата  может  входить  наклонная черта, и
тогда будет записано или прочитано несколько записей.


   12.4. Каналы


   В Фортране-77 обращение  к  файлу  данных  осуществляется
через  "канал". Для внешнего файла канал задается в виде це-
лого значения, которое должно быть положительным  или  нуле-
вым.  Для внутреннего файла канал задается как текстовая пе-
ременная, текстовый массив, элемент текстового  массива  или
текстовая подцепочка.


   12.4.1. Подсоединение


   Установление связи между каналом и файлом называется под-
соединением.  Канал может быть подсоединен неявно операцион-
ной системой, или явно при помощи инструкции "open". Все ка-
налы в Фортране-77 предварительно (т.е. перед началом выпол-
нения программы) подсоединены. Инструкция "open" служит  для
того,  чтобы указать или изменить управляющую информацию для
канала, подсоединить канал, если он был отсоединен, или под-
соединить  канал  к  другому файлу вместо прежнего. В каждый
момент времени к каналу может быть подсоединен  только  один
файл. Но разрешается, отсоединив канал от одного файла, под-
соединить его к другому файлу.


   12.4.2. Отсоединение


   Канал отсоединяется от файла данных в следующих случаях:

   - при выполнении инструкции "close" с этим каналом;

   - при выполнении инструкции "open" с данным каналом, но с
     другим файлом данных.

   - завершение выполнения программы.

   В  инструкциях  ввода-вывода,  кроме  "open",  "close"  и
"inquire", нельзя ссылаться на отсоединенные каналы.











                                                          87

   12.5. Список управляющей информации


   Список управляющей информации в  инструкциях  "read"  или
"write"  может  содержать следующую управляющую информацию о
способе выполнения операции ввода или вывода:

   - канал;

   - формат;

   - номер записи;

   - код ответа;

   - возврат по ошибке;

   - возврат по концу файла.

   Совокупность этих шести спецификаций называется  "списком
управляющей информации", сокращено - УИСП.


   12.6. Синтаксис списка управляющей информации


   Список УИСП может содержать следующие позиционные и  клю-
чевые параметры, разделенные запятыми:

 [unit=]U    (канал)
 [fmt=]F     (формат)
 rec=RN      (номер записи)
 iostat=IOS  (код ответа)
 err=S       (возврат по ошибке)
 end=S       (возврат по концу файла)


   Если спецификации канала и формата задаются как позицион-
ные  параметры, то они должны стоять в списке соответственно
на первом и на втором месте.  Ключевые  параметры  в  списке
могут располагаться в произвольном порядке. Примеры:

  read(5,9000,end=1000)а,в,с,d
  write(99,8000,rec=iseq,err=1500)carray
  read(fmt=9000,end=1000,unit=5)а,в,с,d


   Если спецификация формата  присутствует,  то  выполняется
операция  форматного ввода-вывода, в противном случае выпол-
няется операция бесформатного ввода/вывода. Если присутству-
ет  спецификация  номера записи, то подразумевается операция
ввода или вывода с прямым доступом, в противном случае  име-
ется в виду операция ввода или вывода последовательного дос-
тупа.










88

   12.6.1. Спецификация канала


   Спецификация канала имеет вид:

 [unit=]U

где U может быть:

   - целым выражением, имеющим неотрицательное значение, ко-
     торое идентифицирует внешний канал;

   - звездочкой, обозначающей внешний системный канал, пред-
     варительно  подсоединенный  для последовательного ввода
     или вывода;

   - идентификатором внутреннего файла, который представляет
     собой  имя  текстовой  переменной,  текстового массива,
     элемента текстового массива или текстовой подцепочки.

   Спецификациявнешнего канала имеет одно и то же глобальное
значение  во всех программных компонентах данной исполняемой
программы.


   12.6.2. Спецификация формата


   Спецификация формата имеет вид:

 [fmt=]F

где F может быть:

   - меткой инструкции "format" в той же программной  компо-
     ненте, где находится спецификация формата;

   - целой  переменной,  которой   при   помощи   инструкции
     "assign"  было  присвоено значение метки инструкции той
     же программной компонеты,  где  находится  спецификация
     формата;

   - именем текстового массива;

   - текстовым выражением, не содержащим операций конкатена-
     ции,  один из операндов которой является формальным па-
     раметром или переменной  с  длиной,  описанной  в  виде
     звездочки в скобках;

   - звездочкой, которая обозначает свободный формат.

   Если в спецификации формата ключевое слово "fmt" опущено,
то оно должно быть опущено и в спецификации канала.











                                                          89

   12.6.3. Спецификация номера записи


   Спецификация номера записи имеет вид:

 rec=RN

где RN  -  целое  выражение,  которое  в  момент  выполнения
инструкции должно иметь положительное значение. Эта специфи-
кация служит для указания номера записи, которую нужно  про-
читать или записать в данной операции ввода-вывода.


   12.6.4. Спецификация кода ответа


   Спецификация кода ответа имеет вид:

 iostat=IOS

где IOS - целая переменная или элемент массива целого  типа.
По окончании выполнения соответствующей инструкции ввода или
вывода IOS будет содержать одно из следующих значений:

   - нуль, если операция завершилась успешно, т.е.  не  было
     ошибки и не встретилась запись конца файла;

   - целое положительное значение, зависящее от  реализации,
     если во время выполнения операции произошла ошибка;

   - целое отрицательное значение, зависящее от  реализации,
     если при вводе встретилась запись конца файла и не было
     ошибок. Соответствующее значение присвоится  переменной
     IOS независимо от того, присутствует ли в списке управ-
     ляющей информации также спецификация возврата по ошибке
     или по концу файла.


   12.6.5. Спецификация возврата по ошибке


   Спецификация возврата по ошибке имеет вид:

 err=S

где S - метка исполняемой инструкции в  той  же  программной
компоненте, где находится спецификация. Если во время выпол-
нения  инструкции  ввода-вывода,   содержащей   спецификацию
возврата  по ошибке, произойдет какая-либо ошибка, то управ-
ление будет передано инструкции, помеченной  меткой  S.  Как
указывалось  выше, переменная, указанная в спецификации кода
ответа, примет при этом соответствующее значение.


   12.6.6. Спецификация возврата по концу файла


   Спецификация возврата по концу файла имеет вид:






90

 end=S

где S - метка исполняемой инструкции в  той  же  программной
компоненте,  где находится спецификация. Если при выполнении
инструкции "read", содержащей спецификацию возврата по концу
файла,  встретится запись конца файла и не произойдет какой-
либо ошибки, то управление будет передано инструкции,  поме-
ченной  меткой  S, и выполнение операции чтения завершается.
Как указывалось выше, переменная,  заданная  в  спецификации
кода ответа, примет соответствующее значение.


   12.7. Список ввода-вывода


   В списке ввода-вывода инструкций "read","write" и "print"
перечисляются данные, участвующие в операции ввода или выво-
да. Список ввода-вывода -  это  либо  простой  список,  либо
простой  список,  заключенный в скобки, либо список неявного
цикла, либо два списка ввода-вывода, разделенные запятой.


   12.7.1. Простой список


   Простой  список  -  это  последовательность  спецификаций
данных,  разделенных запятыми. Список вывода несколько отли-
чаетсяот списка ввода, так как он может содержать выражения,
а список ввода нет.


   12.7.1.1. Список ввода


   В простой список ввода могут входить;


   - переменные;

   - массивы;

   - текстовые подцепочки;

   - элементы массива.

   Примеры:

 read(5,9000,end=5000)а,в,(i,j+19,с(4:69)
 read(kfile,rec=irec,err=6000)n,rlist(n,3)



   12.7.1.2. Список вывода


   В простой список вывода могут входить:


   - переменные;





                                                          91

   - массивы;

   - текстовые подцепочки;

   - элементы массивов;

   - выражения, за исключением текстовых выражений, содержа-
     щих  операцию  конкатенации,  один из операндов которой
     является формальным параметром или переменной с длиной,
     заданной в виде звездочки в скобках.

   Примеры:

       write(6,8000,err=50)'pageno',n,
     * sqrt(r)+1.23,a(i,j/к+1)
       write(ltr,rec=krec,err=7000)clist,м,
     * rtable(м/2-1)



   В некоторых версиях Фортрана-77 ОС  ДЕМОС  существуют   |
дополнительные  ограничения  на  выражения в списке вво-   |
да/вывода.                                                 |



   12.7.2. Неявный цикл


   Неявный цикл имеет вид:

(ДСПИСОК,i=E1,E2,[,E3])

где

ДСПИСОК
   - список ввода-вывода,

I  - управляющая переменная,

E1,E2,E3
   - управляющие параметры. Значения, которые пробегает I  и
     условия, налагаемые на I,E1,E2,E3, в точности такие же,
     как для инструкции "do", правила выполнения цикла  "do"
     справедливы  и для неявного цикла. Управляющая перемен-
     ная I не должна входить в качестве члена в список ввода
     или  вывода  ДСПИСОК,  но ДСПИСОК может включать другие
     неявные циклы. При вводе выражения E1,E2,E3  не  должны
     содержать переменные, встречающиеся в ДСПИСКЕ, но могут
     содержать  переменные,  встречающиеся  в  списке  ввода
     перед данным неявным циклом.

   Примеры:

      read(3,9500,end=2000)n,м,
     * ((a(i,j),j=1,м),i=1,n)
      write(17,rec=krec,err=3000)(в(к+1),
     * к=lim/2+1,i),top


   Если в списке ввода-вывода встретился  неявный  цикл,  то
это  равносильно присутствию в списке всех элементов ДСПИСКА


92

для каждого повторения неявного цикла, где управляющая пере-
менная  I  пробегает все значения, определяемые управляющими
параметрами цикла.


   12.7.3. Массивы


   Если в списке ввода-вывода встретилось  имя  массива,  то
это равносильно присутствию в списке всех элементов массива,
выписанных по столбцам. Например, инструкции:

      read a(2,3)
      ...
      read(*,100)a


эквивалентны инструкциям:

      real a(2,3)
      ...
      read (*,100)a(1,1),a(2,1),
     * a(1,2),a(2,2),a(1,3),a(2,3)



   12.8. Операция передачи данных


   Во время выполнения операций ввода  и  вывода  происходит
пересылка  данных  между записями данных и элементами списка
ввода-вывода.Переход к следующему элементу списка происходит
лишь  после завершения обработки предыдущего элемента, поря-
док обработки соответствует порядку расположения элементов в
списке.  Таким образом, элемент списка ввода может использо-
ваться в определениях последующих элементов  списка,  напри-
мер:

      read(kfile)n,(a(i),i=1,n)

или

      read(ifile,5000)n,(a(i),i=1,n)


   Имеются три ограничения:

1)  элемент списка ввода не должен совпадать с текстовой це-
    почкой, описывающей формат в той же инструкции ввода;

2)  все элементы списка вывода к началу выполнения  инструк-
    ции вывода должны быть определены;

3)  при вводе из внутреннего файла элемент списка  ввода  не
    должен  пересекаться с областью памяти, занимаемой внут-
    ренним файлом.








                                                          93

   12.8.1. Операции бесформатной передачи данных


   При выполнении инструкций бесформатного ввода или  вывода
всегда читается или записывается одна запись. При бесформат-
ном вводе запись должна содержать значений  не  меньше,  чем
указано в списке ввода, а типы значений должны быть согласо-
ваны с типами элементов списка ввода. Текстовые  значения  в
вводимой записи должны иметь те же длины, что и соответству-
ющие им элементы списка ввода. Лишние значения в записи  иг-
норируются,  если  же в записи не хватает значений, то имеет
место ошибка.

   Выполнение инструкций  бесформатного  вывода  подчиняется
следующим соглашениям:

   - если доступ последовательный, то длина записи определя-
     ется списком вывода.

   - если доступ прямой, то список вывода не  должен  содер-
     жать значений больше, чем может поместиться в выводимую
     запись. Если выводимая запись заполнена не до конца, то
     она остается частично определенной.

   Инструкции бесформатного ввода и вывода могут применяться
только к внешним файлам.


   12.8.2. Операции форматной передачи данных


   При выполнении форматного ввода или вывода  данные  соот-
ветственно  перед занесением в память или в выводимую запись
подвергаются  редактированию  под  управлением  спецификации
формата.  При  выполнении инструкции ввода перед началом ре-
дактирования запись прочитывается из файла.  Таким  образом,
при  каждом  выполнении  инструкции  "read" прочитывается по
крайней мере одна запись. Количество данных,  выбираемых  из
записи,  определяется  списком ввода. Расположение в внешний
вид этих данных  опеределяются  соответствующей  инструкцией
"format".  Запись  должна  содержать  достаточное количество
данных. Лишние  данные  игнорируются.  Спецификация  формата
может  вызвать  чтение последующих записей. Если доступ пря-
мой, то при каждом чтении номер записи увеличивается на еди-
ницу.

   При каждом выполнении  инструкции  "write"  выводится  по
крайней мере одна запись по указанному каналу. Об'ем выводи-
мых данных определяется как списком вывода, так и специфика-
цией  формата. Каждое выводимое значение выбирается из памя-
ти, преобразуется во внешнее представление  под  управлением
очередной  спецификации преобразования и помещается в вывод-
ную запись.  После  того  как  обработан  последний  элемент
списка-вывода,  формирование выводной записи завершается не-
зависимо от того, остались ли в спецификации  формата  неис-
пользованные   спецификации  преобразования.  Сформированная
запись выводится или помещается в память по указанному кана-
лу. В соответствии со спецификацией формата может быть выве-
дено несколько записей. Если при выводе в файл прямого  дос-
тупа  текст,  сформированный  из элементов списка вывода под
управлением указанного формата, не заполняет всю запись,  то
она  дополняется  пробелами.  В случае прямого доступа длина


94

сформированного текста не должна  превышать  размер  записи.
Если  при выводе в файл прямого доступа под управлением спе-
цификации формата выводится несколько записей, то перед  вы-
водом  каждой  последующей записи номер записи увеличивается
на единицу.


   12.8.3. Файл печати


   При выводе в файл печати первая  литера  каждой  выводной
записи  управляет расположением строк. Эта литера называется
"литерой управления кареткой". Остальные литеры в записи пе-
чатаются, начиная от левого края страницы. При использовании
следующих литер управления каретка продвигается вниз.

Пробел  на одну строку
0(нуль) на две строки
1       до первой строки следующей страницы
+       каретка не продвигается (печать
        поверх  предыдущей строки)


   В реализации Фортрана ОС ДЕМОС эти правила выполняют-   |
ся  только при обработке печатаемой информации специаль-   |
ным программой-фильтром. Вместе с  тем  имеется  возмож-   |
ность  указывать в литеральных константах, в том числе и   |
в  спецификациях  формата,  управляющие  (неграфические)   |
символы.                                                   |


   Записи, не содержащие ни одной литеры, которые могут  по-
лучаться,  если в спецификации формата встречается наклонная
черта, означают печать пустой строки (т.е. происходит  прод-
вижение каретки на одну строку вниз и вывод пустой строки).


   12.8.4. Ввод и вывод в свободном формате


   Если в инструкции ввода или вывода  спецификация  формата
задана  в  виде  звездочки, то ввод или вывод будет произво-
диться в свободном формате. При выполнении  операций  ввода-
вывода  в свободном формате редактирование данных происходит
без участия спецификации формата.


   12.8.5. Установка текущей позиции в файле


   Если при вводе встретилась запись конца  файла,  а  также
после  выполнения  инструкции  "end file", текущая позиция в
файле последовательного доступа находится после записи конца
файла.  В этом случае дальнейшие операции по передаче данных
с этим файлом выполнять нельзя, не  переустановив  предвари-
тельно текущую позицию в файле. Сделать это можно при помощи
инструкций "rewind" и "back space".







                                                          95




               13. ИНСТРУКЦИИ ВВОДА И ВЫВОДА


   Инструкции ввода и вывода в Фортране-77  делятся  на  три
группы: инструкции передачи данных, вспомогательные инструк-
ции и инструкции установки позиции в  файле.  К  инструкциям
передачи  данных  относятся  инструкции  "read",  "write"  и
"print". В группу вспомогательных инструкций входят инструк-
ции  "open",  "close"  и "inquire". Инструкции "back space",
"end file" и "rewind" составляют группу инструкций установки
позиции в файле.


   13.1. Инструкции передачи данных


   Инструкциипередачи данных служат для пересылки информации
из  оперативной  памяти  во внешнюю или наоборот, а также из
одной области оперативной памяти в другую. Для операции вво-
да имеются две формы инструкции "read"; инструкции "write" и
"print" задают операции вывода.


   13.1.1. Инструкция read


   Инструкция "read" имеет вид:

      read (УИСП)[ВВСП]

где УИСП - список  управляющей  информации,  ВВСП  -  список
ввода-вывода.  Эта  форма  инструкции "read" может использо-
ваться как для форматного, так и для бесформатного ввода  из
файла, указанного в УИСП.

   Другая форма инструкции "read":

      read F[,ВВСП]

где F - идентификатор формата, ВВСП - список ввода,  который
может  отсутствовать. Эта форма инструкции "read" служит для
форматного ввода с системного вводного устройства.


   Имеется в виду ввод по каналу стандартного  ввода  ОС   |
ДЕМОС.                                                     |

Примеры:

  read(2,1500,end=5000),а,в,с,d
  read(12,rec=lrt,err=8000)(cab(i,j),j=i,n)
  read 50,х,y,z,w









96

   13.1.2. Инструкция write


   Инструкция "write" имеет вид:

      write (УИСП)[ВВСП]

где УИСП - список управляющей информации, а  ВВСП  -  список
вывода,  который может отсутствовать. Инструкция write может
служить как для форматного, так и для бесформатного вывода в
файл, указанный в УИСП. Примеры:

   write(5,*)a,в,nloc,(tom(i),i=1,nloc)
   write(1)biglst



   13.1.3. Инструкция print


   Инструкция "print" имеет вид:

      print F[,ВВСП]

где F - идентификатор формата, а ВВСП - список вывода,  воз-
можно  отсутствующий.  Инструкцию "print" можно использовать
для форматного вывода на системное выводное устройство. При-
меры:

  print 10,(list(к),к=1,n+1)
  print *,р1,р2,р3
  print *,'area is',a,'length is',l



   В ОС ДЕМОС инструкция "print" производит вывод по ка-   |
налу номер 6, который по умолчанию связан со стандартным   |
выводом задачи.                                            |

   В Фортране-77 для СМ ЭВМ можно  вместо ключевого сло-   |
ва  "print" использовать слово "type", a вместо "read" -   |
"accept". Эта возможность введена для  обеспечения  сов-   |
местимости  с некоторыми широко используемыми диалектами   |
Фортрана-4.                                                |



   13.2. Вспомогательные инструкции


   Вспомогательные инструкции используются для явного откры-
тия  и закрытия файлов, а также для получения справочной ин-
формации о файле или канале.











                                                          97

   13.2.1. Инструкция open


   Инструкция "open" служит для подсоединения файла к каналу
и имеет вид:

      open(ОСПИСОК)

где ОСПИСОК - список, в который могут входить следующие спе-
цификации:

  [unit=] U     (канал)
  iostat=IOS    (код ответа)
  err=S         (возврат по ошибке)
  file=FIN      (файл)
  status=STA    (диспозиция)
  access=ACC    (доступ)
  form=FM       (форматность)
  recl=RL       (длина записи)
  blank=BLNK    (пробел)


   Спецификация  "unit"  обязательна,  она  указывает  номер
внешнего  канала. Остальные спецификации необязательны, и ни
одна из них не должна появляться в данной инструкции  "open"
более  одного  раза. Ниже приводится описание каждой из этих
спецификаций.

iostat
     Спецификация кода ответа "iostat" указывает  переменную
     или  элемент  массива,  которым в результате выполнения
     инструкции open  будет  присвоено  некоторое  значение.
     Нулевое  значение означает, что подсоединение файла вы-
     полнилось без ошибок. Положительное значение, зависящее
     от реализации, означает, что произошла ошибка. Пример:

      iostat=ioval


err     
     Спецификация возврата по ошибке "err"  указывает  метку
     инструкции, которой нужно передать управление, если при
     выполнении инструкции open произойдет ошибка. Пример:

      err=5000


file        
     Спецификация файла "file" -  это  текстовое  выражение,
     задающее  имя  файла,  который  нужно подсоединить. Имя
     должно иметь такой  вид,  который  распознается  данным
     процессором. Пример:

      file='afile'




     В спецификации указывается имя файла в ОС ДЕМОС.      |





98

status
     Спецификация размещения файла "status" задает текстовое
     выражение,  которое после удаления пробелов должно при-
     водиться к одному из значений:

     'old'         (старый)
     'new'         (новый)
     'scratch'     (временный)
     'unknown'     (неизвестный)

     Значения 'old', 'new', 'scratch' соответствующим  обра-
     зом  специфицируют  подсоединяемый файл. Смысл значения
     "unknown" зависит от конкретной реализации. Пример:

      status='new'


access
     Спецификация доступа 'access' указывает текстовое выра-
     жение,  которое  после  удаления пробелов должно приво-
     диться к одному из значений:

     'direct'     (прямой)
     'sequential' (последовательный)

     по умолчанию берется значение 'sequential'. Пример:

      access='direct'


form  
     Спецификация форматности "form" указывает текстовое вы-
     ражение,  которое после удаления пробелов должно приво-
     диться к одному из значений:

     'formatted'   (форматный)
     'unformatted' (бесформатный)


     по умолчанию для файлов последовательного  доступа  бе-
     рется  значение 'formatted', для файлов прямого доступа
     - 'unformatted'. Пример:

      form='unformatted'


recl        
     Спецификация длины записи "recl" указывает целое  выра-
     жение,  которое  должно  иметь  положительное значение,
     обозначающее длину записи в байтах для форматного файла
     и в единицах, зависящих от процессора, для бесформатно-
     го файла. Эта спецификация нужна только для файлов пря-
     мого  доступа; для файлов последовательного доступа она
     игнорируется. Пример:

      recl=lenrec


blanc
     Спецификация пробела "blank" указывает текстовое  выра-
     жение,  которое  после  удаления пробелов должно приво-
     диться к одному из значений:


                                                          99

     'null' (пусто)
     'zero' (нуль)


     по  умолчанию  берется  значение  'null'.  Спецификация
     'null' означает, что при вводе числовых значений пробе-
     лы игнорируются. Спецификация 'zero' означает, что  при
     вводе  числовых  значений все пробелы, кроме начальных,
     воспринимаются как нули. Пример:

      blank='zero'


   Можно выполнять инструкцию "open" с каналом,  к  которому
уже  подсоединен  файл.  Если подсоединяется другой файл, то
старый файл  предварительно  закрывается  (отсоединяется)  и
подсоединяется новый. Если подсоединяется тот же самый файл,
то все спецификации, за исключением "blank",  должны  совпа-
дать с указанными ранее.


   13.2.2. Инструкция close


   Инструкция "close" служит для отсоединения файла от кана-
ла и имеет вид:

      close(ЗСПИСОК)


где список ЗСПИСОК может содержать следующие параметры:

  [unit=] U    (канал)
  iostat=IOS   (диспозиция)
  err=S        (возврат по ошибке)
  status=STA   (код ответа)

спецификация "unit" обязательна, она указывает номер канала.
Остальные  спецификации необязательны; ни одна из специфика-
ций не должна входить  в  инструкцию  "close"  более  одного
раза. Ниже приводится описание спецификаций ЗСПИСКА.

iostat
     В спецификации кода ответа "iostat"  указывается  целая
     переменная  или  элемент  массива, которым в результате
     выполнения инструкции "close" будет присвоено некоторое
     значение. Если присвоено нулевое значение, то ошибок не
     было. Если значение положительное, то произошла ошибка.
     Пример:

      iostat=к


err  В спецификации возврата  по  ошибке  "err"  указывается
     метка  инструкции, которой следует передать управление,
     если при выполнении инструкции "close" произойдет ошиб-
     ка. Пример:







100

      err=6000


status
     В спецификации диспозиции "status" указывается  тексто-
     вое  выражение,  которое после удаления пробелов должно
     приводиться к одному из значений:

     'кеер'    (сохранить)
     'delete'  (уничтожить)

     спецификации 'кеер' и 'delete'  указывают  соответству-
     ющие   диспозиции  файла.  Если  файл  был  открыт  как
     'scratch' (временный), то в инструкции  'close'  нельзя
     указывать  диспозицию 'кеер'. По умолчанию для scratch-
     файлов берется значение 'delete',  а  для  остальных  -
     'кеер'.


   13.2.3. Инструкция inquire


   Инструкция "inquire" служит для  получения  информации  о
свойствах и текущем состоянии файла и имеет вид:

      inquire(ИСПИСОК)


здесь ИСПИСОК  -  это  список  спецификаций  для  инструкции
"inquire".  Допускаются  два вида инструкции "inquire" - ин-
формация о файле и информация о канале. Для получения инфор-
мации о файле нужно указать имя файла, а спецификация канала
должна отсутствовать. Для получения информации о канале  за-
дается  номер  канала, а имя файла не указывается. Каждая из
следующих спецификаций может входить в инструкцию  "inquire"
не более одного раза:

  file=FNAME      (имя опраш. файла)
  unit=U          (номер опраш.канала)
  iostat=IOS      (код ответа)
  err=S           (возврат по ошибке)
  exist=EX        (существует)*
  opened=OD       (открыт)*
  number=NUM      (номер)
  named=NMD       (поименован)*
  name=FN         (имя)
  access=ACC      (доступ)
  sequential=SEQ  (последовательный)
  direct=DIR      (прямой?)
  form=FM         (форматность)
  formatted=FMT   (форматный?)
  unformatted=UNF (бесформатный?)
  recl=RCL        (длина записи)
  nextrec=NR      (следующая запись)
  blank=BLNK      (пробел)


         Пояснения к параметрам оператора "incuire".






                                                         101

file=FILE, unit=U
   - задают соответственно имя файла, о котором нужно  полу-
     чить информацию (FILE - текстовое выражение) либо номер
     канала (U - целое выражение) в случае, если нужно полу-
     чить информацию о канале;

iostat
   - IOS - целая переменная, в которую засылается код состо-
     яния  канала: отрицательное число, если достигнут конец
     файла, положительное, если были ошибки при  вводе/выво-
     де, 0 в остальных случаях.

err=S
   - S - номер метки, на которую будет производиться переход
     при ошибке оператора "inquire";

exist=EX, opened=OD, named=NMD,

   - Эта группа параметров служит для опроса  тех  или  иных
     свойств  канала  или файла. В параметрах задаются пере-
     менные или элементы массивов логического типа,  которым
     в  результате действия оператора присваивается логичес-
     кое значение "истина", если опрашиваемое  свойство  су-
     ществует,  и  "ложь",  если не существует. Опрашиваются
     следующие свойства:
      exist - файл существует?
      opened - файл или канал присоединен к задаче?
      named - файл имеет имя в ОС?

sequantial=SEQ, direct=DIR, formatted=FMT, unformatted=UNF

   - Эта группа параметров аналогична предыдущей, но  указы-
     ваются переменные или элементы массива текстового, а не
     логического типа. В переменные засылается одно из  трех
     значений:  'yes' - если опрашиваемое свойство существу-
     ет, 'no' - если  не  существует,  'unknown',  если  это
     свойство  невозможно определить. Опрашиваются следующие
     свойства:
      sequantial - файл или канал подсоединены для  последо-
     вательного доступа?
      direct - файл или канал подсоединены для прямого  дос-
     тупа?
      formatted - способ передачи данных - форматный?
      unformatted - способ передачи данных - бесформатный?

access=ACC
   - ACC - текстовая переменная, засылается 'sequantial' для
     канала  или файла последовательного доступа, и 'direct'
     для канала или файла прямого доступа;

blank=BLNK
   - BLNK - текстовая переменная, засылается значение  пара-
     метра "blank":

form=FM
   - FM - текстовая переменная, засылается  'formatted'  для
     канала  или файла с форматным способом передачи данных,
     и 'unformatted' для канала  или  файла  с  бесформатным
     способом обмена данными;





102

number=NUM
   - NUM - целая переменная, в нее засылается номер  канала,
     по которому присоединен опрашиваемый файл;

recl=RCL
   - RCL - целая переменная, в нее засылается  номер  размер
     записи в литерах для форматного файла прямого доступа и
     во внутренних единицах памяти для  бесформатного  файла
     прямого  доступа;  в  остальных случаях значение RCL не
     определено;

nextrec=NR
   - NR - целая переменная, в которую засылается номер  сле-
     дующей записи в случае канала прямого доступа.


   13.3. Инструкции установки текущей позиции в файле


   Инструкции установки позиции определены только для файлов
последовательного  доступа. Все инструкции этой группы имеют
следующие параметры:

U  - идентификатор (номер) внешнего канала ввода-вывода

Асписок
   - список, в который смогут входить спецификации:

  [unit=] U   (канал)
  iostat=IOS  (код ответа)
  err=S       (возврат по ошибке)

     спецификация канала "unit" должна присутствовать обяза-
     тельно, остальные спецификации - не более одного раза в
     данной инструкции установки позиции.

   Инструкции установки позиции в файле применяются только к
внешним файлам.


   13.3.1. Инструкция back space


   Инструкция "back space" служит для продвижения позиции  в
файле на одну запись назад и имеет одну из форм:

  back space U
  back space (АСПИСОК)

   Если предыдущей записи нет (позиция в  файле  установлена
на  начало), то позиция файла не изменяется. Если предыдущей
записью  была  запись  конца  файла,  то  после   выполнения
инструкции backspace позиция файла установится перед записью
конца файла. Инструкцию backspace нельзя применять к файлам,
которые  были сформированы путем вывода в свободном формате.
Примеры:

  back space n
  back space (unit=6,iostat=kz,err=5000)





                                                         103

   13.3.2. Инструкция end file


   Инструкция "end file"  служит  для  вывода  записи  конца
файла и имеет одну из форм:

  end file U
  end file (АСПИСОК)

   После вывода записи конца файла позиции файла  устанавли-
ваются  вслед  за  записью  конца  файла. Запись конца файла
может быть выведена и в файл, в который не было записано  ни
одной  записи данных, необходимо только, чтобы файл был под-
соединен к каналу. Примеры:

  end file kfile
  end file(12,err=8200)



   13.3.3. Инструкция rewind


   Инструкция "rewind" служит для установки позиции файла  в
начало файла и имеет одну из форм:

  rewind U
  rewind (АСПИСОК)

если позиция файла уже установлена в начало, то она не меня-
ется. Пример:

  rewind 10
  rewind(nfile,iostat=nval)


   Инструкции "back space", "end file" и "rewind" применяют-
ся как к форматным, так и к бесформатным файлам.


























104




                  14. СПЕЦИФИКАЦИЯ ФОРМАТА


   Спецификацияформата используется в инструкциях форматного
ввода  и  вывода  для  управления преобразованием данных. Из
спецификации формата процессор получает информацию о  струк-
туре  форматной записи. При вводе дескрипторы преобразования
раскрывают структуру различных полей данных во вводимой  за-
писи.  При  этом  устанавливается  соответствие  между полем
данных и элементом списка ввода. При выводе дескриптор  пре-
образования  указывает, какое текстовое представление должен
принять тот или иной элемент данных на внешнем носителе. При
этом устанавливается соответствие между элементом списка вы-
вода и полем данных в выводимой записи.

   Спецификация формата является явным средством  управления
процессом  редактирования  при  форматном  вводе или выводе.
Если в качестве спецификации формата использована звездочка,
то подразумевается ввод или вывод в свободном формате.


   14.1. Способы задания спецификации формата


   Спецификацию  формата  можно  задать  либо   при   помощи
инструкции  "format", либо в виде текстового об'екта, значе-
нием которого должна быть цепочка литер,  имеющая  структуру
спецификации формата.


   14.1.1. Инструкция format


   Инструкция "format" служит для описания формата  и  имеет
вид:

      format СФ


где СФ - спецификация формата.  Инструкция  "format"  должна
иметь  метку,  при помощи которой можно было бы сослаться на
данную спецификацию формата в инструкции ввода  или  вывода.
Инструкция   "format"   -   единственная   инструкция  языка
Фортран-77, в которой метка обязательна. Пример:

 9000 format(10х,15,3f12,6/(1х,12,10i4))


   Инструкция "format" - неисполняемая инструкция.


   14.1.2. Задание формата в виде текстового об'екта


   Вкачестве одного из способов задания формата в инструкции
ввода  или вывода допускается указание имени текстового мас-
сива, текстовой переменной, элемента текстового массива  или
текстового выражения. Последовательность литер, составляющих
текстовый об'ект, должна  иметь  вид  спецификации  формата.


                                                         105

Таким  образом, спецификация формата может быть прочитана во
время выполнения программы или вычислена как текстовое выра-
жение.

   Текстовая  величина,  содержащая  спецификацию   формата,
должна  начинаться с открывающей скобки и заканчиваться зак-
рывающей скобкой. Она должна располагаться в  последователь-
ных текстовых единицах памяти, в которых содержатся дескрип-
торы преобразования, разделители и  управляющие  дескрипторы
редактирования.


   14.1.3. Структура спецификации формата


   Спецификация формата имеет вид:

 ([Q1T1Z1T2Z2...ТNZNQ2])

где:

Q1
   - одна или более наклонных черт, двоеточие или пусто;

T1
   - дескриптор преобразования, управляющий  дескриптор  ре-
     дактирования  или  список дескрипторов преобразования и
     управляющих дескрипторов;

Z1
   - либо разделитель (запятая, наклонная черта,  двоеточие,
     последовательность  наклонных  черт),  либо пусто, если
     список состоит из одного элемента.


   14.1.4. Редактирование


   Редактирование (то есть преобразование данных  при  вводе
или  выводе)  осуществляется путем взаимодействия между эле-
ментом списка ввода-вывода  и  дескриптором  преобразования.
Если  в  списке ввода-вывода есть хотя бы один элемент, то в
спецификации формата должен быть  хотя  бы  один  дескриптор
преобразования. Пустая спецификация формата допускается лишь
тогда, когда список ввода/вывода также пуст. В  этом  случае
при  вводе  пропускается одна запись, а при выводе выводится
запись, не содержащая ни одной литеры.

   Интерпретация спецификации формата и редактирование  вво-
димых  и  выводимых записей производится слева направо, если
нет явных указаний об изменении этого  порядка.  Коэффициент
повторения  означает  многократное  повторение следующего за
ним дескриптора преобразования.  Если  спецификация  формата
использована  до конца, а в списке ввода-вывода еще остались
элементы, то  происходит  возврат  к  последней  открывающей
скобке  в  формате.  В этом случае читается следующая запись
или выводится текущая запись и начинается формирование новой
записи  (если доступ прямой, то номер записи при этом увели-
чивается на единицу).

   Область памяти для выводимой записи перед началом  редак-
тирования всегда заполняется пробелами.


106

   14.2. Дескрипторы преобразования


   В этом разделе рассматриваются дескрипторы преобразования
и  управляющие дескрипторы редактирования, которые могут по-
являться в спецификациях формата.

П_Р_И_М_Е_Ч_А_Н_И_Е.
     В примерах вместо  символа (пробел) используется символ
     "^".



                                                  Таблица 5.
                Дескрипторы преобразования
                 и управляющие дескрипторы

-----------------------------------------------------------
Дескриптор    Значение дескриптора
-----------------------------------------------------------
iW          Ввод/вывод данных целого типа
iW.M        -- // --
fW.D        Ввод/вывод вещественных данных (без порядка  при
            выводе)
eW.D        Ввод/вывод вещественных данных (с  порядком  при
            выводе)
eW.DeE      -- // -- (E указывает число цифр в порядке)
dW.D        Ввод/вывод вещественных данных двойной точности
dW.DeE      -- // -- (E указывает число цифр в порядке)
gW.D        Ввод/вывод вещественных данных (с автоматическим
            выбором представления при выводе)
gW.DeE      -- // -- (E указывает число цифр в порядке)
lW          Ввод/вывод логических данных
a           Ввод/вывод текстовых данных
aW          -- // --
'H1...HN'   Вывод строки текста
NhH1...HN   Вывод строки текста
tC          Перемещение позиции в колонку C
tlS         Перемещение позиции на S колонок влево
trS         Перемещение позиции на S колонок вправо
Wx          Пропуск поля шириной W при вводе, вывод W пробе-
            лов - при выводе
/           Переход к следующей записи
:           Завершение преобразования, если список ввода/вы-
            вода исчерпан
s           Стандартный режим вывода знака '+'
sp          Режим обязательного вывода знака '+'
ss          Блокировка вывода знака '+'
Kp          Масштабирующий множитель, может ставиться  перед
            "f", "e", "d", "g"
bn          Игнорировать пробелы при вводе текстовых данных
bz          При вводе числовых данных пробелы воспринимаются
            как нули
(...)       Об'единение дескрипторов в группу


   Здесь W - размер поля данных (ненулевая положительная це-
лая  константа), M - число цифр при выводе целого, D - число
цифр справа от точки, E - число цифр в порядке  числа,  K  -
целая  константа  (возможно, со знаком), C - номер позиции в
записи, S - смещение в  записи.  Перед  дескрипторами  может
стоять целое без знака число A - коэффициент повторения.


                                                         107

   14.2.1. Редактирование числовых данных


   Дескрипторы преобразования "i", "f", "e", "d" и "g"  слу-
жат для редактирования числовых данных. Во всех случаях, где
не оговорено противное, выполняются следующие правила,  если
они  не отменены явно при помощи соответствующих управляющих
дескрипторов редактирования:

1)  при вводе начальные пробелы поля не существенны. При вы-
    воде  старшие нули не выводятся. Знак "плюс" не выводит-
    ся, но минус, если он нужен, выводится;

2)  при вводе с дескрипторами "f", "е", "d" и  "g",  если  в
    числе  встретилась десятичная точка, то значение "d" иг-
    норируется;

3)  при выводе числа прижимаются к правому краю поля вывода.
    Если размер поля недостаточен для числа, то все поле за-
    полняется звездочками.

   Числовые дескрипторы преобразования должны быть  отделены
друг  от друга разделителями, которыми могут служить запятая
",", наклонная черта "/" или двоеточие ":".


   При вводе чисел по дескрипторам "i", "f",  "e",  "d",   |
"g"  символ  ","  в  поле вводимого числа трактуется как   |
конец этого поля ввода. Это позволяет  вводить  числа  в   |
свободном формате, разделяя их символами ","; необходимо   |
только, чтобы размер поля ввода, заданный в  дескрипторе   |
ввода, был бы больше реальной ширины поля ввода, ограни-   |
ченного запятой.                                           |



   14.2.1.1. Дескриптор i


   Дескриптор "i" служит для  преобразования  данных  целого
типа из внутренней формы во внешнее десятичное представление
и наоборот. Дескриптор "i" имеет вид:

      iW

где W - размер поля во внешней  записи,  включая  пробелы  и
знак.  При  выводе знак печатается только тогда, когда число
отрицательное. При вводе число не должно содержать  десятич-
ной  точки. Пример: при вводе внешних значений ^^12, ^621^ и
-^210^ с участием спецификаций i4, i5 и i6 соответственно  в
память  будут  занесены  числа  12, 6210 и -2100. При выводе
чисел -987 и 123 с  участием  спецификаций  i5  и  i4  соот-
ветственно сформируются поля:

      ^-987 и ^123


   При вводе числовых данных начальные пробелы всегда  игно-
рируются, а пробелы внутри числа считаются нулями. Поле, це-
ликом состоящее из пробелов, соответствует числу  нуль.  При
выводе  выводимое  значение прижимается к правому краю поля.
Если нужно, перед значением выводятся несколько пробелов.


108


   Допускается вариант дескриптора "i" вида:

      iW.M


   При вводе дескриптор iW.M интерпретируется  так  же,  как
iW.  При  выводе дескриптор iW.M действует так же, как iW, с
той разницей, что выводится не менее M цифр - при этом могут
появиться  незначащие  нули  в  начале числа. Если выводимое
значение равно нулю и M равно нулю,  то  поле  вывода  будет
состоять целиком из пробелов.


   14.2.1.2. Дескриптор f


   Дескриптор "f" используется при преобразовании веществен-
ных   данных  из  внутренней  формы  во  внешнее  десятичное
представление без порядка и наоборот. Дескриптор  "f"  имеет
вид:

      fW.D

где W - размер поля, включая пробелы, знак числа и  десятич-
ную точку, а D - число цифр в дробной части числа. При вводе
числа десятичная точка в нем не обязательна, правые  D  цифр
числа  воспринимаются как дробная часть. Если же во вводимом
числе десятичная точка присутствует, то значение D игнориру-
ется.  При  выводе  точка  обязательно присутствует в числе,
справа от нее располагается D десятичных цифр.  Так,  в  ре-
зультате ввода полей (где через ^ обозначены пробелы):

 ^^-123 ^-1.23 ^-1.230-1.23^

с дескриптором f6.2 в память машины попадает одно  и  то  же
число  -1.23.  При  выводе,  например,  значений  9.8134   и
-6.3472  с дескрипторами соответственно f7.2  и  f8.3  будут
сформированы поля:

 ^^98.13 и^^-6.347


   При вводе с дескриптором "f" внешнее представление  числа
может  содержать  десятичный  порядок  в  одной из следующих
форм:

1)  целая константа со  знаком.  Так,  примером  правильного
    числового поля будет .523-4, что означает .523*10**(-4);

2)  буква "e", за которой следует нуль или более пробелов  и
    целая  константа, возможно со знаком. Пример правильного
    числового поля: .523е-4, что означает

3)  буква "d", за которой следуют возможные пробелы и  целая
    константа  с возможным знаком. Пример правильного число-
    вого поля: .523d-4, что означает .523*10**(-4).

   Вводимое значение может иметь большую точность,  чем  до-
пускает процессор.




                                                         109

   14.2.1.3. Дескриптор e


   Дескриптор "e"  предназначен для работы  с  вещественными
данными,  внешнее  представление которых содержит десятичный
порядок. Дескриптор "e" имеет вид:

      eW.D

где W - размер поля, D - количество десятичных цифр в числе.
При вводе, если встретилась десятичная точка, значение D иг-
норируется, так же как и для дескриптора  "f".  Порядок  ве-
щественного  числа  имеет  вид  е+-EEE; старшие нули порядка
могут отсутствовать, так же как и знак, если число неотрица-
тельное.  Если  порядок  имеет знак, то буква "е" может быть
опущена. Размер поля W должен включать  место  для  порядка.
Порядок  должен  быть  прижат к правому краю поля, поскольку
пробелы воспринимаются как нули. При вводе числовых полей:

    3.14159е0
  314.159е-2
    314159е0
  .314159е+1

с дескриптором e12.5 в память машины попадает одно и  то  же
значение 3.14159 .

   При выводе с дескриптором "е" число  принимает  следующий
десятичный вид:

      +-0.d1d2... dne+-еее

где вместо знака плюс выводится пробел. Так в результате вы-
полнения инструкций:

      a=987.123
      write(6,9000)a
 9000 format(1h,e15.7)

   Будет напечатано:

 ^^0.9871230е^03


   При вводе, как и для формата "f", порядок числа может от-
сутствовать. Вводимое значение может иметь большую точность,
чем допускает процессор.

   Имеется вариант дескриптора "е" вида:

      eW.DeE


   При вводе редактирование для этого дескриптора выполняет-
ся  так же, как и для eW.D. при выводе редактирование произ-
водится так же, как для eW.D, но порядок будет  содержать  E
цифр.







110

   14.2.1.4. Дескриптор d


   Дескриптор "d" служит для редактирования  данных  двойной
точности. Дескриптор "d" имеет вид:

      dW.D


и интерпретируется точно так же, как дескриптор  "e",  но  в
обозначении  порядка  числа  вместо  буквы  "e" используется
буква d.


   14.2.1.5. Редактирование комплексных данных


   Элемент данных комплексного типа состоит из  двух  компо-
нент вещественного типа и редактируется при помощи двух пос-
ледовательных дескрипторов для вещественных значений.


   14.2.1.6. Дескриптор g


   Обобщенный (g, general) дескриптор "g"  предназначен  для
редактирования  вещественных данных в тех случаях, когда ве-
личина их заранее не известна. Дескриптор "g" имеет вид:

      gW.D


   При вводе дескриптор "g"  эквивалентен  дескриптору  "f".
При вводе дескриптор "g" эквивалентен дескрипторам:

 Абсолютная вели-  Эквивалентный дескриптор
 чина элемента     преобразования
 данных веществен-
 ного типа

  0.1<=v<1               f(W-4).D,4х
  1<=v<10                f(W-4).(D-1),4х
  10<=v<100              f(W-4).(D-2),4х
       .                       .
       .                       .
       .                       .
 1.e(D-2)<=v<=1.e(D-1) f(W-4).1,4х
 1.e(D-1)<=v<1.e(D)    f(W-4).0,4х
 "в остальных случаях"       eW.D

   Дескриптор "g" позволяет печатать  числа  в  удобной  для
восприятия форме - такой, которую обеспечивает формат "f", и
в то же время избежать ошибок, если числа оказались "слишком
большими" или "слишком малыми".

   Пусть n - абсолютная величина элемента данных. Если n<.01
или  n>=10**D,  то  формат gW.D эквивалентен формату KpeW.D,
где K - значение текущего масштабирующего множителя.

   Имеется вариант дескриптора "g" вида:




                                                         111

      gW.DeE


   При вводе дескриптор gW.DeE эквивалентен gW.D. при выводе
gW.DeE  эквивалентен fW.D, если 0.1<=n<10**D, и eW.DeE, если
n<0.1 или n>=10**D.


   14.2.1.7. Масштабирующий множитель


   Дескриптор масштабирующего множителя имеет вид:

      Kр

где масштабирующий множитель K - целая  константа,  возможно
со знаком. При вводе и выводе с дескриптором "f" воздействие
масштабирующего множителя описывается соотношением:


 внешнее_значение=внутреннее_значение*10**K

например, в результате выполнения инструкций:

       a=0.123
       write(6,9002)a
  9002 format(1h ,2pf5.1)
значение a будет напечатано в виде:

 ^12.3

   При вводе с дескриптором "f", если читаемое значение  со-
держит  порядок,  то  масштабирующий множитель игнорируется.
При вводе с дескрипторами "e" и "d", если читаемое  значение
содержит  порядок, то значение масштабирующего множителя иг-
норируется, при выводе с этими дескрипторами число масштаби-
руется в соответствии со значением "к", но значение числа не
искажается. Более точно, мантисса числа умножается  на  10(в
степени  к) , но при этом соответствующим образом изменяется
и порядок числа. Например, в результате выполнения  инструк-
ций:

       a=12.345
       в=a
       write(6,9003)a,в
  9003 format(1h,e12.5,1pe12.5)
будет напечатано:

 ^0.12345е^02^^1.2345е^01


   При вводе с дескриптором "g":

1)  если поле ввода не содержит порядка,  то  масштабирующий
    множитель  оказывает  же  действие,  как  и  при вводе с
    дескриптором "f";

2)  если поле ввода содержит порядок, то масштабирующий мно-
    житель  не  учитывается.  При выводе по дескриптору "g",
    если  выводимое  значение  лежит  в  пределах   действия
    дескриптора "f", то масштабирующий множитель игнорирует-
    ся. Если действует  дескриптор  "е",  то  масштабирующий


112

    множитель  оказывает такое же действие, как и при выводе
    с дескриптором "е".

   Если вместе с каким-либо подходящим дескриптором употреб-
лен масштабирующий множитель, то это значение множителя ста-
новится текущим. Раз установленное,  оно  действует  на  все
последующие  дескрипторы  преобразования "f", "e", "d" и "g"
до тех пор, пока не встретится другой масштабирующий  множи-
тель. Для того, чтобы отменить действие текущего масштабиру-
ющего множителя, нужно употребить дескриптор:

      0р (т.е. "нуль"р)


   Таким образом, если масштабирующий множитель нужен только
для  одного  дескриптора  преобразования, то перед следующим
дескриптором "f", "е", "d" или g нужно поставить  дескриптор
0р.


   14.2.2. Редактирование логических данных


   Дескриптор "l"  служит  для  ввода  и  вывода  логических
данных и имеет вид:

      lW

где W - размер поля. Поле ввода для  дескриптора  "l"  может
содержать  нуль или более пробелов, затем может стоять точка
(а может и отсутствовать), затем обязательно буквы  "t"  или
"f",  за  которыми могут следовать буквы, составляющие соот-
ветственно слова "true" или  "false".  Логические  константы
.true.  и  .false. являются допустимыми и "ложь". При выводе
значений "истина" и "ложь" поле состоит всегда из W-1 пробе-
лов, за которыми следует соответственно буква "t" или "f".


   14.2.3. Редактирование текстовых данных


   Для редактирования  текстовых  данных  имеются  три  вида
дескрипторов:  дескриптор-цепочка, дескриптор "h" и дескрип-
тор "a". Дескриптор-цепочка  и  дескриптор  "h"  служат  для
включения  в  спецификацию формата описательной информации и
могут использоваться только при выводе.


   14.2.3.1. Дескриптор-цепочка


   Дескриптор-цепочка имеет вид текстовой константы. При вы-
воде  входящие  в  нее литеры переписываются из спецификации
формата в запись, например:

       write(n,9000)a
  9000 format('sum=',f6.2)

   Размер поля вывода равен числу литер в текстовой констан-
те, за исключением двух крайних кавычек. Дескриптору-цепочке
не соответствует никакой элемент в списке вывода.



                                                         113

   Кавычка внутри дескриптора-цепочки представляется в  виде
двух подряд стоящих кавычек.


   14.2.3.2. Дескриптор h


   Дескриптор "h" служит для вывода холлеритовских данных  и
имеет вид:

      WhXXX...X
     W литер

где W - целая константа без знака, которая обозначает  число
литер,  следующих за буквой "h" и входящих в состав холлери-
товского  литерала.  Дескриптору  "h",  как  и  дескриптору-
цепочке,  не  соответствует  никакой элемент в списке ввода-
вывода, что проиллюстрировано в следующем примере:

       write(n,9010)a
  9010 format(7h sum=,f6.2)

   В Фортране-77 дескриптор "h" может использоваться  только
при выводе.


   14.2.3.3. Дескриптор a


   Дескриптор "a" служит для редактирования текстовых данных
и имеет вид:

      aW

где W - размер поля данных в записи. Дескриптор а  действует
следующим образом (G - число литер в соответствующей тексто-
вой переменной или элементе текстового массива):

1)  при вводе, если W>=G, то из поля вводимой записи берутся
    G  крайних правых литер; если W<G, то в левой части эле-
    мента данных текстового типа располагается W литер, а за
    ними следуют G-W пробелов;

2)  при выводе, если W>G, то поле вывода состоит из W-G про-
    белов, за которыми следует G литер, взятых из выводимого
    элемента данных; если W<=G, то в поле вывода попадают  W
    левых литер из элемента данных текстового типа.

   Допускается вариант дескриптора "a" вида:

      a

в котором размер поля опущен. Такой дескриптор можно исполь-
зовать  как  при  вводе, так и при выводе. Размер поля равен
длине соответствующего текстового элемента данных из  списка
ввода-вывода.








114

   14.2.4. Установка позиции в записи


   Позиционные управляющие дескрипторы редактирования служат
для  указания позиции в записи, начиная с которой будет про-
исходить последующий ввод или вывод. Это средство  позволяет
установить  нужную  позицию  в  тексте внешней записи и дает
возможность обрабатывать повторно или  пропускать  некоторые
части  записи  при вводе. При выводе дескрипторы этой группы
позволяют более точно описывать требуемое редактирование,  а
также выравнивать поля.


   14.2.4.1. Дескриптор x


   Управляющий дескриптор редактирования "x" означает  прод-
вижение позиции в записи вперед по отношению к текущей пози-
ции. Таким образом, управляющий дескриптор  "x"  служит  для
пропуска  нескольких литер на внешнем носителе при вводе или
выводе. Дескриптор "x" имеет вид:

      Wx

где W - ненулевая целая константа  без  знака,  указывающая,
сколько  литер нужно пропустить. При вводе W текстовых пози-
ций в записи  пропускаются  независимо  от  их  содержимого.
Перед  началом  форматного  вывода запись всегда заполняется
пробелами. Поля данных помещаются в  запись  последовательно
слева направо по мере выполнения преобразований и редактиро-
вания,  предписываемых  спецификацией  формата.  Управляющий
дескриптор  х означает продвижение текущей позиции в выводи-
мой записи на несколько позиций, в которых остаются пробелы,
если только туда не было выведено что-либо раньше.


   14.2.4.2. Дескриптор t


   Управляющий дескриптор редактирования "t" содержит ссылку
на некоторый абсолютный номер позиции в выводимой или вводи-
мой записи. Указанная позиция может  находиться  как  левее,
так и правее текущей позиции в записи; в результате обработ-
ки дескриптора т текущей становится позиция с указанным  но-
мером. Дескриптор "t" имеет вид:

      tC

где C - ненулевая целая константа без знака,  так  что  (при
выводе)  следующая  литера  будет выведена в позицию номер C
записи или (при вводе) следующая литера будет взята из пози-
ции номер C записи.


   14.2.4.3. Дескриптор tl


   Управляющий дескриптор редактирования "tl" служит для пе-
ремещения указателя текущей позиции в записи назад. Дескрип-
тор "tl" имеет вид:




                                                         115

      tlS

где S - целая константа без знака, показывающая  на  сколько
позиций назад (т.е. влево) следует переместить текущую пози-
цию во внешней записи данных.


   14.2.4.4. Дескриптор tr


   Управляющий дескриптор  редактирования  "tr"  служит  для
продвижения вперед текущей позиции в записи. Дескриптор "tr"
имеет вид:

      trS

где S - целая константа без знака, показывающая, на  сколько
позиций  вперед (т.е. вправо) следует продвинуть текущую по-
зицию во внешней записи данных.


   14.2.5. Дескрипторы управления записями


   Служат для указания того, что  обработку  текущей  записи
следует  завершить.  В этом случае управление в спецификации
формата передается к последней открывающей скобке, и  однов-
ременно происходит переход к следующей записи.

   Встретив в спецификации формата наклонную черту "/" в ка-
честве самостоятельного дескриптора редактирования или в ка-
честве разделителя, процессор переходит к  обработке  следу-
ющей  записи. При вводе прочитывается новая запись и текущей
становится ее первая позиция. При выводе  n  подряд  стоящих
черточек  означают  вывод n-1 пустых строк. Как и при вводе,
текущей становится первая позиция  новой  записи.  Употребив
две  или более наклонные черты подряд, можно пропустить нес-
колько записей целиком при вводе или породить несколько  за-
писей, не содержащих литер, при выводе.

   В случае файлов прямого доступа переход к следующей запи-
си означает переход к записим с номером, на единицу большим.

   Если в спецификации формата встретилоь  двоеточие  ":"  в
качестве  самостоятельного  дескриптора редактирования или в
качестве разделителя и в списке вывода не осталось ни одного
элемента, то процессор завершает выполнение операции вывода.
Если двоеточие встретилось при вводе или при выполнении опе-
рации  вывода в списке вывода еще остались элементы, то дво-
еточие игнорируется.


   14.2.6. Дескрипторы управления выводом знака:  sp,  s,
           ss


   Дескрипторы этой группы управляют выводом знака плюс  для
чисел  и  влияют  на работу дескрипторов преобразования "i",
"f", "е", "d" и "g". Как и в случае масштабирующего множите-
ля,  действие дескриптора управления выводом знака продолжа-
ется до тех пор, пока не встретится другой дескриптор управ-
ления  выводом  знака. При вводе дескрипторы "s", "sp", "ss"


116

игнорируются.

   Управляющий дескриптор  "sp"  указывает  процессору,  что
следует выводить знак плюс везде, где он возможен.

   Управляющий дескриптор  "ss"  указывает  процессору,  что
везде, "где" возможно, знак плюс следует опускать.

   Управляющий дескриптор "s" указывает процессору, что сле-
дует вернуться к стандартному режиму проставления знака плюс
при выводе чисел.


   14.2.7. Дескрипторы управления вводом пробелов: bh, bz


   Дескрипторы управления вводом пробелов указывают  процес-
сору,  как  следует  интерпретировать пробелы, кроме старших
пробелов, при вводе чисел. Режим ввода пробелов устанавлива-
ет спецификация "blank=" в инструкции open или значение этой
спецификации, принятое по умолчанию. Спецификация  "blank=",
управляющая  вводом  пробелов, действует с начала выполнения
инструкции форматного ввода и до тех пор, пока в  специфика-
ции  формата  не  встретится  один  из дескрипторов "bn" или
"bz".

   Управляющий дескриптор "bn" указывает процессору, что при
вводе чисел пробелы следует игнорировать, а остальные литеры
прижимать к правому краю поля, как  если  бы  все  опущенные
пробелы располагались с левого края поля. Поле, состоящее из
одних пробелов, соответствует нулевому значению.

   Управляющий дескриптор "bz" указывает процессору, что при
вводе чисел пробелы следует интерпретировать как нули.


   14.2.8. Разделители в спецификации формата


   Разделителем между дескрипторами преобразования и  управ-
ляющими  дескрипторами  редактирования  служит  запятая.  Ее
можно опускать перед и после наклонной  черты  и  двоеточия,
поскольку наклонная черта и двоеточие сами являются раздели-
телями, а также между управляющим дескриптором р и следующим
за ним дескриптором преобразования "f", "е", "d" и "g".

П_Р_И_М_Е_Ч_А_Н_И_Е.
     В большинстве реализаций Фортрана-4 не требуется разде-
     литель  после  дескрипторов  Wx и Wh '...'. Эта возмож-
     ность не предусмотрена в Фортране-77.


   14.2.9. Коэффициент повторения


   Нулевая целая константа без знака, стоящая перед дескрип-
тором  преобразования, является коэффициентом повторения для
этого дескриптора или для группового дескриптора.  Например,
дескриптор  3i2 эквивалентен последовательности дескрипторов
i2, i2, i2. Коэффициент повторения может относиться и к зак-
люченному  в скобки списку дескрипторов преобразования и уп-
равляющих дескрипторов. Например, запись 3(i4,f10.2) эквива-


                                                         117

лентна i4,f10.2,i4,f10.2,i4,f10.2.


   14.2.9.1. Групповой дескриптор


   Заключенный в скобки список дескрипторов преобразования и
управляющих дескрипторов редактирования называется групповым
дескриптором и используется либо с коэффициентом повторения,
либо  для управления записями. Например, требуется прочитать
значение n по формату i4, пробитое на отдельной  перфокарте,
а  с  последующих  карт  ввести n значений по формату f12.6,
пробитых по шесть на каждой карте. Это можно сделать при по-
мощи следующих инструкций:

       real a(100)
       read(5,9000)n,(a(i),i=1,n)
  9000 format(i4/(6f12.6))

   В этом примере используется наклонная черта для  перехода
к   следующей  перфокарте,  коэффициент  повторения,  список
дескрипторов в скобках и  возврат  к  последней  открывающей
скобке.


   14.3. Ввод-вывод в свободном формате


   Если в качестве спецификации формата указан  символ  "*",
то осуществляется ввод/вывод в свободном формате.

   Свободный формат - это средство, позволяющее осуществлять
форматный  ввод  и вывод, не используя спецификации формата.
Значения данных на внешнем носителе отделяются друг от друга
при помощи запятой или одного или нескольких пробелов. Перед
и после запятой могут стоять  пробелы.  При  вводе  значение
данных  должно  иметь тот же тип, что и соответствующий эле-
мент списка. Вводимые значения данных  на  внешнем  носителе
должны  иметь  вид, допустимый для ввода в языке Фортран-77,
они прочитываются из вводимой записи слева направо и исполь-
зуются  для  определения  элементов  списка ввода инструкции
read, в которой  в  качестве  спецификации  формата  указана
звездочка. Последовательность значений может быть продолжена
в следующих записях. Если между двумя запятыми  нет  ничего,
кроме  пробелов, то подразумевается пустое значение. Если во
вводимой записи в качестве разделителя (т.е. не в  текстовой
константе)  встретилась  наклонная  черта, то операция ввода
завершается, а оставшимся элементам списка ввода  присваива-
ются пустые значения. Присваивание пустого значения элементу
списка ввода не изменяет его  значения,  не  меняется  также
статус определенности этого элемента.

   Вводимые значения могут иметь коэффициент повторения

      R*C
      R*

где R - ненулевая целая константа без знака,  представляющая
собой  коэффициент  повторения,  а  C - некоторая константа.
Форма записи R*C обозначает последовательность из R констант
C, а R* обозначает R пустых значений.



118

   При выводе элементы списка вывода записываются в одну или
несколько  последовательных  записей  в некотором подходящем
формате, который зависит от реализации.  Выводимые  значения
разделяются запятыми или пробелами.

   Пример:

      integer i
      real ff(2)
      read *,i,ff
   ...
Информация в файле стандартного ввода:
   5,2.3е5,3.14



















































                                                         119




                  15. Структура программы


   Исполняемаяпрограмма составляется из следующих компонент:

   - одна главная программа;

   - нуль или более стандартных функций;

   - нуль или более внешних процедур;

   - нуль или более подпрограмм данных (block data).

   Кроме того, главная программа и внешние  процедуры  могут
содержать   так   называемые   функции-формулы  (инструкции,
представляющие собой описание внутренних функций),  а  также
обращения к этим функциям.


   15.1. Главная программа


   Главная программа - это программная компонента, не  явля-
ющаяся ни внешней процедурой, ни подпрограммой данных (block
data). Главной программе передается управление  процессором,
когда исполняемая программа загружена и готова к выполнению.
В исполняемой программе может быть только одна главная прог-
рамма;  главная программа распознается по первой инструкции,
которая  должна  быть  отлична  от  инструкций   "function",
"subroutine"  и  "block  data".  Первой  инструкцией главной
программы может быть инструкция "program".


   15.1.1. Инструкция program


   Инструкция "program" имеет вид:

      program ПРОГ

где ПРОГ - имя главной программы. Необязательная  инструкция
"program"  служит  для  определения имени главной программы,
которое должно быть уникальным среди глобальных имен  данной
исполняемой  программы  и не должно совпадать ни с одним ло-
кальным именем в главной программе.


   15.1.2. Структура главной программы


   Главная программа может содержать любые инструкции  языка
Фортран-77,    за    исключением    инструкций   "function",
"subroutine", "entry"  и "block data". Выполнение инструкций
"stop"  или "end" в главной программе, так же как и выполне-
ние инструкций "stop" в любой программной компоненте  испол-
няемой  программы,  приводит  к  завершению  выполнения всей
программы. Инструкция "save" в главной программе  не  влияет
на  состояние  переменных  и  массивов,  поскольку  для всех
данных, определенных в главной программе,  память  отводится


120

статически.


   15.2. Стандартные функции


   Стандартная функция - это функция, предоставляемая опера-
ционной  системой.  При  обращении  к  ней генерируется либо
встроенная  функция   (последовательность   команд,   непос-
редственно реализующая эту функцию), либо обращение к библи-
отечной  функции.  Стандартные  функции,  входящие  в   язык
Фортран-77  в качестве составной части, перечислены в прило-
жении 1. Примеры стандартных функций: abs - вычисление абсо-
лютной  величины,  int  -  преобразование к целому типу, sin
-синус, sqrt - корень квадратный.


   15.2.1. Обращение к стандартной функции


   Обращение к стандартной функции имеет вид:

      ФУНК(А[,А]...)

где ФУНК - универсальное или индивидуальное имя  стандартной
функции,  А  - фактический параметр. Фактические параметры А
образуют список параметров,  и  их  порядок,  число  и  типы
должны согласовываться с описанием данной функции, приведен-
ным в приложении 1. Фактическим параметром может быть  любое
правильное построенное выражение, кроме текстовых выражений,
содержащих операцию конкатенации,  с  формальным  параметром
или  с  переменной,  длина  которой  описана как звездочка в
скобках.

   Обращение к стандартной функции может входить в выражение
в качестве простого выражения, функция выполняется в процес-
се вычисления выражения.

   Например, следующая инструкция содержит обращение к стан-
дартной функции:

      hyp=sqrt(х**2+y**2)



   15.2.2. Универсальные имена


   Универсальное имя - это  имя,  данное  некоторому  классу
об'ектов.  Все  стандартные  функции языка Фортран-77, соот-
ветствующие одной и той же математической функции,  например
вычислению абсолютной величины, имеют одно общее имя, напри-
мер abs. Универсальным именем можно пользоваться  независимо
от  типа параметра (параметров) функции. Для каждого обраще-
ния к стандартной функции по универсальному имени в  зависи-
мости  от  типа  параметра (параметров) система обеспечивает
обращение к соответствующей специфической функции.







                                                         121

   15.2.3. Правила выполнения стандартных функций


   Все стандартные функции, за исключением функций  преобра-
зования типа, функции вычисления ближайшего целого и функции
вычисления абсолютной величины комплексного числа, дают  ре-
зультат  того  же  типа, какой был у параметра (параметров).
Если для функции допускается или требуется более одного  па-
раметра,  то все параметры должны быть одного типа. Инструк-
ция "implicit" не влияет на тип универсального или  специфи-
ческого имени стандартной функции.

   Если нужно употребить имя стандартной функции в  качестве
фактического параметра при обращении к внешней процедуре, то
следует использовать специфическое имя функции, описав его в
инструкции "intrinsic" в той программной компоненте, где на-
ходится обращение к  внешней  процедуре.  Имена  стандартных
функций для преобразования типов, а также для вычисления ми-
нимума и максимума нельзя использовать в  качестве  парамет-
ров.


   15.3. Функции-формулы


   Функция-формула - это инструкция, содержащая  определение
функции, внутренней по отношению к той программной компонен-
те, где  находится  описание  функции.  Например,  следующая
инструкция является функцией-формулой:

      root(a,в,с)=(-в+sqrt(в**2-4.0*a*с))

при условии, что выполняются другие соглашения. Обращение  к
функции-формуле осуществляется так же, как обращение к стан-
дартной функции. Результат ее вычисляется в той точке  прог-
раммной компоненты, где и когда встретилось обращение. Таким
образом, обращение к функции-формуле может использоваться  в
выражении  в  качестве первичного подвыражения, тип которого
определяется по имени функции и может быть задан либо  явно,
либо неявно.


   15.3.1. Определение функции-формулы


   Определение функции-формулы задается при помощи специаль-
ной инструкции-функции вида:

      ФУНК([D[,D]...])=ВЫР

где D - формальный параметр, ВЫР  -  выражение.  Через  ФУНК
обозначено  имя  функции.  Имя функции и выражение ВЫР могут
иметь разные типы. Здесь выполняются те же правила, что и  в
присваиваниях.  Каждый  формальный  параметр является именем
переменной определенного типа, значение  которой  выбирается
при вычислении ВЫР. Аргументы необязательно имеют один и тот
же тип. Формальный параметр не может  встречаться  в  списке
формальных параметров функции-формулы более одного раза. Имя
формального параметра функции-формулы может употребляться  и
в  качестве  имени  реальной  переменной  в об'емлющей прог-
раммной компоненте. Один и тот же формальный параметр  может
встречаться  в описаниях нескольких функций-формул в одной и


122

той же программной компоненте.

   Имя функции-формулы  и  имена  ее  формальных  параметров
могут  встречаться в инструкциях описания типа. Имя функции-
формулы нельзя использовать для обозначения других  об'ектов
в  той  же программной компоненте, за исключением помеченных
общих блоков.

   Простыми выражениями в ВЫР могут  быть  не  только  имена
формальных  параметров,  но и другие об'екты, которые должны
быть определены к моменту обращения к функции-формуле. Прос-
тыми выражениями в ВЫР могут быть:

   - имена формальных параметров;

   - константы;

   - параметры (поименованные константы);

   - переменные;

   - элементы массивов;

   - обращения к стандартным функциям;

   - обращения к внешним функциям;

   - обращения к формальным процедурам;

   - обращения к другим функциям-формулам;

   - выражения, составленные из элементов 1-9, заключенные в
     скобки.

   Если в ВЫР есть обращения  к  функциям-формулам,  то  эти
функции должны быть определены выше. Нельзя также обращаться
к определяемой функции. Рекурсивные функции-формулы  не  до-
пускаются.

   Описание функции-формулы должно предшествовать  всем  ис-
полняемым инструкциям данной программной компоненты.


   15.3.2. Обращение к функции-формуле


   Обращение к функции-формуле записывается как имя функции,
за  которым  следует список фактических параметров, если они
есть, в скобках; обращение к функции-формуле может использо-
ваться в качестве первичного подвыражения и имеет вид:

      ФУНК([ВРЖ[,ВРЖ...])

где ФУНК - имя функции-формулы, а ВРЖ - выражения,  вычисля-
емые в момент обращения к функции. Порядок, число и типы вы-
ражений должны быть согласованы с формальными параметрами  в
описании функции-формулы.

   Перед выполнением функции-формулы выражения вычисляются и
передаются ей в качестве аргументов. Затем вычисляется выра-
жение ВЫР, фигурирующее в определении функции-формулы, и его
значение  преобразуется,  если  надо,  к  типу функции ФУНК.


                                                         123

Полученное значение и является результатом данного обращения
к функции-формуле.

   Выражения-аргументы функции не должны содержать  операции
конкатенации,  один из операндов которой является формальным
параметром или переменной, длина которой описана  как  звез-
дочка в скобках.


   15.4. Внешние процедуры


   Внешняя процедура - это программная  компонента,  которая
существует  как  самостоятельный об'ект. Она может быть зап-
рограммирована на Фортране-77 или другими средствами.


   15.4.1. Виды внешних процедур


   В Фортране-77 различаются два  вида  внешних  процедур  -
подпрограммы-функции    и    подпрограммы.    Для   удобства
подпрограммы-функции называют обычно просто функциями.

   Функция состоит из инструкции function  и  тела  функции,
которое   заканчивается  инструкцией  end;  общая  структура
функции такова:

        [ТИП] function ИМЯ ([А[,А]...])
           .
           . Тело функции
           .
        end

   Обращение к функции может быть простым выражением в выра-
жении, находящемся в другой прогаммной компоненте той же ис-
полняемой программы.

   Подпрограмма состоит из инструкции "subroutine"  и  тела,
которое  заканчивается  инструкцией  "end";  общая структура
подпрограммы такова:

        subroutine ИМЯ [(А[,А]...])]
           .
           . Тело подпрограммы
           .
        end

   Обратиться к подпрограмме  можно  при  помощи  инструкции
call, находящейся в другой программной компоненте той же ис-
полняемой программы.


   15.4.2. Выполнение внешней процедуры


   Внешняя процедура выполняется следующим образом:

1)  внешняя процедура активируется при обращении  к  функции
    или  при  выполнении  инструкции "call" в зависимости от
    того,  является  ли  внешняя  процедура   соответственно
    функцией или подпрограммой;


124


2)  вычисляются выражения-аргументы процедуры;

3)  фактические параметры, переданные из обратившейся  прог-
    раммной компоненты, ассоциируются с формальными парамет-
    рами процедуры;

4)  инструкции, составляющие тело процедуры,  выполняются  в
    том   порядке,   который  диктуется  последовательностью
    действий программной компоненты;

5)  управление возвращается вызывающей программной компонен-
    те  в результате выполнения инструкции return или если в
    вызываемой процедуре выполнится инструкция end.

   Имя функции должно хотя бы один раз быть  использовано  в
теле  этой  функции  в  качестве  переменной. При выполнении
функции эта переменная должна быть хотя бы однажды определе-
на. После того как эта переменная определена, можно выбирать
ее значение, а также  переопределять  ее.  Когда  управление
возвращается в вызывающую программу, то именно значение этой
переменной и будет результатом обращения к внешней  функции.
Значение  функции  вычисляется в той точке вызывающей компо-
ненты, где и когда встретилось обращение к функции. Тип  ре-
зультата  обращения к функции должен совпадать с типом имени
функции, описанным в самой функции, а если тип текстовый, то
и длины должны совпадать. Если длина переменной, представля-
ющей имя функции, описана в этой  функции  как  звездочка  в
скобках,  то  берется  длина,  указанная  в вызывающей прог-
раммной компоненте. Переменная текстового типа,  представля-
ющая имя функции, не должна участвовать в операциях конкате-
нации в теле функции, но может быть  определена  при  помощи
инструкции присваивания.

   Вызов подпрограммы не может быть простым выражением в вы-
ражении,  поскольку  при вызове подпрограммы не возвращается
какой-либо один явный результат. Тем не менее  подпрограмма,
так  же  как  и  функция,  может передать в вызывающую прог-
раммную компоненту значения, изменив в  процессе  выполнения
один или более из своих аргументов.


   15.4.3. Инструкция function


   Инструкция "function" имеет вид:

      [ТИП] function ФУНК([D[,D]...])

необязательный ТИП может быть одним из типов:

  integer
  real
  double precision
  complex
  logical
  character [*ДЛ]


либо одним из типов, введенных в Фортране-77 ОС ДЕМОС,     |




                                                         125

и специфицирует тип имени функции, который  в  свою  очередь
определяет  тип возвращаемого результата. Через ФУНК обозна-
чено имя внешней функции, к которому, если тип не указан яв-
но,  применяются  правила неявного определения типа. Это имя
является внешним в данной исполняемой программе и в качестве
такового  должно быть уникальным. Например, две внешние про-
цедуры не могут иметь одно и то же имя. Спецификация типа  в
инструкции  "function"  может  быть  опущена,  а  тип  имени
функции можно указать в  инструкции  описания  типа.  Нельзя
только  описывать  тип имени функции дважды - и в инструкции
"function", и в инструкции описания типа. Пример:  следующие
инструкции

      function croot(a,в,с)
      complex croot

эквивалентны инструкции:

      complex function croot(a,в,с)


   Имя формального параметра D может быть именем переменной,
именем массива или именем формальной процедуры. Имя формаль-
ного параметра является локальным в данной программной  ком-
поненте,   и   оно   не   должно  появляться  в  инструкциях
"equivalence", "parameter", "save", "intrinsic", "data"  или
"common"  в  теле этой функции. Имя помеченного общего блока
может совпадать с именем формального параметра.


   15.4.4. Обращение к внешней функции


   Обращение к внешней функции имеет вид:

      ФУНК([А[,А,...])

где ФУНК - имя внешней функции, А  -  фактический  параметр.
Фактические  параметры, их порядок, число и типы должны быть
согласованы  со  списком  формальных  параметров  вызываемой
функции.

   Если в списке формальных параметров функции есть формаль-
ная  процедура, то в соответствующей позиции в списке факти-
ческих параметров должно стоять имя  фактической  процедуры.
Если формальная процедура является функцией, то тип функции,
передаваемой в качестве фактического параметра, должен  сов-
падать  с  типом  формальной процедуры в вызываемой функции.
Если передается стандартная функция, то следует  указать  ее
специфическое имя. В случае когда формальная процедура явля-
ется подпрограммой, понятие типа не применимо.

   Фактическим параметром в обращении к функции может быть:

   - выражение, кроме текстовых выражений, содержащих опера-
     цию  конкатенации,  один  из операндов которой является
     формальным параметром или переменной с длиной,  описан-
     ной в виде звездочки в скобках;

   - имя массива;




126

   - имя стандартной функции;

   - имя внешней процедуры;

   - имя формальной процедуры.

   Поскольку допускается передача имени формальной процедуры
в  качестве  фактического  параметра,  значит, имя процедуры
можно передать через несколько  уровней  обращений  к  прог-
раммным компонентам.


   15.4.5. Инструкция subroutine


   Инструкция "subroutine" имеет вид:

      subroutine ПОДПР[(D[,D]...])]

имя ПОДПР - это внешнее имя подпрограммы, первой инструкцией
которой  является данная инструкция "subroutine", а D - фор-
мальный параметр, который может быть:

   - именем переменной;

   - именем массива;

   - именем формальной процедуры;

   - звездочкой.

   Звездочкойобозначается альтернативный возврат, применение
которого  проиллюстрировано  в следующем примере. Рассмотрим
процедуру:

      subroutine bscale(a,в,с,*,*,*)
      ...
      if (a .lt. 0.0) return 1
      if (a .eq. 0.0) return 2
      return 3
      end
        и ее вызов:
      call bscale(х+y,log(z),
     *         1.54,*1000,*2000,*3000)

   Константы 1000, 2000  и  3000  -  это  метки  исполняемых
инструкций  в  вызывающей программной компоненте. В подпрог-
рамме bscale, если значение a меньше нуля, то  в  результате
выполнения  инструкции  return  1  управление будет передано
инструкции с меткой, указанной в качестве фактического пара-
метра, соответствующего первой звездочке в списке формальных
параметров, т.е.  управление  будет  передано  инструкции  с
меткой 1000 в вызывающей программе. Аналогично, если a равно
нулю, управление будет передано инструкции с меткой  2000  в
вызывающей  программе.  В остальных случаях в результате вы-
полнения  инструкции  return  3  управление  будет  передано
инструкции  с меткой, переданной в качестве фактического па-
раметра, который соответствует третьей звездочке.  В  данном
случае это будет инструкция с меткой 3000.

   Для  подпрограммы  без  параметров  допустимы  две  формы
инструкции:


                                                         127

      subroutine ПОДПР

и

      subroutine ПОДПР()



   15.4.6. Инструкция call


   Обратиться к подпрограмме  можно  при  помощи  инструкции
"call", которая имеет вид:

 call ПОДПР[([А[,А]...])]

где ПОДПР - имя  подпрограммы,  А  -  фактический  параметр.
Параметры a образуют список фактических параметров, и их по-
рядок, число и типы должны быть согласованы  с  соответству-
ющими формальными параметрами вызываемой подпрограммы.

   Если некоторый формальный параметр вызываемой подпрограм-
мы является процедурой, то в соответствующей позиции в спис-
ке фактических параметров инструкции  "call"  должно  стоять
имя фактической процедуры. Если формальная процедура являет-
ся функцией, то  тип  фактической  функции,  передаваемой  в
инструкции  "call",  необходимо  согласовать  с  типом соот-
ветствующей формальной функции. Если передается  стандартная
функция,  то следует указать ее специфическое имя. В случае,
когда процедура является подпрограммой, понятие типа  непри-
менимо.

   Если некоторый параметр вызываемой подпрограммы  является
звездочкой,  то в соответствующей позиции в списке фактичес-
ких  параметров  инструкции  "call"  должна   стоять   метка
инструкции, которой предшествует символ "*".

   В качестве фактического  параметра  в  инструкции  "call"
можно  употребить  холлеритовскую константу; соответствующий
формальный параметр должен иметь целый, вещественный или ло-
гический тип.


   Холлеритовские константы исключены из  международного   |
стандарта  языка  Фортран-77, но допускается в некоторых   |
реализациях, в том числе и в ОС ДЕМОС.                     |


   Фактическим параметром в инструкции "call" может быть:

1)  выражение, кроме  выражений  с  операцией  конкатенации,
    один из операндов которой является формальным параметром
    или переменной с длиной, заданной  в  виде  звездочки  в
    скобках;

2)  имя массива;

3)  тия стандартной функции;

4)  имя внешней процедуры;




128

5)  имя формальной процедуры;

6)  спецификация альтернативного возврата вида *s, где  s  -
    метка исполняемой инструкции.

   Как и в случае внешних функций, благодаря возможности ис-
пользовать  в  списке  фактических параметров имя формальной
процедуры, можно передать имя фактической процедуры на  нес-
колько уровней обращения к процедурам. Дополнительная инфор-
мация о передаче параметров будет приведена ниже.

   Если подпрограмма не имеет параметров, т.е. была  описана
при помощи инструкции вида:

      subroutine ПОДПР   или
      subroutine ПОДПР(),

то вызвать ее можно при помощи инструкции "call" вида:

      call ПОДПР
или
      call ПОДПР().

Обе формы записи полностью взаимозаменяемы как для  инструк-
ции "call", так и для инструкции "subroutine".


   15.4.7. Инструкция entry


   Инструкция "entry" служит для описания  входной  точки  в
функции  или подпрограмме. Инструкция "entry" записывается в
теле  внешней  процедуры  ниже  инструкции  "function"   или
"subroutine", и имеет вид:

      entry ВХОД[([D[,D]...])]

где ВХОД - имя входной точки, D - формальный параметр.  Если
инструкция  "entry" встречается в теле функции, то она обра-
батывается так же, как инструкция "function". Если  инструк-
ция  "entry" встречается в теле подпрограммы, то она обраба-
тывается так же, как инструкция "subroutine".

   К входной точке функции обращаются так же, как к функции.
Квходной точке подпрограммы обращаются при помощи инструкции
"call". Порядок, число, типы и имена формальных параметров в
инструкции  "entry" не обязательно должны согласовываться со
списком формальных параметров в  инструкции  "function"  или
"subroutine", которая является первой инструкцией об'емлющей
внешней процедуры. Но при обращении к входной точке порядок,
число  и  типы фактических параметров должны согласовываться
сосписком формальных параметров в соответствующей инструкции
"entry".











                                                         129

   15.4.8. Инструкция return


   Инструкция "return" приводит к возврату  из  процедуры  в
вызывающую  программную  компоненту  и  может  иметь одну из
форм:

      return
или
      return E


   Вторая форма может использоваться только в подпрограммах.
Целое  выражение E специфицирует альтернативный возврат, уже
обсуждавшийся выше. Если 1<=е<=n, где n - число звездочек  в
инструкции "subroutine" или "entry", то управление будет пе-
редано инструкции с меткой,  которая  указана  в  инструкции
"call"  в  качестве фактического параметра, соответствующего
E-й звездочке в инструкции "subroutine" или "entry". Если  E
меньше 1 или е больше n, то происходит обычный возврат.

   Привыполнении инструкции "return" (равно как и инструкции
"end") становятся неопределенными все об'екты внешней проце-
дуры, за исключением следующих:

   - об'екты, перечисленные в инструкции "save";

   - об'екты непомеченного общего блока;

   - об'екты,  инициализированные  при   помощи   инструкции
     "data", которые не были переопределены и не стали неоп-
     ределенными;

   - об'екты помеченных общих блоков, описанных в процедуре,
     из  которой  осуществляется  возврат,  а также в других
     программных компонентах, которые прямо или косвенно об-
     ращаются к рассматриваемой внешней процедуре.

   Об'ект, описанный в помеченном общем  блоке  в  некоторой
программной  компоненте, не может стать неопределенным в ре-
зультате выполнения инструкции return  в  подчиненной  прог-
раммной компоненте.


   В ОС ДЕМОС становятся неопределенными только  локаль-   |
ные  переменные,  описанные как "auiomatic", если только   |
не используется загрузка  с  перекрытиями  (см.  команду   |
"ldover").                                                 |



   15.4.9. Инструкция end


   Инструкция "end" имеет вид:

      end


   Она служит  фактическим  концом  программной  компоненты.
Когда выполнение программы доходит до инструкции "end", про-
изводятся следующие действия:


130


1)  если инструкция "end" встретилась в  главной  программе,
    то заканчивается выполнение всей программы;

2)  если инструкция "end" встретилась во внешней  процедуре,
    то  осуществляется  неявный  возврат  в вызывающую прог-
    раммную компоненту.

   При выполнении неявного возврата происходят  те  же  дей-
ствия, что и при выполнении инструкции "return".


   15.4.10. Передача массивов в качестве параметров внеш-
            них процедур


   Массив можно передать в качестве  фактического  параметра
функции  или  подпрограмме  при условии, что соответствующий
формальный параметр  является  массивом,  который  описан  в
инструкции  "dimension"  или  в  инструкции  описания  типа.
Размер массива в вызывающей программной компоненте не должен
превышать  размер  соответствующего  формального  массива  в
функции или подпрограмме. Массив в функции или  подпрограмме
может иметь также переменные размерности.

   В следующем  примере  подпрограммы  для  транспонирования
матриц  проиллюстрировано  применение массивов с переменными
размерностями:

      subroutine transp(a,м,n,в)
      real a(м,n),в(n,м)
      do 50 i=1,м
      do 50 j=1,n
50    в(j,i)=a(i,j)
      return
      end

   Вызов этой подпрограммы мог бы выглядеть так:

      real pmat(15,10), rmat(10,15)
        ...
      call transp(pmat,15,10,rmat)

   Спецификация  массива  с  регулируемыми   измерениями   в
функции  или  подпрограмме  - это единственный случай, когда
описатель массива может содержать переменную.  В  декларации
массива с регулируемыми измерениями по крайней мере одно из-
мерение должно быть описано при помощи  переменной,  которая
является либо формальным параметром, либо переменной в общем
блоке.

   Когда массив или элемент массива  передается  в  качестве
параметра функции или подпрограмме, то передается его адрес,
а не сами значения данных. Поэтому можно ассоциировать часть
массива  в  обратившейся программной компоненте с формальным
массивом в вызываемой функции или подпрограмме.








                                                         131


     ЛИТЕРАТУРА


1. Диалоговая Единая Мобильная Операционная  Система.  Руко-
   водство программиста. АПК.00109-01 33-01, 1985.

2. Катцан Г. Язык Фортран 77. М., "Мир", 1982.

3. Баяковский Ю.М. и др. Расширенный Фортран -  Форекс.  М.,
   Препринт ИПМ, 1983.

4. Карпов В.Я. Алгоритмический язык Фортран.   М.,  "Наука",
   1976.

5. Керниган Б. Ритчи Д. Язык программирования Си.  Фьюэр  А.
   Задачи по языку Си. М., "Финансы и статистика", 1985.

6. Диалоговая Единая Мобильная Операционная Система.  Описа-
   ние языка Си. АПК.00109-01 35-01 01, 1985.












































132

                                                 ПРИЛОЖЕНИЕ 


             1. Стандартные функции Фортрана-77


   В таблице 6 содержится следующая информация о стандартных
функциях:

назначение функции
   - описано действие функции;

число параметров
   - число параметров функции, возможно несколько вариантов;

универсальное имя
   - универсальное имя функции, если оно есть;

специфическое имя
   - специфическое имя, если оно есть, часто одному  универ-
     сальному  имени  соответствует  несколько специфических
     имен;

тип
   - типы функции и  параметров,  закодированные  следующими
     буквами:

         I - interer;  CH - character
         R - real;     L  - logical
         D - double precision;
         C - complex;


     Запись имеет вид:
      ТИП-ФУНКЦИИ(ТИП-ПАРАМЕТРА,...)

                                                   Таблица 6
                    Стандартные функции
        ___________________________________________
        |назначение |чис- |универ.|специф|  типы  |
        | функции   |ло   | имя   | имя  | функции|
        |           |пара-|       |      | и пара-|
        |           |мет- |       |      | метров |
        |           |ров  |       |      |        |
        |___________|_____|_______|______|________|
        |    1      | 2   |   3   |  4   |  5     |
        |___________|_____|_______|______|________|
        |     преобразование типов                |
        |_________________________________________|
        | преобразо-|  1  | int   |  -   | I(I)   |
        | вание к   |     |       | int  | I(R)   |
        | целому    |     |       | ifix | I(R)   |
        | типу      |     |       | idint| I(D)   |
        |           |     |       |  -   | I(C)   |
        |           |_____|_______|______|________|
        |           |  1  |  -    | ichar| CH(I)  |
        |___________|_____|_______|______|________|
        | преобразо-|  1  | real  | real | R(I)   |
        | вание к   |     |       | float| R(I)   |
        | вещест-   |     |       |  -   | R(R)   |
        | венному   |     |       | sngl | R(D)   |
        | типу      |     |       |  -   | R(C)   |


                                                         133

        |___________|_____|_______|______|________|
        | преобразо-|  1  | dble  |  -   | D(I)   |
        | вание к   |     |       |  -   | D(R)   |
        | типу двой-|     |       |  -   | D(D)   |
        | ной точ-  |     |       |  -   | D(C)   |
        | ности     |     |       |      |        |
        |___________|_____|_______|______|________|
        | преобразо-|  1  | cmplx |  -   | C(I)   |
        | вание к   | или |       |  -   | C(R)   |
        | комплекс- |  2  |       |  -   | C(D)   |
        | ному типу |     |       |  -   | C(C)   |
        |___________|_____|_______|______|________|
        | преобразо-|  1  |   -   | char | CH(I)  |
        | выние к   |     |       |      |        |
        | текстову- |     |       |      |        |
        | му типу   |     |       |      |        |
        |___________|_____|_______|______|________|
        |     целочисленная арифметика            |
        |_________________________________________|
        | целая     |  1  | aint  | aint | R(R)   |
        | часть     |     |       | dint | D(D)   |
        |___________|_____|_______|______|________|
        | ближайшее |  1  | anint | anint| R(R)   |
        | целое зна-|     |       | dnint| D(D)   |
        | чение     |     |       |      |        |
        |___________|_____|_______|______|________|
        | остаток   |  2  | mod   |  mod | I(I,I) |
        | от целого |     |       | amod | R(R,R) |
        | деления   |_____|       | dmod | D(D,D) |
        | a1-int(a1/a2)*a2|       |      |        |
        |___________|_____|_______|______|________|
        |      общая математика                   |
        |_________________________________________|
        | абсолютная|  1  | abs   | iabs | I(I)   |
        | величина  |     |       | abs  | R(R)   |
        |           |     |       | dabs | D(D)   |
        |           |     |       | cabs | R(C)   |
        |___________|_____|_______|______|________|
        | изменение |  2  | sign  | isign| I(I,I) |
        | знака     |     |       | sign | R(R,R) |
        | |a1|, если a2>0 |       | dsign| D(D,D) |
        |-|a1|, если a2<0 |       |      |        |
        |   0   если a2=0 |       |      |        |
        |_________________|_______|______|________|
        |абсолютная |  2  | dim   | idim | I(I,I) |
        |величина   |     |       | dim  | R(R,R) |
        |разности   |     |       | ddim | D(D,D) |
        |___________|_____|_______|______|________|
        | произведе-|  2  |  -    | dprod| D(R,R) |
        | ние двой- |     |       |      |        |
        | ной точ-  |     |       |      |        |
        | ности     |     |       |      |        |
        |___________|_____|_______|______|________|
        | выбор мак-| >=2 | max   | max0 | I(I,..)|
        | симального|     |       | amax1| R(R,..)|
        | значения  |     |       | dmax1| D(D,..)|
        |           |     |_______|______|________|
        |           |     | -     | amax0| R(I,..)|
        |           |     |       | max1 | I(R,..)|
        |___________|_____|_______|______|________|




134

                                          Продолжение таб. 6
            ___________________________________________
            |    1      | 2   |   3   |  4   |  5     |
            |___________|_____|_______|______|________|
        | выбор ми- | >=2 | min   | min0 | I(I,..)|
        | нимального|     |       | amin1| R(R,..)|
        | значения  |     |       | dmin1| D(D,..)|
        |           |     |_______|______|________|
        |           |     | -     | amin0| R(I,..)|
        |           |     |       | min1 | I(R,..)|
        |___________|_____|_______|______|________|
        | длина це- | 1   |  -    | len  | I(CH)  |
        | почки     |     |       |      |        |
        |___________|_____|_______|______|________|
        | индекс    | 2   |  -    | index|I(CH,CH)|
        | подцепочки|     |       |      |        |
        |___________|_____|_______|______|________|
        | лексикографическое сравнение            |
        |_________________________________________|
        |   >=      |  2  |   -   | lge  |L(CH,CH)|
        |   >       |  2  |   -   | lgt  |L(CH,CH)|
        |   <=      |  2  |   -   | lle  |L(CH,CH)|
        |   <       |  2  |   -   | llt  |L(CH,CH)|
        |___________|_____|_______|______|________|
        |           комплексные  числа            |
        |_________________________________________|
        | мнимая    |  1  |   -   | aimag| R(C)   |
        | часть     |     |       |      |        |
        |___________|_____|_______|______|________|
        | сопряжен- |  1  |   -   | conjg| C(C)   |
        | ное число |     |       |      |        |
        |___________|_____|_______|______|________|
        |        математические функции           |
        |_________________________________________|
        | корень    |  1  | sqrt  | sqrt | R(R)   |
        | квадратный|     |       | dsqrt| D(D)   |
        |           |     |       | csqrt| C(C)   |
        |___________|_____|_______|______|________|
        | экспонента|  1  | exp   | exp  | R(R)   |
        |           |     |       | dexp | D(D)   |
        |           |     |       | cexp | C(C)   |
        |___________|_____|_______|______|________|
        | натураль- |  1  | log   | alog | R(R)   |
        | ный лога- |     |       | dlog | D(D)   |
        | рифм      |     |       | clog | C(C)   |
        |___________|_____|_______|______|________|
        | десятичный|  1  |log10  |alog10| R(R)   |
        | логарифм  |     |       |dlog10| D(D)   |
        |___________|_____|_______|______|________|
        | синус     |  1  | sin   | sin  | R(R)   |
        |           |     |       | dsin | D(D)   |
        |           |     |       | csin | C(C)   |
        |___________|_____|_______|______|________|
        | косинус   |  1  | cos   | cos  | R(R)   |
        |           |     |       | dcos | D(D)   |
        |           |     |       | ccos | C(C)   |
        |___________|_____|_______|______|________|
        | тангенс   |  1  | tan   | tan  | R(R)   |
        |           |     |       | dtan | D(D)   |
        |___________|_____|_______|______|________|




                                                         135

                                          Продолжение таб. 6
            ___________________________________________
            |    1      | 2   |   3   |  4   |  5     |
            |___________|_____|_______|______|________|
        | арксинус  |  1  | asin  | asin | R(R)   |
        |           |     |       | dasin| D(D)   |
        |___________|_____|_______|______|________|
        | арккосинус|  1  | acos  | acos | R(R)   |
        |           |     |       | dacos| D(D)   |
        |___________|_____|_______|______|________|
        | арктангенс|  1  | atan  | atan | R(R)   |
        |           |     |       | datan| D(D)   |
        |___________|_____|_______|______|________|
        | арктангенс|  2  | atan2 | atan2| R(R)   |
        | круговой  |     |       |datan2| D(D)   |
        |___________|_____|_______|______|________|
        | синус ги- |  1  | sinh  | sinh | R(R)   |
        | перболи-  |     |       | dsinh| D(D)   |
        | ческий    |     |       |      |        |
        |___________|_____|_______|______|________|
        | косинус   |  1  | cosh  | cosh | R(R)   |
        | гиперболи-|     |       | dcosh| D(D)   |
        | ческий    |     |       |      |        |
        |___________|_____|_______|______|________|
        | тангенс   |  1  | tanh  | tanh | R(R)   |
        | гиперболи-|     |       | dtanh| D(D)   |
        | ческий    |     |       |      |        |
        |___________|_____|_______|______|________|




































136

                                                 ПРИЛОЖЕНИЕ 


            2. Синтаксис инструкций Фортрана-77


   Символами "***" помечены инструкции, относящиеся к версии
Фортрана-77 ОС ДЕМОС.

 assign M to I
 automatic     ***
 backspace U
 backspace (АСПИСОК)
 block data[ПОДПР]
 call ПОДПР[([A[,A]..)]
 character[*ДЛИНА[,]] ИМЯ[,ИМЯ]...
 CLOSE(ЗСПИСОК)
 common[/[ОБ]/]ССПИСОК
     [[,]/[ОБ]/ССПИСОК]...
 ТИП N[,N]...               - инструкции
 ТИП*ДЛИНА  N[,N]...  ***     описания
 continue
 data СПИМЕН/СПКОНСТ/
     [[,]СПИМЕН/СПКОНСТ/]...
 dimension M(P)[,M(P)]...
 do M[,]I=ВЫР1,ВЫР2[,ВЫР3]
 double precision N[,N]...
 else
 else if(ВЫР) then
 end
 end if
 endfile U
 endfile (АСПИСОК)
 entry ВХОД[([D[,D]...])]
 equivalence (СПИСОК)[,(СПИСОК)]
 external ПРОЦ[,ПРОЦ]
 format СФ
 ФУНК([D[,D]...])=ВЫР - функция формула
 [ТИП] function [ФУНК] ([D[,D]...])
 goto I[[,](M[,M]...)]
 goto M
 goto (M[,M]...)[,]I
 if(ВЫР)ИНСТР
 if(ВЫР)M1,M2,M3
 if(ВЫР)then
 implicit ТИП (A[,A]...)
     [,ТИП (A[,A]...)]...
 implicit undefined (A[,A]...) ***
     [,ТИП (A[,A]...)]...
 inquire(ИФСПИСОК)
 inquire(ИКСПИСОК)
 intrinsic ФУНКЦ[,ФУНКЦ]...
 open(ОСПИСОК)
 parameter (ПАР=В[,ПАР=В]...)
 pause [N]
 print F[,ВВСП]
 program ПРОГ
 read (УИСП) [ВВСП]
 read F[,ВВСП]
 return [E]
 rewind U
 rewind (АСПИСОК)


                                                         137

 save [A[,A]...]
 static [A[,A]...]  ***
 stop N
 subroutine ПОДПР[([D[,D]...])]
 ПЕР=ВЫР
 write (УИСП) [ВВСП]


ТИП  logical, integer, real, double precision, complex;



     integer*2, integer*4,  real*4,  real*8,  logical*1,   |
     logical*2,  logical*4,  double  complex, complex*8,   |
     complex*16.                                           |

















































138



                           СОДЕРЖАНИЕ



1.  ВВЕДЕНИЕ...........................................    2

2.   ОБЩИЕ СВЕДЕНИЯ О ЯЗЫКЕ ФОРТРАН-77.................    3
    2.1. Ввод-вывод....................................    3
    2.2. Описание данных...............................    3
    2.3. Описание подпрограмм..........................    4
    2.4. Прочие возможности............................    4

3.  СПОСОБ ОПИСАНИЯ ЯЗЫКА..............................    6
    3.1. Основные понятия языка Фортран-77.............    6

4.   ЭЛЕМЕНТЫ И ОСНОВНЫЕ КОНСТРУКЦИИ ЯЗЫКА.............    8
    4.1. Набор символов Фортрана-77....................    8
    4.1.1. Отношение следования........................    9
    4.1.2. Пробелы и символы табуляции.................    9
    4.2. Идентификаторы................................    9
    4.2.1. Имена.......................................    9
    4.2.2. Ключевые слова..............................    9
    4.3. Структура инструкции..........................   10
    4.3.1. Строки комментариев.........................   10
    4.3.2. Начальная  строка...........................   10
    4.3.3. Строки продолжения..........................   11
    4.3.4. Инструкции языка Фортран-77.................   11
    4.3.5. Метки.......................................   12
    4.3.6. Форма инструкции в Фортране-77..............   12
    4.3.7. Программная компонента......................   12
    4.3.8. Главная программа...........................   13
    4.3.9. Подпрограммы................................   13
    4.3.10.Процедуры...................................   13
    4.3.11.Программные компоненты block data...........   14
    4.3.12.Исполняемая программа.......................   14
    4.3.13.Порядок инструкций в  программной  компонен-
           те..........................................   14
    4.4. Оператор вставки текста.......................   15

5.  ЭЛЕМЕНТЫ ДАННЫХ....................................   17
    5.1. Типы данных...................................   17
    5.2. Константы и значения..........................   18
    5.2.1. Целые константы.............................   19
    5.3. Вещественные константы........................   19
    5.3.1. Константы с двойной точностью...............   20
    5.3.2. Комплексные константы.......................   21
    5.3.3. Логические константы........................   22
    5.3.4. Текстовые константы.........................   23
    5.3.5. Холлеритовские константы....................   24

6.  СTРУКТУРЫ ДАННЫХ...................................   26
    6.1. Переменные....................................   26
    6.2. Текстовые подцепочки..........................   26
    6.2.1. Обращение к подцепочке......................   26
    6.2.2. Граничные выражения подцепочки..............   27
    6.3. Массивы.......................................   27
    6.3.1.   Имя и тип массива.........................   28
    6.3.1. Распределение памяти для массивов...........   28
    6.3.2. Измерения массива...........................   28
    6.3.3. Индекс массива..............................   29


                                                         139

    6.3.4. Выбор элемента массива......................   29

7.   ВЫРАЖЕНИЯ.........................................   31
    7.1. Арифметические выражения......................   31
    7.1.1. Арифметические операции.....................   31
    7.1.2. Арифметические операнды.....................   32
    7.1.3. Структура арифметических выражений..........   32
    7.2. Арифметические выражения специального вида....   33
    7.2.1. Правила вычисления арифметических выражений-
           ............................................   34
    7.3. Однотипные выражения..........................   34
    7.3.1. Выражения со смешением типов................   34
    7.4. Унарные операции..............................   36
    7.4.1. Целочисленное деление.......................   36
    7.4.2. Возведение в степень........................   36
    7.5. Текстовые выражения...........................   37
    7.6. Текстовые операции............................   37
    7.6.1. Текстовые операнды..........................   37
    7.6.2. Структура текстовых выражений...............   37
    7.6.3. Текстовые выражения специального вида.......   38
    7.7. Выражения отношения...........................   38
    7.7.1. Операции отношения..........................   38
    7.7.2. Операнды операций отношения.................   39
    7.7.3. Вычисление выражений отношения..............   39
    7.7.3.1. Арифметические выражения отношения........   39
    7.7.3.2. Текстовые выражения отношения.............   40
    7.8. Логические выражения..........................   40
    7.8.1. Логические операции.........................   41
    7.8.2. Логические операнды.........................   42
    7.8.3. Структура логических выражений..............   42
    7.8.4. Логические выражения специального вида......   43
    7.8.5. Замечание о выполнении логических выражений-
           ............................................   43
    7.9. Интерпретация и вычисление выражений..........   44
    7.9.1. Старшинство операций различных типов........   44
    7.9.2. Неприкосновенность  скобок  и  правила   ин-
           терпретации.................................   44
    7.9.3. Дополнительные правила вычисления выражений-
           ............................................   45
    7.9.4. Обращение к функциям........................   45
    7.9.5. Вычисление выражений........................   46
    7.9.5.1. Эквивалентность выражений.................   46

8.  ВЫПОЛНЕНИЕ ИНСТРУКЦИЙ ФОРТРАНА-77..................   48
    8.1. Последовательность выполнения инструкций......   48
    8.1.1. Нормальная последовательность выполнения....   48
    8.1.2. Передача управления.........................   48
    8.2. Исполняемые и неисполняемые инструкции........   49
    8.2.1.   Список исполняемых инструкций.............   49
    8.2.1. Список неисполняемых инструкций.............   50

9.  ИНСТРУКЦИИ ОПИСАНИЯ................................   52
    9.1. Инструкции описания типа......................   52
    9.1.1. Инструкция описания арифметического и  логи-
           ческого типа................................   52
    9.1.2. Инструкция описания текстового типа.........   54
    9.2. Инструкции неявного описания типа.............   55
    9.2.1. Инструкция implicit.........................   56
    9.2.2. Инструкция parameter........................   57
    9.2.3. Инструкция dimension........................   58
    9.3. Распределение памяти..........................   59
    9.3.1. Общая память................................   59


140

    9.3.1.1. Статическая и динамическая память.........   59
    9.3.1.2. Инструкция common.........................   61
    9.3.1.3. Организация памяти для общих блоков.......   61
    9.3.2. Эквивалентность памяти......................   62
    9.3.2.1. Правила      использования      инструкции
             equivalence...............................   63
    9.3.3. Индексация массивов.........................   63
    9.4. Инициализация данных..........................   64
    9.4.1. Инструкция data.............................   64
    9.4.2. Неявные do-списки...........................   65
    9.4.3. Программная компонента block data...........   66
    9.5. Инструкции описания, относящиеся   к  подпрог-
         раммам........................................   67
    9.5.1. Инструкция external.........................   67
    9.5.2. Инструкция save.............................   68
    9.5.2.1. Инструкция intrinsic......................   69

10. ИНСТРУКЦИИ ПРИСВАИВАНИЯ............................   71
    10.1.Арифметическое присваивание...................   71
    10.2.Логическое присваивание.......................   71
    10.3.Присваивание литерных цепочек.................   72
    10.4.Инструкция assign.............................   72

11. ИНСТРУКЦИИ УПРАВЛЕНИЯ..............................   74
    11.1.Инструкции перехода...........................   74
    11.1.1.Инструкция безусловного перехода............   74
    11.1.2.Инструкция вычисляемого перехода............   74
    11.1.3.Инструкция перехода по предписанию..........   75
    11.2.Инструкции условного перехода.................   75
    11.2.1.Арифметическая инструкция if................   76
    11.2.2.Логическая инструкция if....................   76
    11.2.3.Конструкция if-then-else....................   77
    11.3.Инструкция do.................................   79
    11.3.1.Структура do-цикла..........................   79
    11.3.2.Выполнение do-цикла.........................   80
    11.4.Инструкция continue...........................   81
    11.5.Инструкции stop и pause.......................   82
    11.6.Инструкция end................................   82

12. ВВОД/ВЫВОД.........................................   83
    12.1.Средства ввода и вывода.......................   83
    12.1.1.Форматные записи............................   83
    12.1.2.Бесформатные записи.........................   84
    12.1.3.Запись конца файла..........................   84
    12.2.Файлы.........................................   84
    12.2.1.Внешний файл................................   84
    12.2.2.Внутренний файл.............................   84
    12.2.3.Терминология, связанная с файлами...........   85
    12.3.Методы доступа................................   85
    12.3.1.Атрибуты доступа............................   86
    12.3.2.Последовательный доступ.....................   86
    12.3.3.Прямой доступ...............................   86
    12.3.4.Доступ к внутренним файлам..................   87
    12.4.Каналы........................................   87
    12.4.1.Подсоединение...............................   87
    12.4.2.Отсоединение................................   87
    12.5.Список управляющей информации.................   88
    12.6.Синтаксис списка управляющей информации.......   88
    12.6.1.Спецификация канала.........................   89
    12.6.2.Спецификация формата........................   89
    12.6.3.Спецификация номера записи..................   90
    12.6.4.Спецификация кода ответа....................   90


                                                         141

    12.6.5.Спецификация возврата по ошибке.............   90
    12.6.6.Спецификация возврата по концу файла........   90
    12.7.Список ввода-вывода...........................   91
    12.7.1.Простой список..............................   91
    12.7.1.1.Список ввода..............................   91
    12.7.1.2.Список вывода.............................   91
    12.7.2.Неявный цикл................................   92
    12.7.3.Массивы.....................................   93
    12.8.Операция передачи данных......................   93
    12.8.1.Операции бесформатной передачи данных.......   94
    12.8.2.Операции форматной передачи данных..........   94
    12.8.3.Файл печати.................................   95
    12.8.4.Ввод и вывод в свободном формате............   95
    12.8.5.Установка текущей позиции в файле...........   95

13. ИНСТРУКЦИИ ВВОДА И ВЫВОДА..........................   96
    13.1.Инструкции передачи данных....................   96
    13.1.1.Инструкция read.............................   96
    13.1.2.Инструкция write............................   97
    13.1.3.Инструкция print............................   97
    13.2.Вспомогательные инструкции....................   97
    13.2.1.Инструкция open.............................   98
    13.2.2.Инструкция close............................  100
    13.2.3.Инструкция inquire..........................  101
    13.3.Инструкции   установки   текущей   позиции   в
         файле.........................................  103
    13.3.1.Инструкция back space.......................  103
    13.3.2.Инструкция end file.........................  104
    13.3.3.Инструкция rewind...........................  104

14. СПЕЦИФИКАЦИЯ ФОРМАТА...............................  105
    14.1.Способы задания спецификации формата..........  105
    14.1.1.Инструкция format...........................  105
    14.1.2.Задание формата в виде текстового об'екта...  105
    14.1.3.Структура спецификации формата..............  106
    14.1.4.Редактирование..............................  106
    14.2.Дескрипторы преобразования....................  107
    14.2.1.Редактирование числовых данных..............  108
    14.2.1.1.Дескриптор i..............................  108
    14.2.1.2.Дескриптор f..............................  109
    14.2.1.3.Дескриптор e..............................  110
    14.2.1.4.Дескриптор d..............................  111
    14.2.1.5.Редактирование комплексных данных.........  111
    14.2.1.6.Дескриптор g..............................  111
    14.2.1.7.Масштабирующий множитель..................  112
    14.2.2.Редактирование логических данных............  113
    14.2.3.Редактирование текстовых данных.............  113
    14.2.3.1.Дескриптор-цепочка........................  113
    14.2.3.2.Дескриптор h..............................  114
    14.2.3.3.Дескриптор a..............................  114
    14.2.4.Установка позиции в записи..................  115
    14.2.4.1.Дескриптор x..............................  115
    14.2.4.2.Дескриптор t..............................  115
    14.2.4.3.Дескриптор tl.............................  115
    14.2.4.4.Дескриптор tr.............................  116
    14.2.5.Дескрипторы управления записями.............  116
    14.2.6.Дескрипторы управления выводом знака: sp, s,
           ss..........................................  116
    14.2.7.Дескрипторы управления вводом пробелов:  bh,
           bz..........................................  117
    14.2.8.Разделители в спецификации формата..........  117
    14.2.9.Коэффициент повторения......................  117


142

    14.2.9.1.Групповой дескриптор......................  118
    14.3.Ввод-вывод в свободном формате................  118

15. Структура программы................................  120
    15.1.Главная программа.............................  120
    15.1.1.Инструкция program..........................  120
    15.1.2.Структура главной программы.................  120
    15.2.Стандартные функции...........................  121
    15.2.1.Обращение к стандартной функции.............  121
    15.2.2.Универсальные имена.........................  121
    15.2.3.Правила выполнения стандартных функций......  122
    15.3.Функции-формулы...............................  122
    15.3.1.Определение функции-формулы.................  122
    15.3.2.Обращение к функции-формуле.................  123
    15.4.Внешние процедуры.............................  124
    15.4.1.Виды внешних процедур.......................  124
    15.4.2.Выполнение внешней процедуры................  124
    15.4.3.Инструкция function.........................  125
    15.4.4.Обращение к внешней функции.................  126
    15.4.5.Инструкция subroutine.......................  127
    15.4.6.Инструкция call.............................  128
    15.4.7.Инструкция entry............................  129
    15.4.8.Инструкция return...........................  130
    15.4.9.Инструкция end..............................  130
    15.4.10.Передача  массивов  в  качестве  параметров
           внешних процедур............................  131

ЛИТЕРАТУРА.............................................  132

ПРИЛОЖЕНИЕ 1.  Стандартные функции Фортрана-77.........  133

ПРИЛОЖЕНИЕ 2.  Синтаксис инструкций Фортрана-77........  137
































                                                         143

