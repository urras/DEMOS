
            дддд   ееееее   м     м    oooo     сссс
           д   д   е        мм   мм   o    o   с    с
          д    д   е        м м м м   o    o   с    с
          д    д   еееее    м  м  м   o    o   с
          д    д   е        м     м   o    o   с
          д    д   е        м     м   o    o   с    с
         дддддддд  ееееее   м     м    oooo     сссс



          демосдемосдемосдемосдемосдемосдемосдемосде
          емосдемосдемосдемосдемосдемосдемосдемосдем
          мо                                      мо
          ос                                      ос
          сд        ОПЕРАЦИОННАЯ СИСТЕМА          сд
          де                                      де
          ем               ДЕМОС                  ем
          мо                                      мо
          ос                                      ос
          сд                                      сд
          де             Версия 1.0               де
          ем                                      ем
          мо                                      мо
          сдемосдемосдемосдемосдемосдемосдемосдемосд
          демосдемосдемосдемосдемосдемосдемосдемосде







                 Руководство программиста.
                Интерпретатор команд CSHELL







                 Давидов  Михаил Изгияевич
                 Антонов  Вадим Геннадиевич
                Володин  Дмитрий Викторович
                 Леонтьев Сергей Евгеньевич









                       МОСКВА - 1985








                                                           1








   Описывается интерпретатор  команд  cshell  (csh).  Описан
входной  язык,  взаимодействие с системой. Приведены примеры
использования интерпретатора "csh".























































2




            1. ВВЕДЕНИЕ. ОБЩИЕ СВЕДЕНИЯ О CSHELL


   Для большинства пользователей ОС ДЕМОС связь  с  системой
обеспечивается  с  помощью  программ  под  названием shell и
cshell (команды "sh" и  "csh").  Данный  документ  описывает
программу  cshell,  которую  мы будем для краткости называть
CSH. Эта программа является интерпретатором командных строк.
Она  читает строки, введенные пользователем или записанные в
командный файл, и интерпретирует их в качестве запросов  для
выполнения  других  программ.  В  простейшем  виде командная
строка состоит из имени команды ОС ДЕМОС, за которым следуют
ее аргументы, разделенные пробелами:

                 command arg1 arg2 ... argN

CSH разделяет имя команды и аргументы на  отдельные  строки.
Затем  осуществляется  поиск файла с именем command. Command
может быть как  именем  команды  из  какого-то  стандартного
справочника команд, так и полным именем файла, который нужно
выполнить в качестве команды. Аргументы, принятые в CSH, пе-
редаются  команде. По окончании выполнения команды возобнов-
ляется выполнение самого CSH, который сообщает о  своей  го-
товности принять другую команду выдачей на дисплей приглаше-
ния.

   Для того чтобы определить дескриптор  какого-либо  файла,
используемого   в  программе,  его  необходимо  открыть  или
создать. Программы, выполняемые CSH, начинают  выполнение  с
тремя открытыми файлами, дескрипторы которых 0, 1 и 2. Когда
такая программа начинает выполнение, файл 1 открыт для запи-
си  и чаще всего называется стандартным выводом. За исключе-
нием некоторых случаев, указанных ниже, этот  файл  является
файлом  выдачи на экран дисплея пользователя. Таким образом,
программы, которым требуется выдать  информационные  сообще-
ния,  обычно  используют  дескриптор файла 1. Соответственно
файл  0,  открытый  при  запуске,  используется  для  чтения
данных, обычно это файл ввода с клавиатуры дисплея.

   CSH имеет  возможность  изменить  стандартные  назначения
этихдескрипторов. Если один из аргументов команды начинается
с символа ">", то файл, имя  которого  указывается  за  этим
символом,  назначается  стандартным файлом вывода. Например,
команда

                             ls

выводит на экран дисплея перечень имен файлов, находящихся в
текущем справочнике. Команда

                         ls > file

создает file и помещает туда этот перечень.  Таким  образом,
">" означает "поместить выходные данные в file".

   Команда ed запускает редактор, который принимает  команды





                                                           3

редактирования с дисплея пользователя. Тогда как команда

                         ed < file

интерпретирует file, как имя файла, содержащего команды  ре-
дактирования.  Следовательно, "<" означает "получить входные
данные из файла file".

   Хотя имя файла рядом с символами "<" или ">" выглядит как
аргумент  команды,  на  самом деле эти символы полностью ин-
терпретируются в CSH и не передаются команде. Таким образом,
отпадает  необходимость в специальном кодировании для управ-
ления переопределением ввода/вывода внутри  каждой  команды.
Для  этого  нужно  просто использовать соответствующие стан-
дартные дескрипторы файлов 0 и 1, используя  символы  ">"  и
"<".

   Дескриптор файла 2, также как и дескриптор файла 1, обыч-
но  связывается  с  экраном дисплея. Когда задана команда на
вывод данных с символом ">", то файл 2 остается связанным  с
экраном  дисплея пользователя. Команды могут выдавать в файл
с дескриптором 2  диагностические   сообщения,  которые  при
этом не записываются в выходной файл, а выводятся на экран.

   Для прямой связи выходных данных одной команды со  входом
другой используется так называемый "канал межпроцессной свя-
зи". Некоторая последовательность команд, разделенных симво-
лом  "|"  (вертикальная черта), заставляет программу CSH вы-
полнить все команды  одновременно  и  соединить  стандартный
вывод  каждой команды со стандартным вводом следующей коман-
ды, указанной в последовательности. Следовательно, в  комад-
ной строке

        ls | pr -2 | lpr

команда ls будет осуществлять вывод имен файлов, находящихся
в тeкущем справочнике. Ее выходные данные передаются команде
pr, которая обеспечивает постраничное форматирование с  ука-
занием даты. Аргумент "-2" запрашивает двухколоночной вывод.
Аналогично, выходные данные из команды pr становятся входны-
ми  данными  для команды lpr. Эта команда буферизует входные
данные для последующей их распечатки.

   Эта же процедура могла бы быть выполнена более сложно при
помощи следующей последовательности:

        ls > file1
        pr -2 file1 > file2
        lpr < file2


   Программы, аналогичные программе pr, производящие переда-
чу  данных из стандартного ввода на стандартный вывод (с об-
работкой), называются фильтрами. Такие фильтры  полезны  для
выполнения  перекодировок  символов,  выборки  строк в соот-
ветствии с образцом, сортировки входных данных и т.д.

   Процессы, связанные последовательно друг с  другом  через
каналы межпроцессной связи, образуют "конвейер". Таким обра-
зом, конвейер - это последовательность процессов,  связанных
межпроцессными  каналами.  Процесс  может занимать различные
положения в конвейере:


4


   - быть первым. В этом случае он должен поставлять  данные
     в  файл  стандартного  вывода,  то есть в межпроцессный
     канал. В примере

        ls | pr -2 | lpr


     это команда ls, которая создает листинг рабочего  спра-
     вочника и ее вывод направляется команде pr.

   - быть последним в конвейере. Тогда этот  процесс  читает
     данные  из  межпроцессного  канала,  соединяющего его с
     предыдущим процессом, а  пишет  данные  либо  на  стан-
     дартный  вывод (дескриптор 1), либо в указанный файл. В
     примере

        ls | pr -2 | lpr


     это команда lpr, которая читает свой  ввод  из  межпро-
     цессного  канала,  и, обработав данные, направляет их в
     буфер для последующей печати на АЦПУ.

   - занимать промежуточное  положение  в  конвейере.  Тогда
     этот  процесс читает свои даные из межпроцессного кана-
     ла, соединяющего его с предыдущим процессом  конвейера,
     и направляет свой вывод в межпроцессный канал, соединя-
     ющий его со следующим процессом конвейера.

   Следующая особенность программы CSH относительно  проста.
Команды  не обязательно должны находиться на отдельных стро-
ках. Вместо этого они могут быть разделены точкой с запятой.
Например, последовательность команд

        ls ; ed


сначала перечислит содержимое справочника, а затем  запустит
редактор.

   Связанная с этой другая особенность более интересна. Если
команда  завершается символом "&", то программа CSH не будет
ожидать окончания команды. Вместо этого, она сразу же  будет
готова принять новую строку. Например, команда

        as file.s  >  output &

вызывает ассемблирование файла file.s и передачу  диагности-
ческих сообщений в output. При этом не важно, сколько време-
ни длится ассемблирование, приглашение выдается сразу.  Если
программа  CSH  не  ждет  завершения  команды, то она выдает
номер запущенного процесса. Этот номер может быть  использо-
ван  для  ожидания завершения команды или ее принудительного
останова. Символ "&" может быть использован  в  строке  нес-
колько раз:

        as file.s > output & ls > file &

Эта командная строка выполняет трансляцию и печать  справоч-
ника в фоновом режиме.



                                                           5

   Программа CSH также допускает использование скобок в при-
веденных выше операциях. Например, команда

        ( date ; ls ) > file &

выдает текущую дату и время, совместно с листингом  текущего
справочника в file. Программа CSH также немедленно возвраща-
ется за следующим запросом (выводит приглашение).

   Программа CSH сама по себе тоже является командой и может
быть  вызвана рекурсивно. Предположим, что file.csh содержит
строки:

        #
        as file.s
        mv a.out program
        program


   В первой строке указан символ  "#"  -   это  признак  ко-
мандного  файла,  написанного на языке CSH (иначе файл будет
обрабатываться интерпретатором "sh").  Команда  mv  вызывает
переименование файла a.out в program. Файл a.out представля-
ет собой (двоичный) файл, содержащий результаты  работы  ас-
семблера  и готовый к исполнению. Таким образом, если приве-
денные выше строки были бы введены с терминала, произошла бы
трансляция file.s, переименование результирующей программы в
program и исполнение program. В том случае, если строки  на-
ходятся в файле file.csh , команда

        csh < file.csh

обеспечит  последовательное  выполнение   заданных   в   них
действий.

   Кроме перечисленных выше, программа CSH обладает дополни-
тельными возможностями, включающими способность замены пара-
метров и создания списков аргументов из определенных подмно-
жеств имен файлов в справочнике. Возможно также условное вы-
полнение команд и организация циклов. Кроме того CSH поддер-
живает   так   называемый  механизм  подстановок  и  истории
(history). Этот механизм осуществляет действия  со  строками
ранее  набранных команд, при этом появляется возможность су-
щественно сократить об'ем вводимой с клавиатуры дисплея  ин-
формации.

   Теперь можно описать некоторые  детали  работы  программы
CSH.  Большую  часть времени программа CSH ожидает ввода ко-
манды с дисплея пользователем.  Как  только  пользователь  в
конце строки напечатает символ "возврат каретки", заканчива-
ется операция чтения и  управление  передается  в  программу
CSH. Эта программа анализирует командную строку и преобразу-
ет аргументы в форму, пригодную  для  выполнения  системного
вызова  exec. Затем вызывается системный вызов  fork для по-
рождения нового процесса. Если этот вызов выполняется успеш-
но,  то начинается выполнение программы с заданным именем. В
это время исходный процесс CSH  выполняет  команду  ожидания
wait  до  тех  пор,  пока не завершится порожденный процесс.
Когда это произойдет, программа CSH считает, что команда за-
вершена,  печатает  приглашение  и начинает чтение с дисплея
для получения следующей команды.



6

   С учетом сказанного выше реализация процессов  в  фоновом
режиме  проста:  если  командная строка содержит символ "&",
программа CSH просто не ожидает завершения процесса, создан-
ного для выполнения команды.

   Этот механизм удобен для работы со стандартными  входными
и  выходными файлами. Когда создается процесс при помощи вы-
зова fork, он наследует не  только  образ  памяти  исходного
процесса,  но  также  и  дескрипторы всех файлов, открытых в
нем, включая те, дескрипторы которых равны 0, 1 и  2.  Прог-
рамма  CSH  использует эти файлы для чтения командных строк,
для вывода подсказок и диагностических сообщений, и в  обыч-
ном  случае, порожденный процесс наследует их автоматически.
Когда среди аргументов встречаются символы "<" или ">",  по-
рожденный процесс перед выполнением команды exec присваивает
дескриптор файла стандартного ввода/вывода (0  или  1  соот-
ветственно) названному файлу.

   В нормальных условиях программа CSH никогда не выходит из
своего основного цикла. Основным условием, вызывающим завер-
шение программы CSH,  является  обнаружение  условия  "конец
файла" во входном файле. Таким образом, при выполнении прог-
раммы CSH в качестве команды с командным входным файлом, как
показано в примере:

        csh < file.csh

команды в файле file.csh будут выполняться до тех пор,  пока
не  будет  достигнут конец файла. В этом случае процесс CSH,
вызванный запросом "cshell < file.csh", завершится. Так  как
этот  процесс  является  порождением другого процесса CSH, в
последнем завершится ожидание и тогда может выполняться дру-
гая команда.

   В нормальном режиме работы ОС ДЕМОС выполняется следующая
последовательность процессов, порождаемых программой init:

   - программа init создает по  одному  отдельному  процессу
     init   для  каждого  дисплейного  канала,  читает  файл
     /etc/ttys (файл имен подключенных дисплеев),  открывает
     для  каждого  дисплея  файлы с дескрипторами 0, 1, 2 и,
     передав управление программе getty, переходит  в  режим
     ожидания;

   - программа getty получает от init в  качестве  аргумента
     имя  дисплея  и  наследует  дескрипторы файлов 0, 1, 2.
     Программа getty устанавливает параметры дисплея  (смот-
     рите  команду  stty)  и  передает  управление программе
     login;

   - программа login выводит приглашение и ждет ввода  имени
     пользователя.  После ввода имени программа login читает
     файл /etc/passwd - парольный файл системы и, если поль-
     зователь с таким именем зарегистрирован в системе, зап-
     рашивает пароль. После получения верного  пароля  прог-
     рамма  login  запускает программу sh или csh - оболочку
     пользователя, указанную в файле /etc/passwd в  качестве
     основной для данного пользователя. Если попытка войти в
     систему оказалась неудачной, то программа  login  снова
     выводит приглашение и ждет ввода имени пользователя;




                                                           7

   - программа  csh  читает  сначала  файл   ~.cshrc,  потом
     ~.login,  в которых устанавливаются значения внутренних
     переменных CSH, тип приглашения, псевдонимы команд, вы-
     числяет  хеш-таблицы команд, расположенных в справочни-
     ках, которые указаны как стандартные, и выводит пригла-
     шение.  Если  пользователь не установил приглашение, то
     выводятся стандартные формы приглашений -   символ  "%"
     для  рядового  пользователя  и  символ  "#"  для супер-
     пользователя;

   - по символу конец файла (CNTRL/D) или (СУ/D) CSH прекра-
     щает  работу.  Выход  из CSH возможен также по командам
     login, logout и exit. По завершению работы  CSH,  прог-
     рамма  init  прекращает  ожидание  и поцессы, описанные
     выше, повторяются.

   Здесь уместно заметить, что программы init, getty,  login
устанавливают также значения переменных окружения, которые в
последствии используются CSH как константы.













































8




                      2. ВВОД - ВЫВОД


   CSH позволяет переадресовывать стандартный ввод  и  стан-
дартный  вывод. Переадресация осуществляется с помощью аргу-
ментов команды специального вида, которые обрабатываются ин-
терпретатором CSH перед вызовом команды. Интерпретатор пони-
мает  следующие  аргументы,   осуществляющие   переадресацию
ввода-вывода:


   2.1. Ввод


        < "имя_файла"


   - открывается файл, который становится  стандартным  вво-
     дом;

        << "слово"


   - в качестве файла стандартного ввода  подставляются  все
     строки  из  командного файла либо из ввода с терминала,
     начиная со следующей и кончая строкой,  совпадающей  со
     "словом".  CSH  прекращает подстановку, когда введенная
     строка будет идентична "слову".

Пример:

        cat file << lll
        0123456789
        0123456789
        0123456789
        lll

команда cat создает file и ждет ввода с клавиатуры  дисплея.
Каждая введенная строка сравнивается с "lll". Если она иден-
тична "lll", ввод прекращается. Теперь, если  выполнить  ко-
манду cat file, мы получим:

        0123456789
        0123456789
        0123456789



   2.2. Вывод


        > "имя_файла"


   - результат работы команды направляется в указанный файл.






                                                           9

        >! "имя_файла"


   - "!" отменяет действие переменной noclobber.  Переменная
     noclobber  запрещает  вывод в файл, если он к этому мо-
     менту существует или не  является  специальным  файлом,
     например /dev/tty* .

Пример:

   Допустим, существуют файлы с именем file1 и file2. Допус-
тим, выполнена команда:

        set noclobber

Тогда, команда

        cat file2 > file1

не выполнится, а команда

        cat file2 >! file1

выполнится.  Переменная  noclobber  предотвращает  случайное
повреждение существующих файлов.

        >&  "имя_файла"
        >&! "имя_файла"


   - в первом случае CSH направит диагностические  сообщения
     в  файл,  во  втором, будет сделано то же, но с отменой
     действия переменной noclobber.

        >>  "имя_файла"
        >>! "имя_файла"


   - вывод помещается в конец файла, а если он  отсутствует,
     то  файл  создается,  во втором случае будет сделано то
     же, но с отменой действия переменной noclobber.

        >>&  "имя_файла"
        >>&! "имя_файла"


   - в первом случае CSH направит диагностические  сообщения
     в  файл, во втором случае будет сделано то же, но с от-
     меной действия переменной noclobber.

        |&


   - использование этой конструкции в конвейере  приведет  к
     тому,что все диагностические сообщения будут направлены
     в тот же программный канал, что и стандартный вывод.

Пример:






10

        cat file1 |& pr -w79 -l24 > file2

сообщения об ошибках команд в конвейере будут направлены  не
на стандартный вывод, на экран дисплея, а в file2.




























































                                                          11




                         3. КОМАНДЫ


   CSH позволяет выполнять простые  команды,  последователь-
ности  команд, группы команд, конвейеры, осуществлять парал-
лельное выполнение процессов.


   3.1. Простые команды


   Командой мы называем любой двоичный или  командный  файл,
который  может  быть выполнен под управлением ДЕМОС.  Напри-
мер, команда

        pr -2 -w79 -l24 -t file

выведет на экран дисплея содержимое файла file в две  колон-
ки,  строками  по  79 символов и страницами по 24 строки без
номеров страниц. Команда pr, двоичный выполняемый файл кото-
рой размещен в справочнике /bin, позволяет выполнить различ-
ную работу перед выводом файла. Режимы работы команды pr за-
даются  флагами,  им  в  командной строке предшествуют знаки
"-". Наличие знаков "-" или "+" перед флагом - это  соглаше-
ние  программистов, сочиняющих команды в юниксоподобных опе-
рационных системах. Кроме того, в командной  строке  указано
имя файла "file", который необходимо обработать команде pr.

   CSH выполнит следующую  работу  прежде,  чем  команда  pr
начнет выполнять свою:

   - проанализирует командную строку на предмет ошибок;

   - найдет двоичный выполняемый файл в одном из стандартных
     справочников (в данном случае - в /bin);

   - передаст его на выполнение операционной системе  вместе
     с флагами и именем файла.

   По завершению работы команды, CSH выдаст приглашение, это
значит,  что  он готов принять следующую команду на выполне-
ние.

   Командная строка обьединяет несколько  слов,  разделенных
пробелами, первое из которых - собственное имя команды. Сло-
во - одно из важных понятий CSH. Оно практически совпадает с
интуитивным,   однако,   CSH   позволяет  создавать  сложные
конструкции, часто отличающиеся от  того,  что  мы  привыкли
считать словом.


   3.2. Последовательности команд


   Часто  бывает  необходимо  выполнить   последовательность
команд.  В этом случае можно использовать символ ";", напри-
мер:




12

    cat file ; pr -2 -w79 -l24 -t file

Эта командная строка управляет выполнением двух команд. Сна-
чала  file  будет  выведен  на дисплей таким, какой он есть,
затем командой pr, со всеми указанными преобразованиями. CSH
позволяет  включать  логические условия выполнения элементов
последовательности команд,например:

    cat file && pr -2 -w79 -l24 -t file

Вторая команда в этой  последовательности  выполнится,  если
успешно  выполнится  первая, то есть  если file существует и
его разрешено читать.

    cat file1 || pr -2 -w79 -l24 -t file

В этом случае вторая команда выполнится, если первая не  вы-
полнится, например, если file1 отсутствует.

   Таким образом, разрешается использовать "&&" и  "||"  для
управления последовательностями команд.


   3.3. Группирование команд


   Для группирования  команд  используются  круглые  скобки.
Группа команд, заключенная в круглые скобки, выполняется как
самостоятельная конструкция и не влияет на внутренние  пере-
менные  других  конструкций командной строки, находящихся за
пределами круглых скобок. Например:

   ls -l; ( cat f1 && cat f2 ) && date

Сначала будет выдан листинг рабочего справочника, затем  вы-
полняется  группа  команд  в  скобках  и, если оба файла су-
ществуют и разрешено их  чтение,  выполнится  команда  date.
Синтаксический  анализатор   CSH требует, чтобы около скобок
находились либо ";" ,либо "&&" , либо "||", либо другие раз-
делители, о которых будет сказано ниже.


   3.4. Программный канал и конвейер


   Конвейер служит удобным средством для  организации  обра-
ботки  информации различными программами (командами) над по-
током данных.

   Последовательность команд,  раз'едененных  символом  "|",
образует конвейер команд, связанных между собой программными
каналами. Выход команды в в межпроцессном канале  передается
на вход следующей команде.

Пример:

    cat file | pr -2 -w79 -l24 -t

Команда cat выводит содержимое file, которое  обрабатывается
командой pr и выводится на экран дисплея.




                                                          13

Пример:

  cat -n file | pr -2 -w79 -l24 -t

Команда cat проставляет номера строк в file, и ее вывод  пе-
редается  команде pr для форматирования. Результат выводится
на экран дисплея.

Пример:

sort file | cat -n | pr -2 -w79 -l24 | lpr

Команда sort сортирует файл, cat проставляет  номера  строк,
pr  форматирует  вывод, lpr направляет на печатающее устрой-
ство через буфер.

   Процессы в конвейере можно разделять  с  помощью  "&&"  и
"||" , группировать круглыми скобками, разделять ";".

Пример:

(cat f1&&date )&&(cat -n f1 | sort -r);date

если имеется файл f1, он выводится на дисплей, затем,  выво-
дится  дата,  и команда cat, пронумеровав строки, направляет
файл на сортировку. Команда sort -r сортирует файл в  обрат-
ном порядке. На экран выводится результат сортировки и дата.
Если f1 отсутствует или  его  нельзя  читать,  то  выводится
только дата.


   3.5. Параллельное выполнение


   CSH позволяет перейти к приему новой командной строки, не
дожидаясь завершения  предыдущей. Это позволяет пользователю
запустить на выполнение несколько процессов и продолжать ра-
боту  в  интерактивном  режиме. Символ "&" в конце командной
строки обязывает CSH перейти в режим  чтения  следующей  ко-
мандной строки, не дожидаясь завершения выполнения данной.

Пример:

   cat -n f1 | pr -2 -w79 -l24 -t > f2 &

Команда cat выводит строки с номерами, команда pr форматиру-
ет их, вывод направляется в f2, CSH выдает номер порожденно-
го данной строкой процесса и приглашение о том, что он готов
принять следующую команду.

  cat -n f1 | pr -2 -w79 -l24 -t >& f2 &

В данном случае в f2 будут направлены сообщения об  ошибках.
Этот способ запуска удобен при компиляции,например:

          cc file.c >& errors &

В файле errors будут записаны все сообщения об ошибках,  об-
наруженных Си-компилятором в программе file.c .





14




               4. ЛЕКСИЧЕСКАЯ СТРУКТУРА  CSH


   Выше было сказано о важности  понятия  "слово"  в  CSH  .
Интерпретатор команд считывает входную строку и разбивает ее
на "слова". Последовательность слов  подвергается  граммати-
ческому разбору, после чего выполняется собственно команда.


   4.1. Слово


   Слово -  это завершенная конструкция, которую  распознает
CSH.

   CSH разбивает входную строку на слова в местах пробелов и
табуляций, однако, имеются исключения:

        "&"   ,   "|"   ,   ";"   ,  "<"  ,

        ">"   ,   "("   ,   ")"   , "||"  ,

        "&&"  ,   ">>"  .

Эти символы разделяют цепочку символов  на  отдельные  слова
даже  тогда,  когда отсутствуют пробелы и табуляции. Ниже мы
будем называть их метасимволами CSH. Если необходимо исполь-
зовать эти символы в качестве части слова, а не разделителя,
используется экранирование  символом "\".

Пример:

        \;

символу ";" предшествует символ "\", и  он  будет  восприни-
маться  не  как  разделитель группы команд, а как символ ";"
некоторого слова, которому принадлежит.


   4.2. Часть слова


   CSH позволяет оперировать частями слов, осуществлять  над
ними различные преобразования.

 "строка"   ,   'строка'    ,    `строка`

Строка символов, взятая в двойные кавычки или одинарные  ка-
вычки  (правые  или  левые), рассматривается как часть слова
при грамматическом разборе  командной  строки.  Метасимволы,
двойные  кавычки и одинарные кавычки также экранируются сим-
волом "\".

   Строка, заключенная в двойные  кавычки,  интерпретируется
CSH.  Все метасимволы и их последовательности будут заменены
соответствующими подстановками.

   Строка, заключенная в одинарные правые  кавычки,  не  ин-
терпретируется.  Все метасимволы и их последовательности те-


                                                          15

ряют свое специальное значение.

   Строка, заключенная в левые одинарные кавычки, интрерпре-
тируется CSH как команда. Эта команда выполняется, и строка,
заключенная в левые одинарные кавычки, заменяется  результа-
том.


   4.3. Продолжение строки


   Если командная строка занимает более одной строки, то  ее
можно  продолжить на следующей строке, поставив перед симво-
лом конца строки символ "\".


















































16




             5. МЕХАНИЗМ ПОДСТАНОВКИ (HISTORY)


   CSH запоминает командные строки, которые вводил пользова-
тель  в  процессе работы и позволяет манипулировать ими, что
существенно сокращает количество символов, которое требуется
ввести  с  клавиатуры  дисплея,  чтобы выполнить то или иное
действие.

   Количество запоминаемых CSH командных строк  определяется
переменной  history,  которая  обычно  определяется  в файле
.cshrc, о котором будет сказано ниже.


   5.1. Команда history


   Чтобы вывести на экран дисплея протокол действий, пользо-
вателю необходимо выполнить команду:

        history

CSH  выведет на экран  командные  строки,  которые  выполнял
пользователь  до команды history. Каждая строка имеет номер,
что позволяет запустить ее на выполнение,  указывая,  напри-
мер,  соответствующий номер.


   5.2. Подстановка команд


   Символ "!" служит указанием для CSH,  что  все  указанное
далее  относится к некоторой строке истории действий пользо-
вателя. Этот указатель может стоять в  начале  или  в  любом
другом месте командной строки.

   Пусть после выполнения команды history на  экран  дисплея
выведено:

 1  cat file1
 2  pr -w79 -l24 -2 file1
 3  cc program.c >& errors &
 4  cat errors
 5  ed program.c
 6  history

Тогда CSH выполнит следующие команды, осуществляя подстанов-
ки следующим образом:

!2
   - выполнится команда, записанная во второй строке;

!3
   - выполнится команда,записанная в третьей строке;

!!
   - выполнится  последняя  команда  в   протоколе   истории
     действий.  Другими  словами,  команда "!!" требует пов-
     торного выполнения последней команды;


                                                          17


!-2
   - выполнится команда, записанная в четвертой строке;

!cat
   - выполнится команда, записанная в четвертой строке.  CSH
     просматривает  строки истории снизу и выполняет первую,
     в которой найдена  последовательность  символов  "cat",
     стоящая в начале строки;

!c
   - результат будет тот же;

!{c}.a1.i-
   - выполнится команда:

           cat errors.a1


     CSH найдет команду, начинающуюся с  символа  "c",  и  к
     последнему  слову  командной строки допишет без пробела
     указанную после закрывающей фигурной скобки  последова-
     тельность символов, в данном случае ".a1" ;

!?gram?
   - выполнится пятая строка истории. CSH выберет для выпол-
     нения  эту  строку,  так  как в ней будет найден шаблон
     "gram". Здесь символы "?" выделяют шаблон, по  которому
     осуществляется поиск;

cat  !5*
   - выполнится команда cat program.c CSH подставит все сло-
     ва пятой строки  истории, исключая первое;

cat !5* !1*
   - выполнится команда:

                cat program.c file1


     CSH подставит слова  пятой  и  первой  строки  истории,
     исключая первые слова этих строк;

!pr !5*
   - выполнится команда:

          pr -w79 -l24 -2 file1 program.c


     К списку слов второй строки истории будет добавлен спи-
     сок  слов  пятой  строки, причем, из пятой строки будут
     выбраны все слова, исключая первое.


   5.3. Определитель слов команды


   CSH  позволяет выбирать отдельные слова в командных стро-
ках для включения их в вводимую командную строку.

   Слова командной строки нумеруются, начиная с 0:



18

   - Слово с номером 0 - обычно имя команды.

   - Слово с номером 1 - первое слово команды.

   - Остальные слова имеют номера по порядку.

   Слово можно выделить, используя  определитель.  Определи-
тель слова позволяет выбрать слово из командной строки исто-
рии, либо по номеру, либо по шаблону.

Определители:

*  - выбрать все слова, начиная со слова с номером 1;

n*
   - выбрать все слова, начиная со слова с номером n;

n-
   - выбрать все слова, начиная со слова  с  номером  n,  не
     включая последнего;

-n
   - выбрать все слова, начиная со слова с номером 0 до сло-
     ва с номером n;

n-m
   - выбрать все слова, начиная со слова с номером n и  кон-
     чая словом с номером m;

n  - выбрать слово с номером n;

%  - выбрать слово, соответствующее шаблону,  указанному  до
     символа "%". Шаблон указывается как "?...?";

   Кроме того, существуют специальные обозначения для  слова
с номером 1 и последнего слова:

^  - слово с номером 1;

$  - последнее слово;

Эти сокращения удобны при наборе длинных командных строк.

   Правило использования определителя:

   перед указанием определителя  необходимо  указать  символ
   ":". Однако символ ":" можно не указывать перед следующи-
   ми определителями:

    ^       $       *       -       %

Пример:

Пусть после выполнения команды history на экран дисплея  вы-
ведено:

 1  cat file1 file2 file3
 2  pr -w79 -l24 -2 file1 file5
 3  cc -o program1.c program2. c>& errors &
 4  cat errors
 5  ed program2.c
 6  history


                                                          19


Тогда CSH выполнит команды, осуществляя  подстановки  следу-
ющим образом:

!5:0 !1:3
   - из пятой строки выбирается слово с номером 0 ( имя  ко-
     манды ), из первой строки выбирается слово с номером 3.
     Выполнится команда:

                   ed file3


!5:0 !1$
   - из пятой строки выбирается слово с номером 0, из первой
     строки последнее слово. Выполнится команда:

                   ed file3


!2:-3   !3:2-3
   - из строки 2 выбираются слова с номерами от 0 до 3 вклю-
     чительно,  из  строки 3 выбираются слова с номерами 2 и
     3. Выполнится команда:

      pr -w79 -l24 -2 program1.c program2.c


!2-3    !3:2-3
   - выполнится та же  команда.  Перед  "-"  в  определителе
     символ ":" можно не ставить.

!2-3    !?prog?%
   - выполнится команда:

           pr -w79 -l24 -2 program2.c


     По конструкции !?prog?% выполняется сравнение с  шабло-
     ном.   В   5   строке   по   шаблону  выделяется  слово
     "program2.c" и по определителю  "%" выполняется подста-
     новка.

   Кроме того, обращение  к  предшествующим  командам  может
быть выполнено без спецификации команды, например так: "!$".
В этом случае обращение относится к предыдущей команде. Нап-
ример, если предыдущая команда имеет вид:

        cat file1 file2 file3    ,

то команда

        cat errors program1.c !$

выполнится как

        cat errors prrgram1.c file3








20

   5.4. Модификаторы слов в history


   После необязательного определителя могут указываться  мо-
дификаторы  слов, которые позволяют выполнить ряд преобразо-
ваний над словом, и оно подставляется в командную строку мо-
дифицированным.

t  - удаляет имена всех справочников, ведущих к  файлу,  ос-
     тавляя имя файла;

h  - удаляет имя файла , оставляя имена справочников,  веду-
     щих к нему;

r  - удаляет расширение имени файла, указанное через ".";

g  - применить модификацию во всех словах. Указывается перед
     именем  модификатора,  который  необходимо применить ко
     всем словам;

p  - распечатать новую команду, но не выполнять ее;

q  - подставлять модифицированное слово, заключив его в  ка-
     вычки. Это необходимо тогда, когда желательно запретить
     дальнейшую модификацию этого слова;

x  - заключить модифицируемое слово в  кавычки,  разбив  его
     перед подстановкой на отдельные слова, там, где имеются
     пробелы, табуляции или  символ  новой  строки  "\<конец
     строки>"  . При этом запрещается дальнейшая модификация
     последовательности полученных слов -  они  заключены  в
     кавычки;

&  - повторить предыдущюю подстановку;

s/l/r/
   - заменить цепочку символов l на цепочку r. Шаблоны l и r
     можно  разделять любыми символами, которых нет в шабло-
     нах. Если r - пустое множество, то l удаляется;

   Перед каждым модификатором необходимо ставить символ ":",
если  имеется определитель слова, то модификатор должен сле-
довать за ним!

   Пусть после выполнения команды history на  экран  дисплея
выведено:

 1  cat /usarc/gruppa/ivanov/file1.c
 2  pr -w79 /usarc/gruppa/ivanov/file1.c
 3  cc pa1.c pa2.c pa3.c pa4.c >& errors &
 4  cat errors
 5  ed program.c
 6  history

Тогда CSH выполнит команды, осуществляя подстановки и  моди-
фикации следующим образом:

!1:0  !1^:t:r
   - !1:0 выбирает из строки с номером 1 слово с номером  0,
     т.  е.  имя команды, в данном случае cat. Далее !1^:t:r
     выбирает из первой строки слово с номером 1,  в  данном
     случае  это /usarc/gruppa/ivanov/file1.c. Модификатор t


                                                          21

     удалит из этого слова имена справочников, в данном слу-
     чае  удаляется  /usarc/gruppa/ivanov,  и  слово  теперь
     будет именем файла file1.c. Модификатор r удалит расши-
     рение  имени  файла,  в данном случае это ".c" и, слово
     теперь будет именем файла file1 . Таким образом, выпол-
     нится команда:

                    cat file1


!1:0  !1^:h/document
   - по определителю ^ будет  выбрано  первое  слово  первой
     строки, модификатор h удалит из него имя файла, оставив
     имена справочников, ведущих к нему. CSH допишет к этому
     слову цепочку символов "/document", и выполнится коман-
     да:

         cat /usarc/gruppa/ivanov/document


!1:0  !1^:h:s?ivanov?sidorov?/document
   - модификатор выберет из первого слова первой строки име-
     на  справочников,  ведущих к файлу, затем модификатор s
     заменит "ivanov" на "sidorov". CSH допишет к слову  це-
     почку символов "/document", и выполнится команда:

        cat /usarc/gruppa/sidorov/document


!1:0  !1^:h:s?ivanov?sidorov?/document:p
   - то же, что и выше, но модификатор p  указывает  CSH  не
     выполнять   команду,  а  только  распечатать  результат
     подстановок и модификаций. На экран дисплея будет выве-
     дено:

        cat /usarc/gruppa/sidorov/document


!1:0 !1^:h:s?ivanov?sidorov?/doc !1^:&:p
   - первые два слова командной строки действуют  аналогично
     предыдущему   примеру,  третье  слово  требует  от  CSH
     выбрать из первой строки истории слово с  номером  1  и
     произвести  в нем замену ( модификатор & ), аналогичную
     предыдущей,  т.е.  выполнить  замену  ?ivanov?sidorov?,
     сохранив все остальное в этом слове. Модификатор p обя-
     зывает CSH не выполнять команду, а только вывести ее на
     экран дисплея, на который будет выведено:

          cat /usarc/gruppa/sidorov/doc\
           /usarc/gruppa/sidorov/file1.c


!1:0 !3:1-4:gs?pa?ff?:p
   - имя команды выбирается из первой строки истории,  из  3
     строки  выбираются все слова с номерами от 1 до 4 вклю-
     чительно и в них глобально (модификатор g) делается за-
     мена ?pa?ff? . Команда будет напечатана , но выполнять-
     ся не будет (модификатор p):






22

             cat ff1.c ff2.c ff3.c ff4.c



   5.5. Замены в последней строке


   CSH позволяет осуществлять удобные подстановки из послед-
ней строки, предоставляя при этом простейшее средство ее ре-
дактирования  .  Для  этих  целей  используется  конструкция
"^шаблон^замена".

   Допустим, последняя строка имеет вид:

        cat aaa bbb ccc ddd ,

тогда после команды

        ^ccc^file.c

будет выполнена замена :

        cat aaa file.c ccc ddd



   5.6. Псевдонимы


   В CSH имеется возможность ввести краткие обозначения  для
часто  встречающихся  команд  или  изменить смысл каких либо
команд.

   Интерпретатор команд ведет  список  псевдонимов,  которые
могут устанавливаться, отображаться и модифицироваться с по-
мощью команд alias  и  unalias.  После  просмотра  командной
строки  она разбивается на отдельные команды, и первое слово
каждой команды проверяется (слева направо), чтобы  выяснить,
имеет  ли оно псевдоним. Если да, то текст, который является
псевдонимом данной команды, считывается с помощью имеющегося
механизма  подстановки  предшествующих команд так, как будто
сама эта команда была предыдущей входной строкой. Полученные
в  результате  слова  заменяют  команду и список параметров.
Если отсутствовали обращения к списку предшествующих команд,
то список параметров остается без изменений.

   Таким образом, если  "ls  -l"  является  псевдонимом  для
"ls",  команда "ls /usr" будет преобразована в "ls -l /usr",
а список параметров остается без изменений. Аналогично, если
псевдонимы  для "lookup" является "grep !^ /etc/passwd", ко-
манда "lookup bill" будет преобразована в команду "grep bill
/etc/passwd".

   Если псевдоним был обнаружен, выполняется  преобразование
слов входного текста и продолжается процесс поиска псевдони-
мов в преобразованной входной строке. Если первое слово  но-
вого  текста совпадает с первым словом старого, зацикливание
предотвращается посредством установки  флага,  прекращающего
дальнейший  поиск псевдонимов. Другие циклы обнаруживаются и
вызывают ошибку.




                                                          23

   Этот механизм позволяет вводить новый  синтаксис  команд.
Таким образом, можно построить команду, которая будет распе-
чатывать на линейном принтере  свои  параметры,  посредством
"alias print 'pr \!* | lpr'".




























































24




                  6. СПЕЦИАЛЬНЫЕ ФАЙЛЫ CSH


   CSH при загрузке читает файлы .login и .cshrc, а при  за-
вершении  работы файл .logout . Кроме того, имеется еще спе-
циальный файл для электронной почты .mail . При входе  поль-
зователя  в  систему  первым  читается  файл .cshrc. Все эти
файлы размещаются в регистрационном справочнике  пользовате-
ля.


   6.1. Файл '.login'


   Файл .login определяет те действия CSH, которые он выпол-
нит при регистрации пользователя. Ниже приведен пример этого
файла:

        set ignoreeof
        set history=22
        set prompt = 'IVANOV_\!> '
        set mail = ( 60 ~/.mail )
        msgs
        stty dec
        setenv MSG r

В первой строке устанавливается команда CSH ignoreeof, кото-
рая предотвращает случайное завершение работы CSH  при набо-
ре на клавиатуре дисплея символа СУ/D (CNTRL/D).  Во  второй
строке  устанавливается  количество  строк  history, которое
должно запоминаться CSH . В третьей  строке  устанавливается
приглашение,  которое будет выдавать CSH при готовности при-
нять  новую  командную  строку.  Здесь  вместо  '\!'   будут
подставляться текущие номера строк history, например, так:

        IVANOV_15>


   В четвертой строке для  CSH   указывается  имя  почтового
файла  (.mail) и количество секунд, через которое CSH должен
опрашивать этот файл. По умолчанию, это время устанавливает-
ся  равным 10 минутам. Если файл .mail будет не пуст , то на
экране дисплея появится сообщение "You have  new  mail"  ("У
Вас есть новая почта ").

   В пятой строке записано обращение к команде "msgs", кото-
рая выдает новые информационные сообщения при каждом входе в
систему (эти сообщения заносятся системными  программистами,
сопровождающими ОС ДЕМОС).

   В шестой строке устанавливается режим работы с терминалом
в  стиле ОС РАФОС и ОС РВ (отмена символа по клавише "забой"
и т.п.).

   В седьмой строке определяется переменная  "MSG",  которая
определяет язык диагностик (в данном случае - русский).





                                                          25

   6.2. Файл '.logout'


   При завершении работы CSH читает файл .logout и выполняет
указанные в нем действия. Ниже приведен пример такого файла:

        echo " Logout I.IVANOV.  date: "
        date

Первая строка выводит на экран дисплея сообщение о выходе из
системы пользователя И.Иванова . Вторая строка выполняет ко-
манду date, которая выводит текущую дату на экран дисплея.

   В этом файле можно разместить все команды, которые  необ-
ходимо  выполнить  по выходе из системы. Важно отметить, что
несмотря на выход пользователя из системы, все процессы, за-
пущенные им как фоновые, будут продолжать выполняться.


   6.3. Файл '.cshrc'


   При каждом вызове  CSH просматривает файл .cshrc и выпол-
няет все действия и назначения, указанные в нем. Ниже приве-
ден пример файла .cshrc:

        set path = ( . /bin /usr/bin )
        set history = 22
        set prompt = 'ivanov_\!> '
        alias  h  history
        alias  c /bin/cat
        alias  l /bin/ls -l

Здесь команда set path=(. /bin  /usr/bin)  устанавливает  те
справочники,  где CSH будет искать команды перед запуском их
на выполнение. Команда set history = 22 устанавливает  коли-
чество  последних командных строк, которые должен запоминать
в истории CSH.

   Команда set prompt = 'ivanov_\!> ' устанавливает  пригла-
шение,  которое будет выводить CSH при порождении новой обо-
лочки. Символы этого приглашения специально набраны  малень-
кими буквами, чтобы у пользователя была возможность отличить
основной режим работы CSH от порожденного нового.  Остальные
команды  демонстрируют возможность использования псевдонимов
команд в CSH.

   Команда alias позволяет пользователю  установить  удобные
для него псевдонимы команд с необходимой мнемоникой и сокра-
щениями. В  примере  такие  сокращения  введены  для  команд
history, cat, ls -l и теперь их можно вызывать соответствен-
но как h, c, l, что существенно облегчит пользователю  вызов
этих команд.

   Файл .cshrc считывается и интерпретируется при порождении
новой оболочки, запущенной пользователем, однако файл .login
при этом не обрабатывается.







26




                     7. ПЕРЕМЕННЫЕ CSH


   CSH поддерживает набор переменных,  значением  каждой  из
которых является список слов, в том числе и пустой. Мы отли-
чаем внутренние переменные CSH  от внешних. Внутрeнние пере-
менные  устанавливают режим работы CSH, а внешние переменные
в основном относятся к тем командам, которые интерпретируют-
ся  им. Обращение к переменным может быть простым - установ-
лена переменная или нет и сложным, например, переменная argv
представляет  образ списка параметров CSH и обращение к сло-
вам, образующим этот список, производится специальным  обра-
зом,  а, например, переменная verbose является флагом, кото-
рый управляет эхо-режимом при вводе командной строки, и  для
CSH существенно лишь наличие флага -v (verbose) при вызове.

   Особоеместо занимают так называемые переменные окружения.
CSH  считывает их значения при порождении оболочки. Значения
переменных окружения становятся внутренними константами  CSH
и  их можно использовать как константы в командных строках и
командных файлах.


   7.1. Внутренние переменные CSH


   Каждая внутренняя переменная имеет определенный смысл для
CSH.  Часть  внутренних  переменных  всегда  устанавливается
самим  CSH  либо  при  инициализации,  либо   при   запуске-
завершении  процессов.  После  этого эти переменные не будут
модифицироваться, если этого не сделает пользователь.

   К числу  внутренних переменных,  которые  устанавливаются
CSH  при инициализации, относятся:

    argv, home, path, prompt, shell


   Переменные child  и status устанавливаются при порождении
процессов и сохраняют свое значение до появления новых.

   Ниже приводится список внутренних  переменных  CSH  и  их
значений:

argv
   - представляет строку параметров  CSH.  К  ней  применимы
     подстановки  позиционных  параметров,  о  которых будет
     сказано ниже.

child
   - номер процесса, выводится на экран дисплея при  запуске
     параллельного процесса. Значение переменной child сбра-
     сывается, когда этот процесс завершается.

echo
   - вызывает печать каждой команды перед  выполнением.  Все
     расширения  выполняются  перед выводом. Устанавливается
     режим echo по флагу "-x" при вызове CSH , например,



                                                          27

               csh  -x comfile

Здесь comfile - имя командного файла, который передается CSH
для интерпретации.

history
   - численное значение этой переменной устанавливает  коли-
     чество  строк,  которое  необходимо  хранить в истории.
     Слишком большое число может вызвать состояние  нехватки
     памяти. Оптимальное число - 22 строки.

home
   - регистрационный справочник пользователя. Его имя считы-
     вается  CSH   при входе пользователя в систему из файла
     /etc/passwd и передается при порождении новых  оболочек
     через environment - окружение.

ignoreeof
   - предотвращает случайное завершение CSH по признаку "ко-
     нец  файла".  Признак конец файла выглядит как СУ/D или
     CNTRL/D при вводе с клавиатуры дисплея.

path
   - переменная path определяет имена справочников, в  кото-
     рых  CSH  будет искать файлы команд, запускаемых на вы-
     полнение. При входе CSH хеширует списки команд,  разме-
     щенных в справочниках, указанных в path, что существен-
     но сокращает время поиска команды при ее запуске.  Если
     после  входа в систему, т.е. после хеширования справоч-
     ников, будет создана и записана в один из  указанных  в
     path  справочников  новая команда, она будет отсутство-
     вать в хеш-таблицах, и CSH не  будет  ее  обнаруживать.
     Для  разрешения  этой ситуации необходимо выполнить ко-
     манду rehash. По команде rehash будут перестроены  хеш-
     таблицы  и новые команды будут доступны CSH. При вызове
     новой оболочки CSH снова читает файл .cshrc в  домашнем
     справочнике  пользователя  и строит хеш-таблицу. На эту
     операцию уходит достаточно много времени и,  если  есть
     необходимость  более  быстрого  старта CSH, при запуске
     необходимо использовать флаги "-c" и "-t", например:

               csh -ct comfile


     Перестройка хеш-таблиц осуществляется также всякий раз,
     когда  с  помощью команды set изменяется значение пере-
     менной path. Переменную path можно  устанавливать  и  в
     файле ".login". Заметим, что порождаемой оболочке также
     всегда  передается  значение  переменной   path   через
     environment - окружение.

prompt
   - переменная prompt является  строкой  символов,  которая
     выдается  CSH  в  качестве приглашения, когда ожидается
     ввод новой командной строки. Если эта  строка  символов
     содержит  "!",  то  на  его место подставляется текущий
     номер командной строки. Если переменная prompt не уста-
     новлена,  то  выдается  стандартное приглашение "%" для
     рядового пользователя и "#" для суперпользователя.





28

shell
   - если файл является командным, т.е. может  интерпретиро-
     ваться,  (имеется бит "x" - выполняемый) и в начале его
     стоит символ "#", то он может быть выполнен  CSH.  Если
     же  символ "#" отсутствует, то он выполняется интерпре-
     татором команд "sh" -  это соглашение  CSH.  Переменная
     shell  устанавливает,  какой именно из командных языков
     должен интерпретировать командный файл с "#" в качестве
     первого символа, чтобы не порождать ошибку при запуске.

status
   - переменная status принимает  значение  кода  завершения
     команды. Например:

                false ; echo $status
                1
                true ; echo $status
                0


     Здесь команда false возвращает 1 - код  неудачного  за-
     вершения, команда true возвращает 0 -  код удачного за-
     вершения. По команде echo  $status  выводится  значение
     переменной status.

time
   - переменная time хронометрирует команды,  если  их  дей-
     ствие  продолжалось более указанного времени. Например,
     в файле ".cshrc" выполнено назначение:

               set time = 6


     Это значит, что CSH  будет хронометрировать  выполнение
     команды  и  выводить  на  экран дисплея сведения о ней,
     когда время выполнения команды превысит 6 секунд.  Если
     теперь  выполнить  команду,  например,  sort  file , то
     после ее завершения будет выведен результат хронометри-
     рования:

              1.6u 17.9s 0:26 74%


      Здесь:


       1.6u     - время пользовательской фазы процесса;

       17.9s     - время системной фазы процесса;

       0:26     - астрономическое время процесса;

       74%      - отношение в процентах суммы  пользователь-
     ской и системной фаз процесса к астрономическому време-
     ни.

verbose
   - эта переменная устанавливается по флагу "-v" и означает
     распечатку  слов  каждой  команды с учетом подстановок.
     CSH будет  распечатывать  содержание  каждой  командной
     строки перед ее выполнением.



                                                          29

   7.2. Флаги CSH


   При запуске командных файлов на интерпретацию можно уста-
навливать различные флаги для CSH. При этом командная строка
выглядит следующим образом:

   csh -список_флагов имя_файла ...

Если имя_файла не указано, то порождается новая  интерактив-
ная оболочка.

Ниже перечислены флаги CSH и их значения:



-c   считывать команду из единственного параметра, указанно-
     го сразу после -c;



-e   CSH прекращает работу, если любая вызванная команда за-
     вершается  ненормально или если код возврата команды не
     равен 0;



-f   запретить чтение файла .cshrc для более быстрого  стар-
     та;



-i   запустить новую оболочку как интерактивную.  Этот  флаг
     устанавливается  по  умолчанию,  если  вызов  CSH  осу-
     ществляется с клавиатуры дисплея;



-n   осуществлять разбор командных строк,  но  не  выполнять
     команды.  Это режим отладки командных строк и командных
     файлов;



-s   читать ввод команды из стандартного ввода;



-t   считывать и выполнять только одну  строку.  Эта  строка
     может содержать в конце символ продолжения строки "\";


-v   после подстановок из  "history"  распечатывать  команду
     перед ее выполнением;


-V   перед разбором строк из файла позволит увидеть на экра-
     не дисплея как CSH устанавливает назначения и выполняет
     командные строки при интерпретации файла .cshrc;





30

-x   печатать на экране дисплея все команды перед выполнени-
     ем;



-X   установить флаг -x при интерпретации файла .cshrc.


   При порождении  новой  оболочки  желательно  иметь  такое
приглашение,  по которому можно судить об уровне вложенности
созданных оболочек. Например, пусть при входе в систему  вы-
водится приглашение

             ivanov_1>

Теперь, если выполнить команду CSH, то будет выдано то приг-
лашение, которое указано в файле .cshrc, например

             ivanov_1>

Если теперь повторить эту процедуру, то снова появится приг-
лашение

             ivanov_1>

К этому моменту времени порождено три оболочки. Оболочка ну-
левого уровня, которая инициализировалась при входе в систе-
му, оболочки первого и второго уровней. При этом  каждая  из
них имеет одинаковое приглашение "ivanov_1>". Ниже приводят-
ся тексты файлов .cshrc и .login,  в  которых  предусмотрена
возможность  выводить  приглашения с указанием номера уровня
вложенности порожденных оболочек. Однако,  необходимо  заме-
тить,  что  эти действия увеличивают время работы CSH в про-
цессе загрузки новых оболочек.


Файл .cshrc

        set path = (. /bin /usr/bin )
        set history = 22
        if( $?LEVEL == 0 ) then
                setenv LEVEL 0
        else
                @ a =  ( $LEVEL + 1 )
                setenv  LEVEL   $a
                unset a
        endif
        set prompt = $LEVEL'_ivanov_\!: '



Файл .login



        set ignoreeof
        set prompt = 'ivanov_\!> '







                                                          31

   Здесь "if( $?LEVEL == 0 )" проверяет, установлена ли  пе-
ременная  LEVEL в окружении. Если она не установлена, то ус-
танавливается ("setenv  LEVEL 0"). Если установлена, то  вы-
полняется  увеличение  значения переменной LEVEL на 1. Пере-
менная LEVEL затем подставляется в приглашение:


   "set prompt = $LEVEL'_ivanov_\!> ' ",


которое будет выводится следующим образом:


              1_ivanov_1>


   Здесь 1 - номер уровня вложенности. Таким  образом,  если
первый  символ  приглашения  не  цифра, то работает оболочка
инициализированная при входе пользователя  в  систему,  т.е.
оболочка нулевого уровня. Если первый символ цифра, то рабо-
тает оболочка с номером вложенности, равным этой цифре.


   7.3. Внешние переменные CSH


   Внешние переменные - это такие  переменные,  которые  ис-
пользуются пользовтелем при создании командных процедур (ко-
мандных файлов) и командных строк. В отличии  от  внутренних
переменных  CSH  и  переменных окружения, внешние переменные
имеют тот смысл, который "придается" им пользователем. В об-
щем  случае эти переменные являются строками символов, кото-
рые могут интерпретироваться CSH как  слова  или  последова-
тельности слов.

   К внешним переменным применимы подстановки имен команд  и
имен  файлов,  они могут интерпретироваться как целые числа,
над ними можно выполнять различные операции, например, срав-
нения. Внешние переменные могут выступать как операнды в вы-
ражениях и как  составные  части  этих  операндов.  Значения
внешних  переменных  могут быть установлены и отображены ко-
мандой set и отменены командой unset.

   CSH предоставляет пользователю мощный механизм  интерпре-
тации подстановок, позволяет использовать модификаторы, рас-
ширения имен и ряд метапоследовательностей, которые упрощают
для пользователя процессы формирования командных процедур.





   7.4. Окружение





   Система поддерживает некоторый массив  строк,  называемый
средой  или  окружением.  Строки окружения могут считываться
системными и пользовательскими  программами.  По  соглашению
строки  в  окружении  имеют вид "имя=значение". Имеется нес-


32

колько стандартных имен, однако их значение зависит от соот-
ветствующих  назначений командой setenv. Часть этих назначе-
ний происходит при выполнении процесса init и  интерпретации
файлов  ".login"  и ".cshrc". Пользователь имеет возможность
переустановить значения существующим переменным и установить
новые.

   Среди переменных окружения имются стандартные. Они  уста-
навливают  значения характеристик окружения, в котором рабо-
тает пользователь. Значениями стандартных характеристик  ок-
ружения пользуются все системные программы, CSH и shell. Они
доступны как константы и программам пользователя. CSH считы-
вает значения переменных окружения при порождении новых обо-
лочек. Важно отметить, что значения переменных окружения для
CSH являются внутренними константами и CSH в своих действиях
не может менять их значения. Значения  переменных  окружения
можно устанавливать и менять только командой setenv:

setenv
setеnv имя значение

Первая форма выводит значение переменных  окружения,  вторая
их  устанавливает.  Перечисленные ниже имена зарезервированы
как стандартные имена окружения:



PATH
   - префиксы  имен  стандартных  справочников,  разделенных
     символом ":";


HOME
   - регистрационный справочник пользователя,  установленный
     в файле /etc/passwd;

TERM
   - имя типа терминала;

SHELL
   - имя командного языка, который инициализируется при вхо-
     де пользователя в систему;

TERMCAP
   - список  возможностей   терминала   (смотрите   termcap,
     termlib);

MSG
   - определяет, на каком языке будут  выводиться  сообщения
     пользователю при работе с системой (MSG=r - на русском,
     MSG=l - на английском);

USER
   - регистрационное имя пользователя.


   В некоторых версиях системы CSH не  модифицирован  на   |
работу  с  русскими идентификаторами и строками символов   |
(в окружении руские символы можно устанавливать командой   |
set  командного  языка  shell). При выводе установленных   |
значений переменных окружения по команде setenv  русские   |
символы  будут  искажаться.  Чтобы этого не происходило,   |


                                                          33

значения переменных окружения, если там имеются  русские   |
символы, лучше выводить следующей командой:                |

        % sh -c set                                        |


   В файле .cshrc можно так же установить удобный  псев-   |
доним:                                                     |


   % alias env  (sh -c set)                                |


   Теперь по команде env переменные окружения будут  вы-   |
водиться без искажений русских символов.                   |


   Команда setenv позволяет определить  и  установить  новую
переменную в окружении, например:

        % setenv NAME 0
        % echo $NAME
        0
        % setenv NAME 15
        % echo $NAME
        15
        % @ a = ( $NAME + 15 )
        % echo $a
        30
        % setenv NAME "Jun Feb Mar Apr"
        % echo $NAME
        Jun Feb Mar Apr
        %


   Однако, если установлена переменная в окружении, то отме-
нить  ее уже нет возможности. Для этого необходимо выполнить
команду login "имя", другими  словами  выйти  из  системы  и
вновь войти в нее.

   Как видно из примера, команда echo позволяет читать  зна-
чения  переменных,  их  можно использовать в подстановках и,
как константы, в выражениях.





















34




                 8. ПОДСТАНОВКА ПЕРЕМЕННЫХ


   CSH  производит  подстановку  значений  переменных  после
подстановки имен команд и файлов. Если перед именем перемен-
ной указан без пробела символ "$", то CSH подставляет в этом
месте командной строки значение этой переменной. Например:

        % set a = 5
        % echo a
        a
        % echo $a
        5
        %

Действие символа "$" можно отменить, указав перед ним символ
"\". Например:

        % set a = 5
        % echo \$a
        $a
        % echo $a
        5
        %

Однако, в последовательности символов, взятой в двойные  ка-
вычки, всегда действует символ "$". Например:

        % set a = 5
        % set b = " Mike, Tom, $a."
        % echo $b
         Mike, Tom, 5.
        %
        % set b = " Mike, Tom, \$a."
        %  echo $b
         Mike, Tom, \5.
        %


   В последовательности символов, взятой в одинарные  правые
кавычки, действие символа "$" отменяется. Например:

        %
        % set a = 5
        % set b = ' Mike, Tom $a.'
        % echo $b
         Mike, Tom, $a.
        %
        % set b = ' Mike, Tom, \$a.'
        % echo $b
         Mike, Tom, \$a.
        %


   В последовательности символов, взятой в  одинарные  левые
(обратные)  кавычки, символ "$" приводит к подстановке пере-
менной. Подстановка происходит непосредственно перед  выпол-
нением команды, взятой в левые кавычки. Пример: пусть имеет-
ся командный файл f.csh:


                                                          35

        #
        set a = 1
        set b = '`echo $v`'
        set c = 3
        echo a = $a b = $b c = $c
        set v = 100
        @ b++
        echo b = $b
        @ d = ( $a + $b + $c )
        echo d = $d

В результате выполнения получим

        % f.csh
        a = 1 b = `echo $v` c = 3
        b = 101
        d = 105
        %

Здесь переменным a, b, c, v и k присваиваются различные зна-
чения,  которые  затем используются в вычислениях в строках,
помеченных символом "@". Все действия сопровождаются выводом
значений переменных.

   В строке set b = '`echo $v`' переменной  b  присваивается
строка  символов. Одиночные правые кавычки запрещают подста-
новку команде set и при выводе значения b имеем: b  =  `echo
$v`.

   В строке "@ b++" выполняется комада "echo $v"  и  ее  ре-
зультат  присваивается переменной b, после чего значение пе-
ременной b увеличивается на 1. Обратите внимание на то,  что
к  этому моменту переменная v стала определенной. Величина b
равна теперь 101 и используется далее.

   CSH допускает использование следующих  метапоследователь-
ностей:

$?переменная
${?переменная}
     подставляется 1, если переменная определена, иначе 0;

$?0
${?0}
     подставляется 1, если входной файл определен, иначе 0;

$$   подставляется десятичный номер процесса CSH;

$переменная
     подставляется значение переменной;

${переменная}
     {} выделяют переменную от других символов, идущих  сле-
     дом без разделителя; подставляется значение переменной;

$переменная[селектор]
${переменная[селектор]}
из переменной выделяется слово по
селектору и подставляется его
значение;




36

$#переменная
${#переменная}
     подставляется количество слов, хранящихся в переменной;

$0    подставляется имя файла, из которого CSH читает коман-
     ды;

$число
${число}
     эквивалентно $argv[число];

$*   эквивалентно $argv[*], то есть  это  строка  параметров
     команды, которой был запущен CSH.

   Пример. Ниже приведен пример всех вариантов использования
метапоследовательностей в командном файле f.csh.

        #
        set m = ( w1 w2 w3 w4 w5 )

        # 1 - 2   ################

        if( $?m ) then
                echo 1 $m
        else
                echo 2 0
        endif

        # 3 - 4   ################

        if( ${?m} ) then
                echo 3 $m
        else
                echo 4 0
        endif

        # 5 - 6   ################

        if( $?0 ) then
                echo 5 1
        else
                echo 6 0
        endif

        # 7 - 8   ################

        if( ${?0} ) then
                echo 7 1
        else
                echo 8 0
        endif

        # 9       ################

        echo 9  $$
        @ p = ( $$ + 10 )

        # 10      ################

        echo 10 $p
        date > ofile$$



                                                          37

        # 11      ################

        echo  "11  \c" ;ls ofile$$
        cat ofile$$
        set p = 2
        @ p++

        # 12 - 17 ################

        echo  12 p = $p
        echo  13 ${p}aaa
        echo  14 $m[1]
        echo  15 $m[5]
        echo  16 $m[2-4]
        echo  17 ${m[3]}aaa

        # 18 - 23 ################

        set p = $#m
        echo  18 $p
        echo  19 ${#m}aaa
        echo  20 $0
        echo  21 $3
        echo  22 ${3}ddd
        echo  23 $*


   После выполнения этого командного файла получим:


        % f.csh 11 22 33 44 55 66
        1 w1 w2 w3 w4 w5
        3 w1 w2 w3 w4 w5
        5 1
        7 1
        9 525
        10 535
        11  ofile525
        Вос Июл 14 22:57:20 MSK 1985
        12 p = 3
        13 3aaa
        14 w1
        15 w5
        16 w2 w3 w4
        17 w3aaa
        18 5
        19 5aaa
        20 f.csh
        21 33
        22 33ddd
        23 11 22 33 44 55 66
        %

В этом командном файле показаны 23 различных случая  исполь-
зования подстановок. Каждый случай выделен строкой коммента-
риев, которые начинаются симвлом "#" в первой позиции  стро-
ки. За символом "#" в комментариях указаны номера вариантов.

   Чтобы легче было ориентироваться в выводе, он организован
таким  образом,  что сначала выводится номер варианта, потом
результат его выполнения. Все варианты легко обьяснимы,  од-
нако,  вариант 11 требуется разьяснить отдельно. Здесь номер


38

процесса используется для создания файла с  уникальным  име-
нем.  Этот  прием часто используют когда необходимо получить
такой файл.

   Варианты 20 - 23 демонстрируют  использование  переменной
argv.  Эта  переменная  получает  свое значение из командной
строки "f.csh 11 22 33 44 55 66", которую мы ввели  при  за-
пуске командного файла.
























































                                                          39




                      9. МОДИФИКАТОРЫ


   CSH позволяет использовать модификаторы слов в  командных
файлах.  Модификаторы  изменяют  слова,  имена  переменных и
файлов. Как правило, модификаторы записываются в виде:

 модифицируемое_слово:модификатор

Ниже представлен список модификаторов:

h  - удалить имя файла, сохранив компоненты  пути  (то  есть
     удалить в слове текст справа до ближайшего символа "/";

gh
   - применить модификатор h глобально, ко всем словам;

r  - удалить расширение имени  файла,  указанное  через  "."
     справа;

gr
   - выполнить модификатор r глобально, ко всем словам;

t  - сохранить имя файла, удалив компоненты  пути  (то  есть
     текст  слева  от самого правого символа "/", и сам этот
     символ);

gt
   - применить модификатор t глобально, ко всем словам;

q  - запретить дальнейшую модификацию слова. Слово  заключа-
     ется в кавычки;

x  - разбить слова на  слова  по  разделителям  и  запретить
     дальнейшую  модификацию. Результат заключается в кавыч-
     ки.

   Модификаторы нельзя применять к следующим  метапоследова-
тельностям:

           $?переменная
           ${?переменная}
           $?0
           $$


   Для  каждой  метапоследовательности  можно   использовать
только один модификатор.

   Перед модификатором должен стоять символ ":".

   Если в метапоследовательности используются символы  "{}",
модификатор должен находиться внутри фигурных скобок.

   Пример: пусть имеется командный файл f.csh:






40

#
set a = /usr/bin/pr1
set b = /dir1/dir11/dir111/file.c
set c = ( /d/d1/d2/f.c /d/d1/c.c /d5/f.s )

# 1     ############
echo 1
echo $a:h
echo $b:h
echo $c[1]:h
echo ${c[2]:h}
echo $c[3]:h

# 2     ############
echo 2
echo $a:t
echo $b:t
echo $c[1]:t
echo ${c[2]:t}
echo $c[3]:t

# 3     ############
echo 3
echo $a:r
echo $b:r
echo $c[1]:r
echo ${c[2]:r}
echo $c[3]:r

# 4     ############
echo 4
echo $c:gh
echo $c:gt
echo $c:gr


# 5     ############
echo 5
set m = "$c:x"
echo $m
echo $m[1]:t
echo $m[1]:r

# 6     ############
echo 6
set m = "$c:q"
echo $m
echo $m[1]:h
echo $m[1]:r


   Тогда получим:

% f.csh
1
/usr/bin
/dir1/dir11/dir111
/d/d1/d2
/d/d1
/d5
2
pr1


                                                          41

file.c
f.c
c.c
f.s
3
/usr/bin/pr1
/dir1/dir11/dir111/file
/d/d1/d2/f
/d/d1/c
/d5/f
4
/d/d1/d2 /d/d1 /d5
f.c c.c f.s
/d/d1/d2/f /d/d1/c /d5/f
5
/d/d1/d2/f.c /d/d1/c.c /d5/f.s
f.s
/d/d1/d2/f.c /d/d1/c.c /d5/f
6
/d/d1/d2/f.c /d/d1/c.c /d5/f.s
/d/d1/d2/f.c /d/d1/c.c /d5
/d/d1/d2/f.c /d/d1/c.c /d5/f



   В командном файле демонстрируется использование модифика-
торов.  Вывод  данных организован таким образом, чтобы можно
было отличить действия каждого варианта использования  моди-
фикаторов.  Варианты  1-4  самооб'яснимы. Варианты 5 и 6 де-
монстрируют действия модификаторов x и q  .  Переменная  "c"
содержит  список  слов. Этот список присваивается переменной
"m", и к нему поочередно применяются модификаторы x и q.  Из
примера  видно,  что этот список превращается в одно слово и
модификаторы h, t и r  работают с этим списком как  с  одним
словом.





























42




                 10. РАСШИРЕНИЕ ИМЕН ФАЙЛОВ


   Если слово содержит один  из символов "*", "?", "[", "]",
"{",  "}"  или  начинается  с символа "~", то оно становится
кандидатом на подстановку имени файла.

   При этом данное слово рассматривается  как шаблон,  кото-
рый  заменяется отсортированным в алфавитном порядке списком
имен файлов, которые соответствуют шаблону. Если ни для  од-
ного возможного варианта подстановки имени по шаблону не на-
ходится ни одного файла, то  порождается  состояние  ошибки.
Ниже  раскрыты  метазначения  символов  в  подстановках имен
файлов:

*  - соответствует любой последовательности  символов.  При-
     мер:

        % more *

     Будут показаны все файлы справочника.

        % ls /*/*/f*

     От корневого  справочника  будут  просмотрены  входящие
     справочники  и выведен список всех  файлов, имена кото-
     рых начинаются на "f". Если среди них встретятся  спра-
     вочники с именем "f*", то будет выведено их содержимое.

?  - соответствует одному любому символу. Пример:

        % ls f.?
        f.c
        f.o
        f.s
        %

     Будут выведены имена всех файлов справочника, которые в
     качестве корневой части имени имеют символ "f", а в ка-
     честве расширения имени - один любой символ.

[последовательность_символов]
   - соответствует любому символу  указанной  последователь-
     ности. Пример:

        ls f.[cso]
        f.c
        f.o
        f.s
        %


[символ-символ]
   - соответствует любому символу из лексикографически  упо-
     рядоченного диапазона. Пример:






                                                          43

        ls f.[A-z]
        f.c
        f.o
        f.s
        %

Выводятся все файлы, расширение имени которых - любая  буква
латинского алфавита.

~  - регистрационный справочник. Пример:

        % ls ~

     Будет выведено содержимое справочника, в который вы по-
     падаете  при входе  в систему. Такой справочник принято
     называть регистрационным. Содержимое этого  справочника
     будет  выводиться,  где  бы вы в этот момент не находи-
     лись.

        % ls ~/dir1/dir2

     Будет выведено содержимое подсправочника dir2, входяще-
     го в ваш регистрационный справочник.

~имя
   - регистрационный справочник пользователя имя. Пример:

        % ls ~ivanov


     Будет выведено содержимое регистрационного  справочника
     пользователя с именем ivanov.

        % ls ~ivanov/dir1


     Будет выведено содержимое справочника dir1, входящего в
     регистрационный   справочник   пользователя   с  именем
     ivanov.

        % ls ~ivanov/*/*/file


     Во всех справочниках  третьего  уровня  пользователя  с
     именем  ivanov  будут найдены и выведены файлы с именем
     file. Если будет обнаружен справочник с  таким  именем,
     то выводится его содержимое.

[список_символов_через_запятую]
   - соответствует любому  из  перечисленных  символов.  Для
     указания  самих  символов "[" и "]" в списке перед ними
     должен ставиться символ "\". Пример:

        ls f.[c,s,o]
        f.c
        f.o
        f.s
        %






44

слово1{список_слов_через_запятую}слово2
   - к слово1 добавляется первое  слово  из  список_слов_че-
     рез_запятую и добавляется слово2. Далее повторяется для
     второго слова из список_слов_через_запятую и так далее.
     Не допускаются пробелы. Пример:

        % ls aaa{ddd,ccc,bbb}eee
        aaadddeee не найден
        aaaccceee не найден
        aaabbbeee не найден
        %

     При поиске файлов формировались их  имена  комбинациями
     указанных  последовательностей.  Сообщение  "не найден"
     выводится, когда такой файл командой ls не обнаружен.

   При создании шаблона имени файла  особое  место  занимают
символы  "."  и  "/".  Если  имя  файла имеет вид "/имя" или
"/.имя" , то эти символы должны быть указаны явно и точно на
своих местах.












































                                                          45




                  11. ВЫРАЖЕНИЯ. КОМАНДА @


   CSH позволяет вычислять выражения. Выражения  вычисляются
при определении переменных по команде "set", кроме того, су-
ществует специальная команда "@" для  вычисления  выражений.
Команда "@" означает, что все указанные далее слова являются
операндами или частью операндов, над которыми необходимо вы-
полнить  действия  -  операции.  На  тип  операции указывает
символ операции, он же служит разделителем слов. Например:

        % set a = 5
        % set b = 7
        % @ c = ( $a + $b )
        % echo $c
        12
        %


   В языке CSH числом считается любая символьная строка, ко-
торая  может  интерпретироваться как десятичное число. В ка-
честве  логическизх  значений  используются  число  "0"  для
"ложь"  и 1 для "истина" (при проверках как "истина" воспри-
нимается любое число, отличное от нуля).

   Операции в CSH в основном аналогичны  операциям  в  языке
Си.  Кроме того, выражения можно использовать также в опера-
торах if_then_else, while, exit. Команда @ также допускает в
качестве  простого операнда команду системы, взятую в фигур-
ные скобки.


   11.1. Операции


   В CSH имеются следующие операции:

Операции сравнения.

                      ==   равно?
                      !=   не равно?


В качестве операндов в этих операциях используются строки:

Операции над числами:

операнд_целое_число:
        (два операнда)
                     ||   или
                     &&   и
                     <=   меньше или равно?
                     >=   больше или равно?
                      >   больше?
                      <   меньше?
                      +   сложить
                      -   вычесть
                      *   умножить
                      /   делить


46

                      %   остаток деления


        (один операнд):
                     ++    инкремент,
                          (постфиксная)
                     --    декремент,
                           (постфиксная)

поразрядные_логические

                      &       умножение
                      |       сложение
                      ~       или
                      ^       дополнение
                              (унарная)
                      !       отрицание
                              (унарная)
                     >>      сдвиг вправо
                     <<      сдвиг влево


   Имеются операции опроса свойств файла. Они записываются в
виде:

        -код имя_файла

где код - одна из следующих букв, обозначающих операцию:

     r (можно ли читать?)
     w (можно ли писать?)
     x (можно ли выполнять?)
     е (файл существует?)
     o (выполняющий CSH - владелец файла?)
     z (размер файла = 0 ?)
     f (файл зашифрован?)
     d (файл - это справочник?)


   Указанное имя файла подвергается расширению переменных  и
имен  файлов,  а  затем  проверяется  опрашиваемое  свойство
файла. Если файл обладает требуемым свойством, то  возвраща-
ется значение 1 - "истина", иначе 0 - "ложь".


   11.2. Форматы команды @


@  - распечатать значения всех переменных;

@ имя = выражениe
   - присвоение переменной имя значения выражения;

@ имя[целое] = выражениe
   - присвоение значения выражения компоненте переменой имя.









                                                          47

   11.3. Операции присваивания


   Операции присваивания аналогичны подобным операциям языка
Си:

                     =
                    +=
                    -=
                    *=
                    /=
                    %=



   11.4. Порядок и старшинство операций


   Порядок выполнения операций определяется  либо по умолча-
нию, с учетом старшинства, либо явным указанием круглых ско-
бок.

   В показанном  ниже  ряду  операций  старшинство  операций
растет слева направо:

        ||, &&, | , ^ , & , ==, !=, <=,

        >=, < , > , <<, >>, + , - , * ,

        / , % , ! , ~ , ( )


   Внутри указанных ниже  групп  операции  имеют  одинаковый
приоритет:

                ==, !=

                <=, >=, < , >

                <<, >>

                +, -

                *, /, %



   11.5. Синтаксис выражений


   Все знаки операций должны отделяться от операндов  пробе-
лами. В одном слове не должны встречаться две компоненты вы-
ражений, за исключением случаев использования следующих зна-
ков операций:

        &, |, <, >, "( )"


   Таким образом, части выражений, содержащие все  остальные
знаки   операций,  необходимо  брать в круглые скобки. Перед
круглыми скобками и за ними должен идти пробел.



48

   Знак присваивания также должен  быть  окружен  пробелами.
Количество пробелов, знаков табуляции не ограничивается, эти
символы являются только разделителями.


   11.6. Примеры вычислений в CSH


   Пример организован таким образом, чтобы перед выводом ре-
зультатов  выводился  номер  раздела командного файла. Пусть
имеется командный файл f.csh:

#
# 1     ##########
echo '>> 1'
set a = 5
@ a++
echo $a
# 2     ##########
echo '>> 2'
@ a = 7
echo $a
# 3     ##########
echo '>> 3'
set a = 10
set b = 15
@ c = ( $a + $b )
echo $c
# 4     ##########
echo '>> 4'
@ c += 5
echo $c
# 5     ##########
echo '>> 5'
@ c = ( $c * 5 )
echo $c
# 6     ##########
echo '>> 6'
@ c *= 5
echo $c
# 7     ##########
echo '>> 7'
@ c *= $c
echo $c
# 8     ##########
echo '>> 8'
@ a = 5
@ b = 7
@ c = 9
echo $a $b $c
@ a = ( $a << 2 )
@ b = ( $b >> 2 )
@ c = ( $c + $a + $b )
echo $a $b $c
# 9     ##########
echo '>> 9'
set a = 5
set b = 3
@ c = ( $a | $b )
echo $c
# 10    ##########
echo '>> 10'


                                                          49

set a = 5 b = 3 c = 2
echo $a $b $c
@ d = ( ( $a + $b ) + ( $a + $b + $c ) )
echo $d
# 11    ##########
echo '>> 11'
set a = 5
if( $a == "5" ) echo "o'key"
if( $a != "5" ) echo "sorry"
# 12    ##########
echo '>> 12'
date > file
chmod 555 file
if( -x file ) echo 'execut'
ls -l file
rm -f file


   После его выполнения получим:

>> 1
6
>> 2
7
>> 3
25
>> 4
30
>> 5
150
>> 6
750
>> 7
-27324
>> 8
5 7 9
20 1 30
>> 9
7
>> 10
5 3 2
18
>> 11
o'key
>> 12
execut
-r-xr-xr-x 1 ivanov  29 Июл 15 17:50 file


   Варианты 1 - 6 самооб'яснимы. В варианте 7 получилось от-
рицательное  число,  так  как  CSH  работает  с  целыми типа
integer.












50




             12. УПРАВЛЕНИЕ ВЫПОЛНЕНИЕМ КОМАНД


   CSH  позволяет  вводить  управляющие   команды   foreach,
switch, while, if_then_else.

   В интерактивном режиме в процессе  ввода  CSH  приглашает
символом  "?"  продолжать  набор,  пока не встретит ключевое
слово,  означающее  конец  ввода.  Введенный   текст   можно
рассматривать  как  временный  командный  файл,  который ин-
терпретируется и, после выполнения, уничтожается.

   В операторах управления CSH ключевые слова  (if,  else  и
др.) должны быть первым словом в строке.


   12.1. Оператор цикла foreach


foreach имя (список слов)
        ...
  последовательность команд
        ...
end


   Переменной "имя" последовательно  присваиваются  значения
каждого члена "списка слов" и выполняется последовательность
команд между данной командой и соответствующей командой end.
(Как  foreach, так и end должны находиться в отдельных стро-
ках). Например:

        % foreach i = ( a b c d e f g h )
        ?        if( $i == "c" ) continue
        ?        echo $i
        ?        if( $i == "f" ) break
        ? end

        , тогда мы получим:

        a
        b
        d
        e
        f
        %

Здесь выполняется цикл. Переменная цикла  i  последовательно
принимает  значения  из  списка,  обьявленного в предложении
foreach. Внутри цикла стоят две проверки.  Если  значение  i
равно "c", то перейти к следующему шагу цикла, а если значе-
ние i равно "f", то прекратить выполнение  цикла.  В  первом
случае  оператор  continue требует перехода к новой итерации
цикла, во втором оператор break осуществляет выход за преде-
лы цикла и его действие прекращается.






                                                          51

   12.2. Оператор switch


   Оператор выбора "switch" имеет вид:

switch(строка)
        case стр1:
                ...
                breaksw
        ...
        ...
        ...
        default:
                ...
                breaksw
endsw


   "Строки" вариантов case  последовательно  сравниваются  с
указанной  в  "switch" строкой, которая сначала подвергается
расширению имен команд и имен файлов. В "строках"  вариантов
case могут использоваться метасимволы имен файлов "*", "?" и
"[...]".  Если  перед  обнаружением  "default"  ни  одна  из
"строк"  в  "case" не совпала, выполнение продолжается после
"default". Слова "case" и "default" должны  быть  первыми  в
строке. Команда breaksw приводит к тому, что выполнение про-
должается после endsw. Если ни одна из меток не совпадает  и
"default" отсутствует, выполнение продолжается после endsw.


        Пример:

        % set j = 0
        % foreach i ( aaa bbb ccc ddd eee )
        ?       @ j++
        ?       switch( $i )
        ?               case "aaa":
        ?                       echo $i
        ?                       breaksw
        ?               case "bbb":
        ?                       echo $i
        ?                       breaksw
        ?               case "ccc":
        ?                       echo $i
        ?                       breaksw
        ?               case "ddd":
        ?                       echo $i
        ?                       breaksw
        ?               default:
        ?                       breaksw
        ?
        ?       endsw
        ?       echo $j
        ?end
        aaa
        1
        bbb
        2
        ccc
        3
        ddd
        4


52

        5
        %

Здесь foreach образует цикл. Переменной цикла i присваивают-
ся  значения  из  списка в предложении foreach. Внутри цикла
работает переключатель switch. После каждого найденного  ва-
рианта,  указанного  в  case, команда echo выводит найденное
значение. Если ни одно значение вариантов case не совпадает,
то выполняется вариант default. В данном случае это приводит
к выходу за пределы переключателя switch, выводится порядко-
вый  номер итерации цикла и foreach выполняет следующую ите-
рацию. В новой итерации  цикла  снова  начинает  действовать
switch.






   12.3. Оператор if


   Следующая конструкция используется для условного выполне-
ния команд CSH:

   if(выр) then
   ...
   else if(выр2) then
   ...
   else
   ...
   endif

Если значение заданного выражения "выр" истина (то есть  от-
лично  от нуля), выполняются команды до первого else. Иначе,
если значение "выр2" истина, выполняются команды до  второго
else,  и  т.д.  Возможно любое количество пар else-if; endif
нужно только одно. Часть else является необязательной. Слова
else и endif должны быть первыми в строках, где они указаны.
If должен находиться один во входной строке или после else.


        Пример:

        %
        % foreach i ( a b c d e f )
        ?        if( $i == "a" ) then
        ?                echo a
        ?        else if( $i == "b" ) then
        ?                echo b
        ?        else if( $i == "c" ) then
        ?                echo c
        ?        endif
        ? end
        a
        b
        c
        %


На каждой итерации цикла foreach осуществляется проверка те-
кущего  значения  переменной  цикла i с символами "a", "b" и


                                                          53

"c". Если логическое условие проверки выполняется, то на эк-
ран  выводится  соответствующий символ, иначе осуществляется
следующая итерация цикла.


   12.4. Оператор цикла while


   Оператор цикла "while" имеет вид:

while(выражение)
        ...
        ...
        ...
end

Цикл выполняется, пока истинно значение "выражения".  Ключе-
вые  слова  "while"  и  "end" должны находиться на отдельных
строках. В теле цикла можно использовать команду "break" для
выхода  из цикла и команду "continue" для возобновления сле-
дующей итерации цикла без завершения текущей ( все операторы
цикла, следующие за командой "continue", не будут выполнять-
ся в данной итерации).

        Пример:

        % set argv = ( 1 2 3 1 2 3 0 1 )
        % echo "     \c"
        % while( $#argv > 0 )
        ?        if( $argv[1] == "3" ) then
        ?                shift
        ?                continue
        ?        endif
        ?        if( $argv[1] == "0" ) then
        ?                break
        ?        endif
        ?        echo " $argv[1]\c"
        ?        shift
        ? end
                1 2 1 2
        %

Здесь выполняется цикл, в котором выводятся  значения  argv.
Если слово есть символ "3", то оно не выводится и идет пере-
ход к следующей итераци цикла, если  слово  символ  "0",  то
действие цикла прекращается.


















54




                    13. КОМАНДНЫЕ ФАЙЛЫ


   CSH позволяет создавать командные  файлы.  Каждая  строка
командного  файла интерпретируется CSH, в ней осуществляются
подстановки имен команд и файлов, вычисляются, если  необхо-
димо, выражения.

   Командный файл  CSH  может  вызывать  другие  выполняемые
файлы,  в том числе командные файлы, написанные как для CSH,
так и для SH. Кроме того, в командном файле доступна для вы-
полнения любая команда системы.

   Каждый командный файл CSH должен начинаться символом  "#"
в  первой  позиции первой строки. Допускаются пустые строки.
Строка, начинающаяся "#", является строкой комментариев. CSH
не работает с символами кириллицы, поэтому при использовании
их в строках  комментариев  командный  файл  выполняться  не
будет!

   При  создании  командных  файлов,  используя   переменную
argv,  можно  организовать  ввод  и обработку аргументов ко-
мандной строки, которые могут быть как именами файлов, так и
любыми последовательностями символов.

   Команда системы rline позволяет  организовать  диалоговые
процедуры, например: пусть имеется командный файл f.csh:


#
loop:
    echo '> \c'
    set m = `rline`
    if( $m == "y" || $m == "Y" ) then
           echo Yes!
    else
            echo No!
    endif

goto loop


   Здесь на ответы типа "y" или "Y" будет выводиться "Yes!".
Во всех остальных случаях ответ будет "No!". Убить эту прог-
рамму можно по CNTRL/C (СУ/C).
















                                                          55




                 14. ВСТРОЕННЫЕ КОМАНДЫ CSH


   Встроенные команды позволяют выполнять ряд  действий  над
внутренними  и  внешними переменными CSH. Важно помнить, что
имена встроенных команд являются зарезервированными  словами
CSH,  поэтому  не рекомендуется присваивать пользовательским
программам имена, совпадающие с именами встроенных команд.

   Ниже перечислены имена встроенных команд CSH, их  синтак-
сис и действия.

alias
alias имя
alias имя список-слов
    Команда alias позволяет устанавливать псевдонимы  команд
    и  командных  строк.  При  обращении  к командам или ко-
    мандным строкам, для которых  выполнена  команда  alias,
    можно использовать их псевдонимы.

       Первая форма распечатывает все псевдонимы, например:

                a       alias
                l       (/bin/ls -l)
                alg     (/bin/ls -alg)
                all     (/bin/ls -al)
                c       /bin/cat
                h       history
                bye     exit

       Вторая форма распечатывает псевдоним  для  указанного
    имени, если он установлен, например:

                alias l
                /bin/ls -l

       Третья форма устанавливает  псевдоним  для  заданного
    списка слов, например:

               alias  l /bin/ls -l

       "Список-слов" подвергается подстановке команд и  имен
    файлов.  В  качестве  имен  не  могут  служить "alias" и
    "unalias".

alloc
    Показывает  размер  используемой  динамической   памяти,
    включая  используемую  и свободную память, а также адрес
    последней ячейки памяти.

break
    Вызывает выход  за  end  ближайшей  внешней  конструкции
    foreach  или  while.  Например,  пусть имеется командный
    файл f.csh:







56

        #
        set m = ( Jan Feb Mar Apr May Jun )
        while( $#m > 0 )
                shift m
                if( $m[1] == "May" ) break
                echo $m
        end

    После выполнения на экране дисплея получим:

        % f.csh
        Feb Mar Apr May Jun
        Mar Apr May Jun
        Apr May Jun
        %

    Можно выполнять переходы через  несколько  уровней  пос-
    редством написания нескольких команд break в одной стро-
    ке, разделяя их символом ";".

breaksw
    Вызывает выход из команды switch  за  пределы  оператора
    endsw;

case метка:
    "метка"  -  один из вариантов  переключателя  switch.  В
    метках  могут использоваться метасимволы расширения имен
    файлов ("*", "?", "[...]"). Двоеточие обязательно!

cd
cd имя
chdir
chdir имя
    Заменяет рабочий справочник на  справочник  "имя".  Если
    параметр  отсутствует,  осуществляется  переход  к  "ре-
    гистрационному" справочнику пользователя.

continue
    Продолжает  выполнение  ближайшего  внешнего  while  или
    foreach. При этом все строки цикла до end пропускаются и
    начинается новая итерация цикла. Остальные команды теку-
    щей строки выполняются.

default:
    Служебное слово предложения switch. Если после всех про-
    верок  не  нашлось  варианта,  совпавшего  с вариантом в
    case, то выполняется то, что указано в варианте default.
    Ключевое  слово  default должно располагаться после всех
    case. Двоеточие обязательно!

echo список-слов
    Указанные слова записываются в стандартный вывод. Символ
    "\c"  запрещает  перевод  на  новую строку после вывода.
    Например:

        % set m = ( 0 1 2 3 4 5 6 7 8 9 )
        % echo $m
        0 1 2 3 4 5 6 7 8 9
        % echo "$m\c"
        0 1 2 3 4 5 6 7 8 9%
        % echo $m"\c"
        0 1 2 3 4 5 6 7 8 9%


                                                          57


    Здесь команда  set  присваивает  переменной  m  значение
    "0123456789".  Команда  "echo  $m"  выводит значение m и
    приглашение "%" выводится на новой строке. Команда "echo
    $m\c"  выводит  значение  m и в этой же строке выводится
    приглашение "%". Команда echo $m"\c" аналогична предыду-
    щей.  Команда  echo  позволяет также использовать символ
    новой строки, например:

        % echo a b c"\n"d e f
        a b c
        d e f
        %

       Команда echo позволяет использовать символ  продолже-
    ния строки. Смотрите пример в описании case.

else
end
endif
endsw
    см. ниже  описание  операторов  foreach,  if,  switch  и
    while.

exec команда
    Команда запускается вместо  CSH. Работа CSH заканчивает-
    ся.

exit
exit(выр)
    Производится выход из CSH либо со  значением  переменной
    status  (первая форма), либо со значением указанного вы-
    ражения "выр" (вторая форма).

foreach имя (список слов)
end
    Переменной "имя" последовательно присваиваются  значения
    каждого члена "списка слов" и выполняется последователь-
    ность команд между данной командой и соответствующей ко-
    мандой  end. (Как foreach, так и end должны находиться в
    отдельных строках). Например,  пусть  имеется  командный
    файл f.csh

        #
        foreach i = ( a b c d e f g h )
                if( $i == "c" ) continue
                echo $i
                if( $i == "f" ) break
        end


    , тогда мы получим:


        % f.csh
        a
        b
        d
        e
        f
        %



58


    Здесь выполняется цикл. Переменная  цикла  i  последова-
    тельно  принимает  значения  из  списка,  об'явленного в
    предложении foreach. Внутри цикла  стоят  две  проверки.
    Если  значение i равно "c", то перейти к следующему шагу
    цикла, а если значение i равно "f", то прекратить выпол-
    нение цикла. В первом случае оператор continue выполняет
    переход к новой итерации цикла, во втором оператор break
    осуществляет  выход за пределы цикла, и цикл прекращает-
    ся.

glob список-слов
    Эта команда аналогична команде echo, однако, слова выво-
    дятся  без  пробела и после последнего слова без пробела
    идет приглашение. Такой вывод полезен при манипулиции  с
    именами  файлов, когда эти имена необходимо удлинять или
    создавать новые файлы. Пример:


        #
        mkdir dir
        foreach i ( a b c d e f )
        cat /dev/null > ./dir/$i`glob .$i`
        end

    В этом командном файле выполняется цикл, на каждой  ите-
    рации  которого  создается  новый пустой файл. Имя файла
    формируется  переменной  цикла  i.  Значение  переменной
    цикла  i используется дважды. В первом случае подставля-
    ется значение i для  формирования  главной  части  имени
    файла,  во  втором  для  расширения имени файла, которое
    формируется командой "`glob .$i`". Левые кавычки  служат
    указанием  CSH для подстановки результата выполнения ко-
    манды "glob .$i"  в  слово  "./dir/$i(результат  команды
    glob)". После выполнения этого командного файла получим:

        % ls dir
        a.a
        b.b
        c.c
        d.d
        e.e
        f.f
        %
    Команда glob не  интерпретирует  символы  "\c",  "\n"  и
    символ продолжения строки "\".

goto слово
    Команда безусловного перехода на метку. Выполнение  про-
    должается со строки, идущей после указанной метки. Метка
    должна завершаться символом ":". Слово  в  команде  goto
    может   быть  строкой,  содержащей  команды,  псевдонимы
    команд и расширения имен файлов.  В  этом  случае  метка
    формируется  как  результат  интерпретации  и выполнения
    этой строки.

hashstat
    Распечатывает строку статистики, определяющую, насколько
    эффективно  внутренняя таблица хеширования размещает ко-
    манды. Данная командa является отладочной и  отсутствует
    в  поставляемых версиях CSH, однако, в текстах программы
    CSH она имеется и помечена как комментарий.


                                                          59


history
    Отображает список предшествующих команд.

if(выр) команда
    Если выражение истинно, то выполняется команда.  Команда
    должна  быть  одна. Не допускается применение последова-
    тельности команд и/или конвейера. CSH  вычисляет  истин-
    ность  выражения  после подстановок как в команде, так и
    выражении.

if(выр) then
else if(выр2) then
else
endif
    Если значение заданного выражения "выр" истинно,  выпол-
    няются  команды  до  первого  else. Иначе, если значение
    "выр2" истинно, выполняются команды до второго  else,  и
    т.д.  Возможно любое количество пар else-if; endif нужно
    только одно. Часть else является  необязательной.  Слова
    else и endif должны быть первыми в строках, где они ука-
    заны. If должно находиться одно во  входной  строке  или
    после else. Пример: пусть имеется командный файл f.csh

        #
        foreach i ( a b c d e f )
                if( $i == "a" ) then
                        echo a
                else if( $i == "b" ) then
                        echo b
                else if( $i == "c" ) then
                        echo c
                endif
        end

    В этом командном файле на каждой итерации цикла  foreach
    осуществляется  проверка  текущего  значения  переменной
    цикла i с символами "a", "b" и "c". Если логическое  ус-
    ловие  проверки выполняется, то на экран выводится соот-
    ветствующий символ, иначе осуществляется следующая  ите-
    рация  цикла.  В  результате выполнения этого командного
    файла на экран дисплея будет выведено:

        % f.csh
        a
        b
        c
        %


login
login имя
    По команде login завершается работа CSH и  инициализиру-
    ется  программа  init для данного дисплея. Команду login
    можно выполнять без аргумента "имя" и с ним.  Во  втором
    случае  сразу же будет запрошен входной пароль пользова-
    теля.

logout
    Если  установлена  переменная  ignoreeof,то  стандартный
    сигнал  конца  файла (CNTRL/D или СУ/D), по которому CSH
    завершает работу, игнорируется. Команда logout указывает


60

    CSH  о  необходимости  прекратить работу. Перед этим CSH
    читает файл "~/.logout", если он  имеется,  и  выполняет
    все указанные в нем действия. Фоновые процессы пользова-
    теля продолжают выполняться и после logout, , если поль-
    зователь не предусмотрит прекращение их работы.

nice
nice + число
nice - число
nice команда
nice + число команда
nice - число команда
    Первая форма  устанавливает  приоритет  (nice)  для  CSH
    равным  4.  Вторая  форма устанавливает приоритет равным
    указанному числу. Последние формы  выполняют  команду  с
    приоритетом   4   и   "число"   соответственно.   Супер-
    пользователь может  установить  отрицательный  приоритет
    путем использования "nice -число". Команда всегда выпол-
    няется в под-оболочке. Команда должна  быть  одна  и  не
    может быть последовательностью команд или конвейером.

nohup
nohup команда

    Команда  nohup  запрещает  реакцию  на  сигналы  CNTRL/C
    (СУ/C),  CNTRL/\  (СУ/\)  и BREAK (отключение удаленного
    терминала или компьютера по коммутируемой линии).

       Первая форма в  командном  файле  устанавливает  свое
    действие на все строки командного файла, указанные ниже.

       Вторая форма приводит к тому, что при выполнении ука-
    занной команды зависания игнорируются.

       Команда nohup не оказывает никакого влияния, если CSH
    не работает отдельно как под-оболочка.

       Для всех процессов, отделенных с помощью  "&",  nohup
    выполняется автоматически.

onintr
onintr -
onintr метка
    Управляет реакцией оболочки на прерывания. Первая  форма
    восстанавливает стандартную реакцию оболочки на прерыва-
    ния, которая заключается в завершении  командных  файлов
    оболочки  или  возврате  на  уровень  ввода терминальных
    команд. Вторая форма "onintr -"  вызывает  игнорирование
    всех  прерываний.  Последняя  форма  вызывает выполнение
    оболочкой команды перехода на метку "goto метка" при по-
    лучении  прерывания или при завершении порожденного про-
    цесса из-за прерывания. В любом случае, если CSH работа-
    ет отдельно и прерывания игнорируются, все формы команды
    onintr не имеют никакого значения, и прерывания  продол-
    жают  игнорироваться оболочкой и всеми вызванными коман-
    дами.

rehash
    CSH создает хеш-таблицу команд, имеющихся  в  справочни-
    ках, указанных в path. Это происходит при входе в систе-
    му и всякий раз, как порождается оболочка нового уровня.
    Когда в процессе работы в любом из этих справочников за-


                                                          61

    водится новая команда, сведения о  ней  не  поступают  в
    хеш-таблицу  и  CSH  не  находит команду при ее запуске.
    Чтобы сделать новую команду известной для CSH, необходи-
    мо перестроить хеш-таблицу. Команда rehash обязывает CSH
    сделать это.

repeat счетчик команда
    Команда repeat позволяет  повторить  выполнение  команды
    "счетчик"  раз.  Если  "счетчик" равен 0, команда выпол-
    няться не будет. Если "счетчик" не  указан  генерируется
    состояние  ошибки.  Команда  должна  быть  одна,  она не
    должна быть последовательностью команд  или  конвейером.
    Например:

        % set a = ( a b c d e f )
        % repeat 5 echo $a > file
        %

    Здесь в первой строке  назначается  значение  переменной
    "a". Во второй строке назначается пятикратное выполнение
    команды echo. При этом пятикратный  вывод  этой  команды
    будет весь размещен в file. Таким образом, file открыва-
    ется при запуске команды repeat и остается открытым  для
    записи пятикратного вывода команды echo. File закрывает-
    ся по завершению работы команды repeat. Теперь получим:

        % cat file
        a b c d e f
        a b c d e f
        a b c d e f
        a b c d e f
        a b c d e f
        %


set
set имя
set имя = слово
set имя[индекс] = слово
set имя = (список слов)
    Первая форма команды set отображает значения всех  пере-
    менных  интерпретатора команд. Переменные, которые в ка-
    честве своих значений имеют не одно слово,  отображаются
    как заключенный в скобки список слов. Вторая форма прис-
    ваивает указанному "имени" пустую строку.  Третья  форма
    присваивает  "имени"  отдельное "слово". Четвертая форма
    присваивает имени с  номером  "индекс"  значение  слова.
    Последняя  форма  присваивает  "имени" "список слов". Во
    всех случаях происходят расширения псевдонимов команд  и
    имен  файлов. Для присвоения нескольких значений в одной
    команде set параметры могут повторяться. Расширение  пе-
    ременных для всех параметров происходит перед выполнени-
    ем присваиваний. Примеры:

        % set  a
        % echo $a
        %
        % set a = DEMOS
        % echo $a
        DEMOS
        %
        % set a = ( a b c d e )


62

        % echo $a
        a b c d e
        % set a[1] = BSD4.2
        % set a[2] = DEMOS
        % set a[3] = INMOS
        % set a[4] = MNOS
        % set a[5] = UNIX
        % echo $a
        BSD4.2 DEMOS INMOS MNOS UNIX
        % echo $a[4]
        MNOS
        % echo $a[2-4]
        DEMOS INMOS MNOS
        %
        % set a = b c = d e = f
        % echo $a $c $e
        b d f
        % set a = ( a b ) c = ( d e )
        % echo $a $c
        a b d e
        % set k = ( a b $a $c )
        % echo $k
        a b a b d e
        %

    Подстановка  переменных  происходит   перед  выполнением
    присваиваний.  Перед  операциями  над элементами массива
    его необходимо полностью определить.  Не  обрабатываются
    массивы  с  переменными  или  неопределенными границами.
    Команда set позволяет переопределять  переменные,  уста-
    новленные при интерпретации файла .cshrc, поэтому не ре-
    комендуется без особой необходимости использовать  имена
    этих переменных.

setenv
setеnv имя значение
    Первая форма выводит значение переменных окружения, вто-
    рая их устанавливает.

       Система поддерживает некоторый массив строк,  называ-
    емый  средой или окружением. Строки окружения могут счи-
    тываться системными и пользовательскими программами.  По
    соглашению  строки в окружении имеют вид "имя=значение".
    Имеется несколько стандартных имен, однако  их  значение
    зависит  от  соответствующих назначений командой setenv.
    Часть этих назначений происходит при выполнении процесса
    init и интерпретации файлов ".login" и ".cshrc". Пользо-
    ватель имеет возможность переустановить  новые  значения
    существующим  переменным и установить новые переменные и
    их значения. Перечисленные  ниже  имена  зарезервированы
    как стандартные имена окружения:

   PATH   префиксы имен стандартных справочников,  разделен-
          ных символом ":".

   HOME   домашний справочник пользователя, установленный  в
          файле /etc/passwd

   TERM   имя типа терминала





                                                          63

   SHELL  имя командного языка, который инициализируется при
          входе пользователя в систему

   TERMCAP
          список возможностей терминалов ( смотрите termcap,
          termlib )

   MSG    определяет, на каком языке будут выводиться  сооб-
          щения  пользователю при входе в систему(MSG=r - на
          русском, MSG=l - на английском)
    Команда setenv позволяет определить и  установить  новую
    переменную в окружении, например:

        % setenv NAME 0
        % echo $NAME
        0
        % setenv NAME 15
        % echo $NAME
        15
        % @ a = ( $NAME + 15 )
        % echo $a
        30
        % setenv NAME "Jun Feb Mar Apr"
        % echo $NAME
        Jun Feb Mar Apr
        %

       Однако, если установлена переменная в  окружении,  то
    отменить  ее  уже  нет возможности. Для этого необходимо
    выполнить команду login "имя", другими словами выйти  из
    системы и вновь войти в нее.

       Как видно из примера, команда echo  позволяет  читать
    значенияпеременных, их можно использовать в подстановках
    и, как константы, в выражениях.

shift
shift переменная
    Команда shift осуществляет левый сдвиг списка слов пере-
    менной.  Левый  элемент  списка  исчезает.  Попытка осу-
    ществить shift для пустого списка приводит  к  состоянию
    ошибки. Пример: пусть имеется командный файл f.csh:

        #
        set a = ( a b c d e f )
        while( $#a > 0  )
                echo $a
                shift a
        end

    , тогда получим:

        % f.csh
        a b c d e f
        b c d e f
        c d e f
        d e f
        e f
        f
        %

    Здесь после установки массива "a", содержащего слова  "a


64

    b  c  d e f", выполняется цикл. Если список слов массива
    "a" становится пустым, цикл прекращает работу  (проверя-
    ется истинность логического условия

                $#a > 0,

    т.е. если число слов списка "a" больше 0, то  список  не
    пуст).  В  теле  цикла  действует команда shift, которая
    "выталкивает" влево крайнее левое слово списка, а следу-
    ющее  занимает его место в списке и так далее до послед-
    него слова в списке. Таким образом, после каждой  итера-
    ции количество слов в списке сокращается на 1, а текущие
    номера слов принимают новые значения - на 1 меньшие тех,
    которые были до shift.

       Форма команды shift без  аргумента  относится  к  ко-
    мандной строке. Аргументы командной строки являются сло-
    вами массива argv, argv[0] -  собственное  имя  команды,
    остальные  слова ее аргументы. Пример: допустим, имеется
    командный файл f.csh

        #
        while( $#argv > 0 )
                echo $argv
                shift
        end

     , тогда получим

        % f.csh a1 b2 c3 d4 e5 f6
        a1 b2 c3 d4 e5 f6
        b2 c3 d4 e5 f6
        c3 d4 e5 f6
        d4 e5 f6
        e5 f6
        f6
        %

    Здесь все происходит аналогично предыдущему примеру, од-
    нако, в качестве рабочего массива слов используются сло-
    ва массива argv. Команда echo выводит слова с номера 1 и
    до последнего слова в списке.

source имя
    команда source заставляет  CSH  интерпретировать  строки
    файла "имя", определяющие действия, аналогичные тем, ко-
    торые установлены в файле ".cshrc". Другими словами, ко-
    манда source используется для установки новых внутренних
    переменных оболочки и других назначений, которые заменя-
    ют  имевшиеся к этому моменту. Команды source могут быть
    вложенными. Eсли глубина вложения  слишком  велика,  CSH
    может  не  хватить дескрипторов файлов. Ошибка в команде
    source на любом уровне завершает  выполнение.  Ввод  при
    выполнении  команд  source  не помещается в список пред-
    шествующих команд истории. Вызов команды source без  ар-
    гументов порождает состояние ошибки.








                                                          65

switch (строка)
        case стр1:
                ...
                breaksw
        ...
        ...
        ...
        default
                ...
                breaksw
endsw

    "Строки" вариантов case последовательно  сравниваются  с
    указанной  в "switch" строкой, которая сначала подверга-
    ется расширению имен команд и имен файлов.  В  "строках"
    вариантов  case  могут  использоваться  метасимволы имен
    файлов "*",  "?"  и  "[...]".  Если  перед  обнаружением
    "default" ни одна из "строк" в "case" не совпала, выпол-
    нение  продолжается  после  "default".  Слова  "case"  и
    "default"  должны быть первыми в строке. Команда breaksw
    приводит  к  тому,  что  выполнение  продолжается  после
    endsw.  Если  ни  одна из меток не совпадает и "default"
    отсутствует, выполнение продолжается после  endsw.  При-
    мер: пусть имеется командный файл f.csh

        #
        set i = 0
        while( $#argv > 0 )
            switch($argv[1])
                case "a":
                        echo a "\c"
                        @ i++
                        breaksw
                case "b":
                        echo b "\c"
                        @ i++
                        breaksw
                case "c":
                        echo c "\c"
                        @ i++
                        breaksw
                case "d":
                        echo d "\c"
                        @ i++
                        breaksw
                case "e":
                        echo e "\c"
                        @ i++
                        breaksw
                case "f":
                        echo f "\c"
                        @ i++
                        breaksw
                default:
                        breaksw
            endsw
            shift
        end
        if( $i == 0 ) then
                echo "\nNot found."
        else
                echo "\nReady."


66

        endif

        Теперь получим:

        % f.csh  a b c d e f
        a b c d e f
        Ready.
        % f.csh  z k l m n o p

        Not found.
        % f.csh  z k l a n f e
        a f e
        Ready.
        %

    В этом примере анализируется строка аргументов  команды.
    Если  в этой строке встречаются слова из списка "a b c d
    e f", то выводятся найденные и работа завершается  выво-
    дом  "Ready.".  Если  совпадений  нет, то выводится "Not
    found." Переменная i используется  как  флаг.  Если  его
    значение  не  равно  0,  то  совпавшие слова обнаружены.
    Переключатель switch используется для организации прове-
    рок совпадений элемента argv[1] со словами, указанными в
    вариантах case. По метке "default" осуществляется  выход
    за  пределы  "switch"  и  продолжается действие внешнего
    цикла while до тех пор, пока список слов в argv не  ста-
    нет пустым.

time
time команда
    При отсутствии параметров печатается итог  времени,  из-
    расходованного  данной  оболочкой и ее потомками. Напри-
    мер:

        % time
        310.5u 350.2s 5:51:05 3%
        %

        310.u  - это время
               пользовательской фазы
               процессов, порожденных в
               оболочке (в секундах);

        350.2s - время системной фазы этих
               процессов;

    Далее идет астрономическое общее время работы оболочки и
    %  отношения  суммы  времен пользовательской и системной
    фаз к астрономическому времени.

       Когда задан аргумент, получим:

        % time date
        Вто Июл  9 19:08:42 MSK 1985
        0.0u 0.3s 0:01 28%
        %

        или

        % time date >& file &
        156
        % cat file


                                                          67

        Вто Июл  9 19:08:52 MSK 1985

        real        1.0
        user        0.0
        sys         0.1
        %

    В качестве аргумента команды time может выступать только
    одна  команда.  Не  допускается использование последова-
    тельности команд или конвейера.

umask
umask маска
    Все файлы, которые создаются в процессе интерпретации  и
    выполнения  командных  строк  будут иметь код доступа, в
    котором будут маскированы (равны 0) те биты, номера  ко-
    торых указаны в маске. Пусть маска имеет вид 123. Первая
    цифра относится к маскированию битов  доступа  для  вла-
    дельца файла и супер-пользователя, вторая к битам досту-
    па группы, а третья к битам доступа всех остальных поль-
    зователей. Допустим коды доступа к файлу имеют вид:

                 -rwxrwxrwx ,

    тогда после наложения маски 123 получим

                 -rw-r-xr--

       Значение маски указывается в восьмеричном коде. Самы-
    ми  распространенными значениями маски являются 002, ко-
    торое задает любой доступ для пользователей своей группы
    и доступ для чтения и выполнения другим пользователям, и
    022, которое определяет любой доступ, за исключением за-
    писи, для пользователей своей группы и всех прочих.

       Чтобы получить значение маски, надо выполнить  коман-
    ду:

        % umask
        022
        %

       Чтобы изменить маску необходимо выполнить,  например,
    команду:

        % umask 022
        %

       По умолчанию в системе устанавливается маска 022.

unalias псевдоним ...
    Все псевдонимы, имена которых  соответствуют  указанным,
    отменяются. Следовательно, "unalias *" удаляет все псев-
    донимы. Если ни один из псевдонимов не установлен, то не
    порождается  состояние  ошибки при попытке выполнить ко-
    манду unalias. При запуске команды без аргументов порож-
    дается состояние ошибки.

unhash
    Команда unhash запрещает  CSH  использовать  хеш-таблицу
    при поиске команды. В этом случае CSH пытается найти ко-
    манду либо в справочниках, указанных в path, либо,  если


68

    не  указан  путь к файлу с именем "команда", порождается
    состояние ошибки.

unset шаблон
    Все переменные, имена которых  соответствуют  указанному
    шаблону, удаляются. Таким образом, "unset *" удаляет все
    переменные, установленные командой set. При попытке уда-
    лить  неопределенную переменную не порождается состояние
    ошибки.

wait
    Происходит ожидание всех  выполняемых  процессов.   Пока
    выполняется  команда  wait,  CSH  не выдает приглашения.
    Команда wait выполняется, пока не завершатся  все  запу-
    щенные на выполнение процессы. При прерывании выполнения
    команды wait (CNTRL/C или СУ/C) сообщаются имена и номе-
    ра  всех  процессов,  для  которых выполнялось ожидание.
    Когда все выполняющиеся процессы прекратят работу  будет
    выдано приглашение CSH.

while(выражение)
        ...
        ...
        ...
end

    Оператор цикла. Цикл выполняется пока  истинно  значение
    "выражения". Ключевые слова "while" и "end" должны нахо-
    диться на отдельных строках. В теле цикла можно  исполь-
    зовать  команду  "break"  для  выхода из цикла и команду
    "continue" для возобновления  следующей  итерации  цикла
    без  завершения текущей ( все операторы цикла, следующие
    за командой "continue" не  будут  выполняться  в  данной
    итерации). Пример: пусть имеется командный файл f.csh

        #
        echo "     \c"
        while( $#argv > 0 )
                if( $argv[1] == "3" ) then
                        shift
                        continue
                endif
                if( $argv[1] == "0" ) then
                        break
                endif
                echo " $argv[1]\c"
                shift
        end

        , тогда получим:

        % f.csh 1 2 3 1 2 3 1 2 3 0 1 2 3
                1 2 1 2 1 2
        %

    Здесь выполняется цикл, в котором  выводятся  слова  ко-
    мандной  строки.  Если  слово есть символ "3", то оно не
    выводится и идет переход к следующей итераци цикла, если
    слово символ "0", то действие цикла прекращается.





                                                          69

                                                 ПРИЛОЖЕНИЕ 


                   1. ОПИСАНИЕ  CSH в БНФ


   Ниже представлено описание языка команд "CSH" в БНФ.

   Если специально не оговорено другое, символ "/"  выделяет
начало и конец комментариев.


        команда_CSH ::= последоват_команд
                    ::= последоват_команд
                   /последоват_команд
                            уходит в пакет/

последоват_команд ::= команда
::= команда разделитель_последовательности
            последоват_команд

разделитель_команд ::=  ;
                   /последовательности
                    команд выполняются
                    последовательно/

                    ::=  ||
                   /следующая
                    последовательность
                    команд выполняется,
                    если предыдущая
                    завершилась неудачно/

                    ::=  &&
                   /следующая
                    последовательность
                    команд выполняется,
                    если предыдущая
                    завершилась удачно/

            команда ::=  простая_команда
                    ::=  простая_команда
                         разделитель_команд
                         команда

 разделитель_команд ::=  |
                   /команды образуют
                    межпроцессный канал/


                    ::=  |&
                   /к стандартному выводу
                    добавляется
                    диагностический/

    простая_команда ::=(последоват_команд)

                    ::=  перенаправление
                         слово
                         список_слов
                         перенаправление



70

    перенаправление ::=  ввод вывод
                    ::=  вывод ввод
                    ::=  ввод
                    ::=  вывод
           ::= вывод_в_межпроцессный_канал

               ввод ::=  <  имя
                   /файл имя становится
                    стандартным вводом/

                    ::=  << слово

                   /взамен символа CNTRL/D
                    (СУ/D) (конец файла)
                    используется слово,
                    которое проверяется на
                    соответствие вводимой
                    строке. При совпадении
                    файл создается и
                    нормально закрывается,
                    иначе не создается.
                    Слово в файл не
                    записывается./



              вывод ::=  >  имя
                   /файл 'имя' становится
                    стандартным выводом/

                    ::=  >!
                   /отменить запрет на
                    операции с файлом
                   'имя'/

                    ::=  >&
                   /диагностические
                    сообщения направить
                    в файл 'имя'/

                    ::=  >&!
                   /отменить запрет на
                    операции с
                    файлом 'имя' и выводить
                    диагностические
                    сообщения в него/

                    ::=  >>
                   /дописать вывод в
                    файл 'имя'/

                    ::=  >>&
                   /дописывать
                    диагностические
                    сообщения в файл 'имя'/

                    ::=  >>!
                   /отменить запрет на
                    операции с
                    файлом 'имя' при
                    дописывании/



                                                          71

                    ::= >>&!
                   /дописывать в файл 'имя'
                    и диагностические
                    сообщения и отменить
                    запрет на операции
                    с файлом 'имя'/

вывод_в_межпроцессный_канал ::= |
                   /команда выводит
                    результат не в файл, а
                    в межпроцессный канал
                    (pipe)/


              слово ::=  элемент_слова |
                         элемент_слова
                         слово

      элемент_слова ::=  'строка'
                   /в строке не делается
                    подстановок/

         ::=  "строка"
        /в строке делаются подстановки/

         ::= `команда_системы`
        /подставляется выход команды/

         ::=  символ

         ::= \символ
        /снять спецзначение символа,
         если оно отсутствует, то сам
         символ/

         ::= переменная_CSH
         ::= слово_предыдущей_команды
         ::= переменная_CSH:модификатор

         ::=  $?переменная
        /подставляется 1, если переменная
         определена, иначе 0/

         ::= ${?переменная}
        /подставляется 1, если переменная
         определена, иначе 0/

         ::= $?0
        /подставляется 1, если входной файл
         определен, иначе 0/

         ::= ${?0}
        /подставляется 1, если входной файл
         определен, иначе 0/

         ::= $$
        /подставляется десятичный номер
         порождающей процесс оболочки/


         ::= расширение_имени_файла



72


     переменная_CSH ::= $переменная
                   /подставляется
                    значение переменной/

         ::= ${ переменная }
        /{} выделяют переменную от других
         символов, идущих следом без
         разделителя; подставляется
         значение переменной/

         ::= $переменная[селектор]
        /из переменной выделяется слово по
         селектору и подставляется его
         значение/

         ::= ${переменная[селектор]}
        /из переменной выделяется слово по
         селектору и подставляется его
         значение/

         ::= $#переменная
        /подставляется количество слов
         переменной/

         ::= ${#переменная}
        /подставляется количество слов
         переменной/

         ::= $0
        /подставляется имя файла из
         которого читается вход CSH/

         ::= $число
        /эквивиалентно $argv[число]/

         ::= ${число}
        /эквивиалентно $argv[число]/

         ::= $*
        /эквивалентно $argv[*]/



         переменная ::=  argv
                   /строка аргументов CSH /

                    ::= child
                   /номер последнего
                    процесса/

                    ::= history
                   /размер списка
                    предшествующих команд в
                    истории/

                    ::= home
                     /регистрационный
                     справочник   процесса/

                    ::= ignoreeof
                   /игнорирует символ


                                                          73

                    конца файла с дисплея/

                    ::= mail
                   /файлы, которые
                    необходимо
                    просматривать на
                    наличие почты/

                    ::= noclobber
                   /защитить файлы
                    от случайных
                    разрушений/

                    ::= noglob
                   /защитить файлы от
                    случайного расширения
                    имен/

                    ::= nonomatch
                   /не порождать состояние
                    ошибки при попытке
                    расширить имя файла
                    когда он от этого
                    защищен. Возвращает
                    шаблон, который
                    предлагался для
                    расширения имени файла/

                    ::= path
                   /каждое слово пременной
                    определяет имя
                    справочника, в котором
                    осуществляется поиск
                    команд/

                    ::= prompt
                   /строка приглашения/

                    ::= shell
                   /командный язык,
                    которому передаются
                    командные файлы на
                    исполнение/

                    ::= status
                   /код состояния
                    предыдыщей команды/

                    ::= time
                   /хронометрирование
                    выполнения команды/

                    ::= verbose
                   /выводить команды перед
                    выполнением/


модификатор_последней_строки ::= ^l^r
                   /заменить в последней
                    строке истории слово l
                    на слово r/



74


        модификатор ::= h
                   /удалить имя файла,
                    сохранив компоненты
                    пути/

                    ::= r
                   /удалить расширение
                    имени файла, указанное,
                    через "." /

                    ::= s/l/r/
                   /строку l заменить на
                    строку r/

                    ::= t
                   /сохранить имя файла,
                    удалив компоненты пути/

                    ::= &
                   /повторить предыдущую
                    подстановку/

                    ::= g
                   /применить изменение
                    глобально, ко всем
                    словам/

                    ::= p
                   /распечатать команду, но
                    не выполнять ее/

                    ::= q
                   /запретить дальнейшую
                    модификацию слова.
                    Слово заключается в
                    кавычки/

                    ::= x
                   /разбить слова на слова
                    по разделителям и
                    запретить дальнейшую
                    модификацию. Результат
                    заключается в кавычки./



слово_предыдущей_команды
        ::=спецификация_предыдущей_команды

        ::=спецификация_предыдущей_команды
                       возможно_двоеточие
                       определитель_слов
                       список_модификаторов
        ::= модификатор_последней_строки


 возможно_двоеточие ::= :
                    ::=

список_модификаторов::= :модификатор
                    ::= :модификатор


                                                          75

                       список_модификаторов



спецификация_предыдущей_команды ::= !
                    ::= !определитель

       определитель ::= целое
                   /подставляется командная
                    строка номер которой в
                    истории равен целому/

                    ::= -целое
                   /подставляется командная
                    строка, номер которой в
                    истории меньше текущего
                    на целое/

                    ::= слово
                   /подставляется командная
                    строка из истории, в
                    которой первое слово
                    совпадает с указанным/

                    ::= ?слово?
                   /подставляется командная
                    строка из истории,
                    содержащая слово,
                    совпадающее с
                    указанным/

  определитель_слов ::= целое
                   /выбирается слово из
                    командной строки, номер
                    которого равен
                    указанному/

                    ::= ^
                   /выбрать первое слово
                    из командной строки/
                    ::= $
                   /выбрать последнее
                    слово из командной
                    строки/

                    ::= %
                   /выбрать слово
                    соответствующее
                    предшествующему шаблону
                    "?...?"/

                    ::= целое1-целое2
                   /выбрать диапазон слов
                    от слова с номером
                    целое1 до целое2
                    включительно/

                    ::= -целое
                   /выбрать слова от слова
                    с номером 0 до слова,
                    номер которого равен
                    указанному целому/


76


                    ::= *
                   /выбрать все слова кроме
                    слова с номером 0/

                    ::= целое*
                   /выбрать все слова от
                    слова с номером целое
                    до последнеого/

                    ::= целое-
                   /выбрать все слова от
                    слова с номером целое и
                    не выбирать последнее
                    слово/


расширение_имени_файла ::=  *
                   /соответствует любой
                    последовательности
                    символов./

                    ::= ?
                   /соответствует одному
                    любому символу/

        ::= [последовательность_символов]
                   /соответствует любому
                    символу указанной
                    последовательности/

                    ::= [диапазон_символов]

                    ::= ~
                   /регистрационный
                    справочник/

                    ::= ~имя
                   /справочник пользователя
                    имя/

        ::= [список_символов_через_запятую]
                   /соответствует одному из
                    перечисленных символов.
                    В том числе и символы
                    "[", "]"/

        ::= метаобозначение_порядка_имен
                   /генерация имен
                    файлов из указанных
                    слов/


  диапазон_символов ::= символ-символ
                   /соответствует любому
                    символу из
                    лексикографически
                    упорядоченного
                    диапазона/

метаобозначение_порядка_имен ::=
  слово1{список_слов_через_запятую}слово2


                                                          77

                /к слово1 добавляется
                 первое слово из
                 список_слов_через_запятую
                 и добавляется слово2.
                 Далее повторяется для
                 второго слова из
                 список_слов_через_запятую
                 и так далее. Не
                 допускаются пробелы!/






        команда_CSH ::=

                    ::= alias
                   /вывести список
                    псевдонимов/

                    ::= alias имя
                   /вывести
                    содержимое псевдонима
                    имя/

        ::= alias имя список_слов
                   /установить псевдоним
                    имя списку слов/

                    ::= alloc
                   /распечатать карту
                    распределения памяти
                    CSH/

                    ::= break
                   /прерывание цикла/

                    ::= breaksw
                   /прерывание switch/

                    ::= continue
                   /переход к заголовку
                    цикла/

                    ::= echo строка
                   /распечатать строку/

        ::= exec команда_системы
                   /выполнить команду
                    системы /

                    ::= exit
                   /завершить работу CSH/

                    ::= exit(выражение)
                   /выход из CSH со
                    значением выражения/

        ::= foreach имя (список_слов)
                список_команд
            end


78


                   /список команд
                    выполняется для каждого
                    значения имени из
                    списка слов/

                    ::= glob список_слов
                   /выводить список слов не
                    разделяя их пробелами и
                    без перехода на новую
                    строку/

                    ::= goto слово
                   /переход по метке/

                    ::= hashstat
                   /распечатать статистику
                    использования
                    хеш-таблиц/

                    ::= history
                   /распечатать список
                    предшествующих команд,
                    распечатка истории/

        ::= if(выражение) команда_системы
                   /выполнить команду
                    системы, если выражение
                    не 0/

                    ::= if(выражение)
                            список_команд
                            команда_else_if
                            команда_else
                        endif

команда_else_if ::= else if(выражение) then
                            список_команд

       команда_else ::=
                    ::= else список_команд

                    ::= login
                   /выход/

                    ::= login имя
                   /выход с запросом входа
                    по имени/

                    ::= nice
                   /установить приоритет
                    CSH равный 4/

                    ::= nice +число
                   /установить приоритет
                    CSH число/

                    ::= nice -число
                   /установить приоритет
                    CSH '-число'. Доступно
                    только
                    супер-пользователю/


                                                          79


        ::= nice команда_системы
                   /установить приоритет 4
                    команде/

        ::= nice +число команда_системы
                   /установить приоритет
                    число команде/

        ::= nice -число команда_системы
                   /установить приоритет
                    -число команде.
                    Доступно только
                    супер-пользователю/

                    ::= nohup
                   /игнорировать прерывания
                    по (CNTRL/C), (CNTRL/\)
                    и break (отключение
                    коммутируемой линии)/

        ::= nohup команда_системы
                   /игнорировать прерывания
                    команды по (CNTRL/C),
                    (CNTRL/\) и break
                    (отключение
                    коммутируемой линии)/

                    ::= onintr
                   /восстановить нормальную
                    реакцию CSH на
                    прерывания/

                    ::= onintr -
                   /игнорировать
                    прерывания/

                    ::= onintr имя
                   /переходить на метку имя
                    при получении
                    прерывания/


                    ::= rehash
                  /пересчитать
                  хеш-таблицы в связи со
                  сменой содержимого
                  справочников, указанных в
                  path/

        ::= repeat целое команда_системы
                   /выполнить команду
                    системы "целое"
                    число раз/

                    ::= set
                   /распечатать значения
                    переменных/

                    ::= set имя
                   /переменной имя
                    присвоить пустую


80

                    строку/

                    ::= set имя = слово
                   /переменной имя
                    присвоить слово./

        ::= set имя[целое] = слово
                   /в переменной имя слово
                    с номером "целое"
                    получает новое
                    значение/

        ::= set имя = (список_слов)
                   /имя получает значение
                    списка слов/

                    ::= setenv имя строка
                   /значению переменной
                    окружения имя
                    присваивется строка/

                    ::= shift
                   /элементы argv
                    сдвигаются влево/

                    ::= shift имя
                   /элементы переменной имя
                    сдвигаются влево/

                    ::= source имя
                   /считать команды из
                    файла имя/

                    ::= switch(строка)
                           список_случаев
                        endsw

     список_случаев ::= case слово:
                              список_команд
                    ::= default:
                              список_команд

                    ::= time
                   /вывести время работы
                    CSH/

        ::= time команда_системы
                   /хронометрировать и
                    вывести результат/

                    ::= umask
                   /вывести маску доступа к
                    файлам/

                    ::= umask число
                   /установить маску
                    доступа к файлам. Число
                    восьмеричное/

                    ::= unalias слово
                   /удалить псевдоним
                    слово/


                                                          81


                    ::= unhash
                   /запретить использование
                    хеш-таблиц/

                    ::= unset имя
                   /считать имя
                    неопределенным/

                    ::= wait
                   /ждать завершения
                    порожденных процессов/

                    ::= while(выражение)
                            список_команд
                        end

                    ::= @
                   /распечатать значения
                    всех переменных/

::= @ имя знак_присваивания выражениe
                   /присвоение переменной
                    имя значения выражения/


::= @имя[целое] знак_присваивания выражениe
                   /присвоение значения
                    выражения компоненте
                    переменой имя/


знак_присваивания ::=

                     =
                    +=
                    -=
                    *=
                    /=
                    %=



          выражение ::= операнд
                    ::= порядок_операций

                    ::= операнд
                        знак_операции
                        выражение

   порядок_операций ::= ( выражение )
                   /скобки меняют приоритет
                    операций/


      знак_операции ::= двуместная
                    ::= одноместная
        ::= поразрядная_логическая

         двуместная ::= операнд_строка
                    ::= операнд_целое_число



82

     операнд_строка ::=
                      ==   равно?
                      !=   не равно?

операнд_целое_число ::=

                     ||   или
                     &&   и
                     <=   меньше или равно?
                     >=   больше или равно?
                      >   больше?
                      <   меньше?
                      +   сложить
                      -   вычесть
                      *   умножить
                      /   делить
                      %   остаток деления

       одноместная ::=
                     ++   /инкремент,
                           постфиксная/
                     --   /декремент,
                           постфиксная/

поразрядная_логическая ::=
                      &       умножение
                      |       сложение
                      ~       или
                      ^       дополнение
                             /унарная/
                      !       отрицание
                             /унарная/
                     >>      сдивг вправо
                     <<      сдвиг влево




            операнд ::= переменная
                    ::= константа
                    ::= строка
                    ::= {команда_системы}
                   /подставляется результат
                    выполнения команды/
                    ::= -запрос_файла имя


       запрос_файла ::= r /читать?/
                    ::= w /писать?/
                    ::= x /выполнять?/
                    ::= е /существует?/
                    ::= o /владелец?/
                    ::= z /размер = 0 ?/
                    ::= f /зашифрован?/
                    ::= d /справочник?/









                                                          83

                                                 ПРИЛОЖЕНИЕ 


                  2. СООБЩЕНИЯ ОБ ОШИБКАХ


   CSH выводит два типа сообщений. Один тип сообщений -  это
сообщения  о  нарушениях синтаксиса CSH, ошибочных значениях
аргументов, обращение к  отсутствующим  командам,  нарушение
прав доступа и т.д. Второй тип сообщений - это сообщения вы-
полняемых команд и программ, сообщения системных программ.

   Ниже перечислены сообщения CSH и приведены их значения.

Alarm clock
   - Сигнал от таймера;

Alias loop
   - Зацикленный alias.

Ambiguous
   - Неоднозначно.

Ambiguous : no output
   - Нет имени для ">" и т.п.

Ambiguous output redirect
   - Неоднозначно определено имя файла для перенаправления.

Arguments too long
   - Слишком длинные аргументы.

Bad ! arg selector
   - Плохой номер слова в !.

Bad ! form
   - Неправильное использование !.

Bad ! modifier:
   - Плохой модификатор в !.

Bad : mod in $
   - Плохой модификатор подстановки переменной.

Bad file number
   - Плохой дескриптор открытого файла.

Bad substitute
   - Плохая подстановка.

Bad system call
   - Плохой код системного вызова.

Badly placed (
   - Не на месте (.

Badly placed ()'s
   - Не на месте ().

Block device required
   - Должно быть блокориентированное устройство.



84

Broken pipe
   - Некорректный межпроцессный канал.

Bus error
   - Обращение по нечетному адресу.

Can't << within ()'s
   - Нельзя использовать << в скобках.

Can't from terminal
   - Нельзя выполнять в диалоговом режиме.

Can't make pipe
   - Нельзя создать pipe.

Command not found
   - Команда не найдена.

Cross-device link
   - Нельзя делать ссылку на другую файловую систему.

Disk quota exceeded
   - Исчерпан бюджет дискового пространства.

Divide by 0
   - Деление на 0.

EMT trap
   - Инструкция EMT.

Error 14
   - Ошибка  адресации.  Только  ЭВМ  типа  СМ-4,   СМ-1420,
     СМ-1600, Электроника-79.

Event not found
   - Такая команда не выполнялась.

Exec format error
   - Ошибка при выполнении системного вызова exec.

Expansion buf ovflo
   - Переполнен буфер обработки имен.

Expression syntax
   - Синтаксическая ошибка в выражении.

File exists
   - Файл уже существует.

File table overflow
   - Переполнена таблица файлов.

File too large
   - Файл слишком большой.

Floating exception
   - Ошибка выполнения операции с плавающей точкой.

Hungup
   - Зависание  по разрыву коммутируемой линии (break).




                                                          85

I/O error
   - Ошибка ввода-вывода.

IOT trap
   - Инструкция IOT.

Illegal instraction
   - Неверная инструкция.

Illegal seek
   - Недопустимый lseek.

Improper mask
   - Неправильная маска.

Improper then
   - Недопустимый then.

Interrupted
   - Прерванная команда wait.

Interrupted system call
   - Прерванный системный вызов.

Invalid argument
   - Недопустимый аргумент (в системном вызове).

Invalid null command
   - Недопустимая пустая команда.

Invalid variable
   - Недопустимая метка.

Is a directory
   - Это справочник.

Killed
   - Безусловное завершение процесса.

Line overflow
   - Слишком длинная строка.

Missing ]
   - Отсутствует ].

Missing file name
   - Пропущено имя файла.

Missing name for redirect
   - Пропущено имя файла для перенаправления.

Missing }
   - Отсутствует фигурная скобка.

Mod by 0
   - Попытка вычислить остаток от деления на 0.

Modifier failed
   - Образец, соответствующий модификатору не найден.





86

Mount device busy
   - Монтируемое устройство занято.

No args on labels
   - У метки не может быть аргументов.

No children
   - Нет порожденных процессов.

No file for $0
   - Не известен файл для $0.

No home
   - Не установлена переменная home.

No match
   - Нет подходящих имен.

No more processes
   - Слишком много процессов в системе.

No more words
   - Нет больше слов в списке.

No prev LHS
   - Не было предыдущей левой части подстановки.

No prev search
   - Не было предыдущего поиска.

No prev sub
   - Не было предыдущих подстановок.

No space left on device
   - Нет свободного пространства на устройстве.

No such device
   - Нет такого устройства.

No such device or address
   - Нет такого устройства.

No such file or directory
   - Нет такого файла или справочника.

No such process
   - Нет такого процесса.

Not a directory
   - Это не справочник.

Not a typewriter
   - Не терминал.

Not enough core
   - Не хватает оперативной памяти.

Not in while/foreach
   - Команды break или  continue  выполняются  не  в  циклах
     while/foreach.




                                                          87

Not login shell
   - Команда выполняется не в основной оболочке.

Not super-user
   - Вы не супер-пользователь.

Out of memory
   - Исчерпана внутренняя память интерпретатора.

Permission denied
   - Нарушение прав доступа.

Quit
   - Образ памяти процесса записан в файл core (CNTRL/\).

RHS too long
   - Слишком длинная правая часть подстановки.

Read-only file system
   - Запись в файловую систему запрещена.

Segmentation violation
   - Нарушение защиты памяти.

Setenv: syntax error
   - Синтаксическая ошибка в setenv.

Subscript error
   - Ошибочный индекс.

Subscript out of range
   - Индекс за границами массива.

Syntax error
   - Синтаксическая ошибка.

Terminated
   - Завершение процесса.

Terminator not found
   - Нет ограничивающего слова для <<.

Text file buse
   - Файл выполняется.

Then/endif not found
   - Не найдены then/endif.

Too dangerous to alias that
   - Слишком опасно переобозначать unalias.

Too few arguments
   - Слишком мало аргументов.

Too many )'s
   - Слишком много скобок.

Too many arguments
   - Слишком много аргументов.





88

Too many links
   - Слишком много ссылок.

Too many open files
   - Слишком много открытых файлов.

Too many words from ``
   - Слишком большой вывод из ``.

Trace/BPT trap
   - Сигнал по команде BPT или трассировка (T-бит).

Unknown user: ...
   - Неизвестный пользователь ...

Unmatched ...
   - Не закрыто ...

Unmatched `
   - Не закрыта `.

Use exit to leave CSH
   - Для выхода используйте exit.

Use logout to logout
   - Для выхода используйте logout.

Variable syntax
   - Неправильный синтаксис переменной.

Word too long
   - Слишком длинное имя.

Words not ()'ed
   - Слова должны быть в скобках.





























                                                          89



                           СОДЕРЖАНИЕ



1.  ВВЕДЕНИЕ. ОБЩИЕ СВЕДЕНИЯ О CSHELL..................    3

2.  ВВОД - ВЫВОД.......................................    9
    2.1. Ввод..........................................    9
    2.2. Вывод.........................................    9

3.  КОМАНДЫ............................................   12
    3.1. Простые команды...............................   12
    3.2. Последовательности команд.....................   12
    3.3. Группирование команд..........................   13
    3.4. Программный канал и конвейер..................   13
    3.5. Параллельное выполнение.......................   14

4.  ЛЕКСИЧЕСКАЯ СТРУКТУРА  CSH.........................   15
    4.1. Слово.........................................   15
    4.2. Часть слова...................................   15
    4.3. Продолжение строки............................   16

5.  МЕХАНИЗМ ПОДСТАНОВКИ (HISTORY).....................   17
    5.1. Команда history...............................   17
    5.2. Подстановка команд............................   17
    5.3. Определитель слов команды.....................   18
    5.4. Модификаторы слов в history...................   21
    5.5. Замены в последней строке.....................   23
    5.6. Псевдонимы....................................   23

6.  СПЕЦИАЛЬНЫЕ ФАЙЛЫ CSH..............................   25
    6.1. Файл '.login'.................................   25
    6.2. Файл '.logout'................................   26
    6.3. Файл '.cshrc'.................................   26

7.  ПЕРЕМЕННЫЕ CSH.....................................   27
    7.1. Внутренние переменные CSH.....................   27
    7.2. Флаги CSH.....................................   30
    7.3. Внешние переменные CSH........................   32
    7.4. Окружение.....................................   32

8.  ПОДСТАНОВКА ПЕРЕМЕННЫХ.............................   35

9.  МОДИФИКАТОРЫ.......................................   40

10. РАСШИРЕНИЕ ИМЕН ФАЙЛОВ.............................   43

11. ВЫРАЖЕНИЯ. КОМАНДА @...............................   46
    11.1.Операции......................................   46
    11.2.Форматы команды @.............................   47
    11.3.Операции присваивания.........................   48
    11.4.Порядок и старшинство операций................   48
    11.5.Синтаксис выражений...........................   48
    11.6.Примеры вычислений в CSH......................   49

12. УПРАВЛЕНИЕ ВЫПОЛНЕНИЕМ КОМАНД......................   51
    12.1.Оператор цикла foreach........................   51
    12.2.Оператор switch...............................   52
    12.3.Оператор if...................................   53
    12.4.Оператор цикла while..........................   54


90

13. КОМАНДНЫЕ ФАЙЛЫ....................................   55

14. ВСТРОЕННЫЕ КОМАНДЫ CSH.............................   56

ПРИЛОЖЕНИЕ 1.  ОПИСАНИЕ  CSH в БНФ.....................   70

ПРИЛОЖЕНИЕ 2.  СООБЩЕНИЯ ОБ ОШИБКАХ....................   84

























































                                                          91

