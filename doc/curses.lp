
            дддд   ееееее   м     м    oooo     сссс
           д   д   е        мм   мм   o    o   с    с
          д    д   е        м м м м   o    o   с    с
          д    д   еееее    м  м  м   o    o   с
          д    д   е        м     м   o    o   с
          д    д   е        м     м   o    o   с    с
         дддддддд  ееееее   м     м    oooo     сссс



          демосдемосдемосдемосдемосдемосдемосдемосде
          емосдемосдемосдемосдемосдемосдемосдемосдем
          мо                                      мо
          ос                                      ос
          сд        ОПЕРАЦИОННАЯ СИСТЕМА          сд
          де                                      де
          ем               ДЕМОС                  ем
          мо                                      мо
          ос                                      ос
          сд                                      сд
          де             Версия 1.0               де
          ем                                      ем
          мо                                      мо
          сдемосдемосдемосдемосдемосдемосдемосдемосд
          демосдемосдемосдемосдемосдемосдемосдемосде







                  БИБЛИОТЕКА ПРОГРАММ ДЛЯ
                 РАБОТЫ С ЭКРАНОМ ТЕРМИНАЛА
                          libcurses





                  Аншуков Сергей Александрович












                       МОСКВА - 1985









                                                           1



   Описывается  библиотека  стандартных  функций  ОС  ДЕМОС,
предназначенных для работы с экраном терминала.





























































                                                           1


     ВВЕДЕНИЕ


   Одним из "узких" мест в создании  "мобильного"  математи-
ческого  обеспечения  является  взаимодействие  программы  с
внешними устройствами. Эта проблема может быть решена  двуми
способами:    использованием    ограниченного   подмножества
функций, допустимых на широком классе устройств, и  расшире-
нием  функционального  набора  за  счет сужения класса. В ОС
ДЕМОС, первый подход реализован в самой операционной системе
путем  обеспечения  единого  аппарата доступа для всех типов
внешних устройств. Второй подход применяется некоторыми спе-
циализированными  программами, к числу которых можно отнести
функциональные фильтры, реализующие некоторый набор операций
для  одного  конкретного устройства (примером такого подхода
может служить графический пакет plot), и компоненты, способ-
ные,  в рамках определенного класса внешних устройств, дина-
мически настраиваться на их  функциональные  особенности.  К
последнему  типу  относятся  экранный  редактор  red и пакет
curses.

   Пакет curses предлагается в качестве универсального прог-
раммного интерфейса для работы с экраном алфавитно-цифрового
терминала и предназначен для создания  интерактивных  компо-
нент,  способных  функционировать на довольно широком классе
дисплеев. Curses моделирует работу с виртуальным терминалом,
для  которого  разрешены  такие операции как очистка экрана,
уничтожение строки (символа), вставка строки (символа),  вы-
деление  символов,  перемещение курсора в заданную позицию и
т.п.  Для  настройки  на  тип  дисплея   используется   файл
/etc/termcap,  в  котором содержатся описания функциональных
возможностей терминалов.































2




                     1. ОБЩИЕ СВЕДЕНИЯ


   Пакет curses представляет собой набор подпрограмм для ра-
боты  с  экраном  терминала, обеспечивающих функционирование
программ, написанных с их  применением,  на  широком  классе
терминалов.  Универсальность  пакета  об'ясняется следующими
причинами.

   При создании пакета curses, была сделана попытка выделить
наиболее общие для алфавитно-цифровых терминалов функции пе-
ремещения курсора. При инициализации пакета, из файла описа-
ний возможностей терминалов /etc/termcap, берется информация
о том, как выполнить  ту  или  иную  команду  на  конкретном
устройстве; в дальнейшем работа ведется в режиме интерпрета-
ции.

   Большая часть операций, связанных с  редактированием  ин-
формации  на экране, выполняется над образом экрана в памяти
ЭВМ. В пакете curses вводится понятие "окно". Это  виртуаль-
ное  устройство, отображающееся на часть экрана терминала (в
пределе весь экран или отдельную позицию). Окно характеризу-
ется  своим расположением относительно начала экрана, разме-
рами (количеством строк и символов в  строке),  координатами
текущей  позиции  (положением  логического курсора) в окне и
относящейся к нему информацией. Для описания  окна  вводится
новый  тип  данных - WINDOW. Это структура, которая содержит
буфер для символов, относящихся к окну, и некоторую  служеб-
ную  информацию. Большая часть подпрограмм пакета предназна-
чена для работы именно с этой структурой.

   Для окна существуют такие операции, как:  создать/уничто-
жить  окно,  вставить/уничтожить символ или строку, перемес-
тить курсор в заданную позицию в окне, "наложить" одно  окно
на  другое  и  т.п.  Все  изменения производятся в буфере, и
пользователь может только проецировать их на экран. Это поз-
воляет в произвольном порядке редактировать содержимое окна,
иметь несколько версий одной и той же части  экрана,  созда-
вать  различные структуры отображаемой информации. На экране
одновременно может  содержаться  информация,  относящаяся  к
различным окнам. При выдаче содержимого окна на экран терми-
нала меняется только та его часть, которая "покрывается" ок-
ном. При этом задачей пакета curses является оптимизация об-
новления экрана.

   В пакете curses реализовано три уровня оптимизации:

- В структуре WINDOW, описывающей какое-либо окно,  сохраня-
  ется контекст последнего редактирования. При проецировании
  содержимого окна на экран терминала просматривается только
  та  часть окна, которая менялась со времени предыдущей вы-
  дачи.

- Хранится копия экрана  терминала  (окно  curscr),  которая
  описывает как выглядит экран в текущий момент времени. При
  проецировании содержимого окна на экран, все изменения да-
  ются как отличия от копии предыдущей версии экрана.




                                                           3

- Даже если имеется возможность  прямой  адресации  курсора,
  делается попыпка переместиться в заданную позицию, исполь-
  зуя наименьшее число управляющих символов. Это  связано  с
  тем,  что  для прямой адресации, как правило, требуется не
  менее трех символов, а в большинстве случаев  можно  обой-
  тись одним-двумя управляющими символами.

   Все виды оптимизации реализованы из соображения, что  об-
работка информации в памяти занимает меньше времени, чем об-
мен с физическим устройством.

   За любого  рода  универсальность  приходится  платить.  В
данном  случае  основным недостатком пакета curses является,
то что при заведении окна динамически  захватывается  память
прямо пропорциональная его размерам. При работе на малых ма-
шинах, таких как СМ-4, это накладывает некоторые ограничения
на  число окон, с которыми одновременно может работать прог-
рамма. Оценить количественно ограничения этого типа  трудно,
так как, это зависит от величины самой программы и структуры
отображаемой информации.

   В пакете curses предусмотренны два типа средств, позволя-
ющих в какой-то мере сгладить существующий недостаток:

- Вводится понятие "подокна",  которое  отличается  от  окна
  только  тем,  что для хранения относящихся к нему символов
  используется буфер окна "родителя".  Этим  обуславливается
  то,  что  при редактировании подокна изменяется и та часть
  окна "родителя", которая "покрыта" этим  подокном.  В  ос-
  тальном подокно ничем не отличается от окна, и к нему при-
  менимы все разрешенные для окна операции. Подобный  подход
  позволяет  создавать  программы,  работающие  с достаточно
  сложными структурами отображаемой информации, что удовлет-
  воряет требованиям большого числа задач.

- В пакете curses выделены две подпрограммы,  которые  могут
  использоваться  автономно.  Это: подпрограмма оптимального
  перемещения курсора mvcur и подпрограмма настройки на  тип
  терминала setterm. С помощью этих подпрограмм можно созда-
  вать  достаточно  оптимальные,  компактные,  интерактивные
  программы  (пример  такой программы приводиться в приложе-
  нии). Однако, использование  этого  уровня  пакета  curses
  требует более высокой квалификации.





















4




                    2. ОПИСАНИЕ ФУНКЦИЙ


   При работе с пакетом curses требуется  выполнение  следу-
ющих условий:

- Функциональные характеристики терминала должны быть описа-
  ны в файле /etc/termcap;

- В качестве стандартного файла вывода должен использоваться
  терминал;

- Программы, написанные с использованием curses, должны  со-
  держать описания глобальных переменных библиотеки:

                      #define <curses.h>

  и  транслироваться  совместно  с  библиотеками  curses   и
  termlib  (подпрограмм для работы с файлом описаний функци-
  ональных возможностей терминалов):

             cc [flags] files -lcurses -ltermlib

  В таблице 1 приводится список переменных, которые  исполь-
  зуются пакетом и встречаются в описании.

                                                   Таблица 1

                    Основные переменные

------------------------------------------------------------
ТИП     ИМЯ        ОПИСАНИЕ
------------------------------------------------------------
WINDOW* curscr  Копия текущего состояния  экрана.  Заводится
                функцией   initscr   и  является  внутренней
                структурой пакета curses изменять которую НЕ
                ДОПУСКАЕТСЯ.
WINDOW* stdscr  Окно прeдназначенное для работы  пользовате-
                ля.  Заводится  функцией  initscr,  равно по
                размерам экрану терминала.
int     LINES   Число строк на экране терминала. Определяет-
                ся функцией initscr.
int     COLS    Число   колонок   в   строке.   Определяется
                функцией initscr.
int     ERR
int     FALSE   Значения, которые возвращают функции  пакета
                curses  в  случае  ошибки. Следует отметить,
                что все функции сообщают об ошибке, не  про-
                изводя ни каких изменений.
int     OK
int     TRUE    Значения, которые возвращают функции  пакета
                curses  в случае успешного завершения опера-
                ции.
------------------------------------------------------------

   Подпограммы пакета можно разделить на три группы:





                                                           5

- управление окнами (initscr, newwin, subwin,  wrefresh  ...
  delwin);

- задание режимов  ввода/вывода  (scrollok,  clearok,  echo,
  noecho, raw, noraw ... crmode);

- редактирование окон (waddch, waddstr, wdelch,  winsch  ...
  wgetch).

   На рис. 1 представлена картина взаимодействия функций па-
кета.

            Взаимодействие функций пакета curses

==========================================
|               initscr                  |
==========================================
| newwin, subwin, delwin, scrollok ...  .|
|........................................|
|        |            .wdelch, wdeleteln.|
|        |            ...................|
|+-------V-------+    .wpritw, wscanw   .|
||  структура    |<---...................|
||   WINDOW      |    .waddch, waddstr  .|
|+---------------+    ...................|
|        |            .wgetch, wgetstr  .|
|        |            ...................|
|        |            .wdelch, wdeleteln.|
|   *****V*******************************|
|   * wrefresh                          *|
|   *************************************|
|        |            .werase, wclear   .|
|        |            ...................|
|+-------|-------+    .     .......     .|
||       |  ЭКРАН|    +++++++++++++++++++|
||   ....V..     |    +raw, noraw       +|
||   .ОКНО .     <====+.................+|
||   .     .     |    +echo, noecho     +|
||   .......     |    +.................+|
||               |    +crmode, nocrmode +|
|+---------------+    +++++++++++++++++++|
|                                        |
==========================================
|            endwin                      |
==========================================

                           Рис. 1


   Программы, использующие библиотеку  curses  должны  начи-
наться   с  инициализации  устройства  -  для  этого  служит
функция:

                         initscr()

которая "настраивает" пакет на характеристики терминала.

   Для завершения  работы  с  экраном  терминала  необходимо
вызвать функцию:





6

                          endwin()

Она восстанавливает режимы терминального  драйвера,  которые
могли быть изменены в процессе работы.

   Программам, использующим curses, следует  реагировать  на
сигналы,  которые  могут  вызвать преждевременное завершение
процесса (например сигнал interrupt), иначе, при "аварийном"
завершении процесса, режимы работы терминала могут оказаться
в  неопределенном  состоянии.  Заказать  обработку   сигнала
interrupt можно следующим образом:

                  signal (SIGINT, endwin);


   Для заведения окон служат функции newwin  и  subwin.  Как
уже  отмечалось,  измененять  экран терминала можно только с
помощью подпрограмм пакета curses. Функция:

    wrefresh (win)
    WINDOW* win;

проецирует содержимое окна win на экран терминала.

   Остальные функции предназначены для редактирования содер-
жимого  окон.  Все  они связаны с понятием координат текущей
позиции в окне. На рис. 2 показано соответствие значений те-
кущих  координат в окне положению курсора на экране термина-
ла.

                     Адресация символов

  0 к о о р д и н а т а  X
0 +--------------------|------------>COLS-1
 к|  начальное      0  |            |
 о|   положение   0 +--|---->cols-1 |
 о|    окна_______/ |  |    .       |
 р---------------------*    .       |
 д|текущие координаты /     .       |
 и|   в окне_________/      .       |
 н|                 |       .       |
 а|                 |ОКНО   .       |
 т|                 V........       |
 а|  ЭКРАН       lines-1            |
  |                                 |
 Y|                                 |
  V---------------------------------+
LINES-1

                           Рис. 2


   Координаты текущей позиции определяются двуми значениями:
y  - номером строки (от 0 до lines-1), и x - номером колонки
(от 0 до cols-1). Подпрограммы, предназначенные для редакти-
рования окон, используют относительные координаты в пределах
окна. Все изменения производяться от текущей позиции в окне.
При  проецировании содержимого окна на экран, координаты по-
зиции в окне преобразуются в координаты  позиции  на  экране
следующим  образом: номер колонки (строки) на экране опреде-
ляется как номер колонки (строки) в окне плюс номер  началь-
ной колонки (строки) окна относительно начала экрана.


                                                           7


   Некоторое из описанных функций в действительности являют-
ся макроопределениями и служат в основном для работы с окном
stdscr, например, функция уничтожения текущей строки в  окне
stdscr определена как:

           #define deleteln() (wdeleteln(stdscr))

В приводимом ниже описании, эта функция и подобные ей  выде-
ляются следующим образом:

                   deleteln()     /* + */



   2.1. Режимы ввода/вывода


   Существует несколько режимов ввода/вывода информации, ко-
торые можно разделить на два типа - режимы работы с физичес-
ким и виртуальным  устройством.  Изменение  режимов  первого
типа  распространяется на работу с экраном терминала и "нас-
ледуются"  всеми  окнами.  Изменение  режимов  второго  типа
распространяется только на работу с конкретным окном.


   2.1.1. Режимы работы физического устройства


ECHO   - Отображание на экране (и в окне) символов при  вво-
         де.  Для задания и отмены режима ECHO служат, соот-
         ветственно, функции echo() и noecho().

RAW    - Работа с терминалом в кодах устройства. Для задания
         и  отмены  режима RAW служат соответственно функции
         raw() и noraw().

NL     - В этом режиме при вводе/выводе символ '\n' вызывает
         перевод  в  начало  следующей строки. Если режим не
         задан, то курсор перемещается в ту же колонку  сле-
         дующей  строки. Для задания и отмены режима NL слу-
         жат соответственно функции nl() и nonl().

CRMODE - В этом режиме при вводе  символы  сразу  передаются
         программе, если режим не задан - только после нажа-
         тия клавиши <возврат каретки>. Для задания и отмены
         режима   CRMODE   служат   соответственно   функции
         crmode() и nocrmode().


   2.1.2. Режимы работы виртуального устройства


SCROLL - При заполнении последней колонки  последней  строки
         окна происходит СДВИГ информации в окне. Все строки
         перемещаются на одну вверх, а самая верхняя уничто-
         жается.  Если  режим  не  задан, то практически все
         подпрограммы  пакета  curses  возвращают  состояние
         ошибки  (значение  ERR)  при попытке СДВИГА экрана.
         Для  установки  (отмены)   режима   SCROLL   служит
         функция:



8

             scrollok (win, flg)
             WINDOW *win;
             bool flg;

         Значение TRUE  параметра  flg  устанавливает  режим
         SCROLL, а значение FALSE - отменяет.

LEAVE  - Если этот режим не задан, то после выдачи  содержи-
         мого  окна на экран, курсор на экране переводится в
         позицию, соответсвующую координатам текущей позиции
         в окне, с учетом его относительного расположения. В
         противном случае, курсор остается в той же позиции,
         а  меняется  значение текущих координат в окне. Для
         установки (отмены) режима LEAVE служит функция:

             leavelok (win, flg)
             WINDOW *win;
             bool flg;

         Значение TRUE  параметра  flg  устанавливает  режим
         LEAVE, а значение FALSE - отменяет.

CLEAR  - В этом режиме, при выдаче содержимого окна на экран
         происходит  очистка  экрана. Режим распространяется
         только на окна равные по размерам экрану (например,
         stdscr)  и отменяется очередной операцией wrefresh.
         Для установки (отмены) режима CLEAR служит функция:

             clearlok (win, flg)
             WINDOW *win;
             bool flg;

         Значение TRUE  параметра  flg  устанавливает  режим
         CLEAR, а значение FALSE - отменяет.


   2.2. Инициализация   работы   с   экраном    терминала
        (initscr)


ФОРМАТ:

    initscr ()


   Функция initscr заводит окно stdscr, копию экрана -  окно
curscr,  и настраивает пакет curses на функциональные харак-
теристики терминала, используя  файл  описаний  возможностей
терминалов  /etc/termcap. Для определения типа терминала ис-
пользуется макропеременная языка управления заданиями $TERM.

   Функция initscr возвращает значение ERR (ошибка)в  следу-
ющих случаях:

- если макропеременная  $TERM  не  определена  или  в  файле
  /etc/termcap   отсутствует  описание  терминала  заданного
  типа;

- устройство на которое отображается стандартный файл вывода
  не является терминалом;




                                                           9

- если не хватает памяти для заведения окон stdscr и curscr.


   2.3. Завершение работы с экраном терминала (endwin)


ФОРМАТ:

    endwin ();


   Функция endwin служит для завершения работы. Она устанав-
ливает  терминал  в состояние, в котором тот находился перед
началом  работы  (до  вызовов  функций   initscr,   setterm,
gettmode).


   2.4. Заведение нового окна (newwin)


ФОРМАТ:

    WINDOW *
    newwin (lines, cols, b_y, b_x);
    short lines, cols, b_y, b_x;


   Функция newwin создает новое окно размерами  lines  строк
на  cols колонок. Начальные координаты окна относительно на-
чала экрана устанавливаются равными b_y/b_x.  Если  значение
параметра  lines равно нулю, размеры окна по вертикали опре-
деляюся как LINES-b_y, соответственно, для размера по  гори-
зонтали - COLS-b_x. Таким образом, для определения окна рав-
ного по размерам экрану терминала правильнее всего использо-
вать вызов:

    newwin (0, 0, 0, 0);


   Функция newwin возвращает значение ERR, если:

- не хватает памяти для заведения окна;

- окно, с учетом размеров и относительного положения,  выхо-
  дит за границы экрана.


   2.5. Заведение подокна (subwin)


ФОРМАТ:

    WINDOW *
    subwin (orig, lines, cols, b_y, b_x);
    WINDOW *orig;
    short lines, cols, b_y, b_x;


   Функция subwin заводит подокно размерами lines  строк  на
cols колонок. Особенности подокна заключаются в том, что:




10

- для хранения символов, относящихся  к  нему,  используется
  буфер окна "родителя";

- для заведения подокна требуется меньше памяти;

- при изменении информации в подокне, изменяется и окно "ро-
  дитель".

   Начальные координаты подокна, относительно начальных  ко-
ординат  окна  orig,  устанавливаются  равными b_y/b_x. Если
значение параметра lines равно нулю, размеры подокна по вер-
тикали  определяюся  как  <число_строк_окна_orig>-b_y, соот-
ветственно     для     размера     по     горизонтали      -
<число_колонок_окна_orig>-b_x. Например, для определения по-
докна равного по размерам четверти окна stdscr с  началом  в
его центре правильнее всего использовать вызов:

    b_x = COLS/2;
    b_y = LINES/2;
    subwin (orig, 0, 0, b_y, b_x);


   Функция subwin возвращает значение ERR, если:

- не хватает памяти для заведения подокна;

- подокно, с учетом размеров и относительного положения, вы-
  ходит за границы окна orig.


   2.6. Уничтожение окна (delwin)


ФОРМАТ:

    delwin (win);
    WINDOW *win;


   Функция delwin "уничтожает" окно win, освобождая  память,
которая была под него захвачена. Если win является окном, то
уничтожаются все относящиеся к нему подокна.


   2.7. Перемещение окна (mvwin)


ФОРМАТ:

    mvwin (win, b_y, b_x);
    WINDOW *win;
    short b_y, b_x;


   Функция mvwin меняет значения  начальных  координат  окна
win  на значение b_y/b_x. Если win является окном, то значе-
ния координат меняются относительно начала экрана, если  win
является подокном - относительно начала окна "родителя".

   Функция mvwin возвращает значение ERR, если при изменении
начальных  координат окно win выйдет за границы экрана (окна
"родителя").


                                                          11

   2.8. Заключение окна в рамку (box)


ФОРМАТ:

    box (win, vert, hor);
    WINDOW *win;
    char vert, hor;


   Функция box создает рамку по границам окна win, используя
символ  vert для вертикальных сторон, и символ hor - для го-
ризонтальных. Если для данного окна установлен режим SCROLL,
то углы рамки остаются пустыми.


   2.9. Проецирование содержимого окна на экран терминала
        (wrefresh)


ФОРМАТ:

    refresh (); /* + */

    wrefresh (win);
    WINDOW *win;


   Функция wrefresh выдает на  экран  терминала  информацию,
относящуюся к окну win. Изменяется только часть экрана, пок-
рываемая окном (подокном) win. Одновременно корректируется и
копия  экрана - окно curscr. Функция refresh является анало-
гом wrefresh для окна stdscr.


   2.10. Перепись окон (overwrite)


ФОРМАТ:

    overwrite (win1, win2);
    WINDOW *win1, *win2;


   Функция overwrite переписывает информацию из окна win1  в
окно  win2.  Учитывается начальное положение и размеры окон,
если win1 "покрывает" лишь часть окна win2,  то  только  эта
часть и будет изменена.


   2.11. Наложение окон (overlay)


ФОРМАТ:

    overlay (win1, win2);
    WINDOW *win1, *win2;


   Функция overlay "накладывает" окно win1 на окно win2. Она
работает  аналогично функции overwrite, за исключением того,
что пробелы на окне win1 не  "затирают"  соответствующие  им


12

символы окна win2.


   2.12. Выделение символов (standout)


ФОРМАТ:

    standout (); /* + */

    wstandout (win);
    WINDOW *win;

    standend (); /* + */

    wstandend (win);
    WINDOW *win;


   Функции wstandout и wstandend соответственно "включают" и
"выключают"  режим выделения символов в окне win. В этом ре-
жиме все символы, которые будут записываться в окно win, при
последующей  выдаче этого окна на экран терминала выделяются
либо подчеркиванием, либо инверсией фона экрана. Способ  вы-
деления символов зависит от возможностей терминала.

   Функции standout  и  standend  являются  частным  случаем
функций  wstandout и wstandend и предназначены для изменения
режима выделения в окне stdscr.

   Все функции возвращают значение FALSE, если  терминал  не
имеет возможностей выделения символов.


   2.13. Получение  координат  текущей  позиции  в   окне
         (getyx)


ФОРМАТ:

    getyx (win, y, x); /* + */
    WINDOW *win;
    short y, x;


   Функция getyx возвращает значения текущих координат в ок-
не  win. Значение параметра y соответствует номеру строки, а
значение параметра x - номеру колонки.


   2.14. Записать символ (waddch)


ФОРМАТ:

    addch (ch) /* + */
    char ch;

    waddch (win, ch)
    WINDOW *win;
    char ch;



                                                          13


   Функция waddch записывает символ ch в окно win.  Значения
текущих  координат  увеличиваются на единицу, при этом может
происходить переход на новую  строку  или,  если  установлен
режим SCROLL, СДВИГ окна.

   Некоторые специальные  символы  обрабатываются  следующим
образом:

\n   Перевод в начало следующей строки, если был задан режим
     NL, или в ту же позицую в следущей строке.

\r   Перевод в начало текущей строки;

\b   Возврат на одну позицию назад;

\t   Переобразуется в соответствующее число пробелов, с уче-
     том табуляционной сетки с шагом восемь позиций.

   Функция addch - аналог waddch для окна stdscr.

   Обе функции возвращают значение ERR, если:

- значения текущих координат в окне win выходят за его  гра-
  ницы;

- не установлен режим SCROLL, и символ добавляется в послед-
  нюю колонку последней строки окна.


   2.15. Записать строку (waddstr)


ФОРМАТ:

    addstr (str) /* + */
    char *str;

    waddstr (win, str)
    WINDOW *win;
    char *str;


   Функция waddstr записывает строку str в окно win. Измене-
ние  текущих  координат  и  коды возврата аналогичны функции
waddch. Функция addstr - аналог waddstr для окна stdscr.


   2.16. Вставить символ (winsch)


ФОРМАТ:

    insch (ch) /* + */
    char ch;

    winsch (win, ch)
    WINDOW *win;
    char ch;





14

   Функция winsch вставляет символ ch в окно win. Символ по-
мещается  в  позицию  с текущими координатами. Все символы в
строке, начиная с этой колонки, смещаются  на  одну  позицию
вправо.   Текущие  координаты  остаются  неизменными.  Если,
вставка символа, вызывает заполнение последней колонки  пос-
ледней строки окна, то:

- происходит СДВИГ окна в режиме SCROLL;

- возвращается значение ERR, если режим SCROLL  не  установ-
  лен.

   Функция insch - аналог winsch для окна stdscr.


   2.17. Вставить пустую строку (winsertln)


ФОРМАТ:

    insertln () /* + */

    insertln (win)
    WINDOW *win;


   Функция winsertln вставляет пустую  строку  в  окно  win.
Значения  текущих координат не изменяются. Все строки, начи-
ная с текущей, смещаются  на  одну  вниз.  Последняя  строка
уничтожается.

   Функция insertln - аналог winsertln для окна stdscr.


   2.18. Стирание информации в окне (werase)


ФОРМАТ:

    erase () /* + */

    werase (win)
    WINDOW *win;


   Функция werase заполняет окно win пробелами. Текущие  ко-
ординаты  не  изменяются.  Функция erase - аналог werase для
окна stdscr.


   2.19. Стирание экрана (wclear)


ФОРМАТ:

    clear () /* + */

    wclear (win)
    WINDOW *win;





                                                          15

   Функция wclear заполняет окно win пробелами и, в  отличие
от функции werase, проставляет признак очистки экрана (режим
CLEAR). Текущие координаты не изменяются.  Функция  clear  -
аналог wclear для окна stdscr.


   2.20. Стeреть до конца окна (wclrtobot)


ФОРМАТ:

    clrtobot () /* + */

    wclrtobot (win)
    WINDOW *win;


   Функция wclrtobot стирает информацию в окне win от  теку-
щей позиции до конца окна. Значение текущих координат не из-
меняется.  Фунция  clrtobot  -  аналог  wclrtobot  для  окна
stdscr.


   2.21. Стереть до конца строки (wclrtoeol)


ФОРМАТ:

    clrtoeol () /* + */

    wclrtoeol (win)
    WINDOW *win;


   Функция wclrtoeol стирает  информацию  до  конца  текущей
строки в окне win. Значение текущих координат не изменяется.
Функция clrtoeol - аналог wclrtoeol для стандартного окна.


   2.22. Уничтожить символ (wdelch)


ФОРМАТ:

    delch () /* + */

    wdelch (win)
    WINDOW *win;


   Функция wdelch уничтожает символ в окне win. Значение те-
кущих координат не изменяется. Функция delch - аналог wdelch
для окна stdscr.











16

   2.23. Уничтожить строку (wdeleteln)


ФОРМАТ:

    deleteln () /* + */

    wdeleteln (win)
    WINDOW *win;


   Функция wdeleteln уничтожает текущую строку в  окне  win.
Все  последующие строки перемещаются на одну вверх. Значение
текущих координат не изменяется. Функция deleteln  -  аналог
wdeleteln для окна stdscr.


   2.24. Измененить значения текущих координат (wmove)


ФОРМАТ:

    move (y, x) /* + */
    short y, x;

    wmove (win, y, x)
    WINDOW *win;
    short y, x;


   Функция wmove меняет значения текущих  координат  в  окне
win. Функция move - аналог wmove для окна stdscr.

   Обе функции возвращают значение ERR, если значения  коор-
динат выходят за границы окна.


   2.25. Форматный вывод (wprintw)


ФОРМАТ:

    printw (fmt, args)
    char *fmt;
    int  args;

    mvprintw (y, x, fmt, args)
    short y, x;
    char *fmt;
    int  args;

    wprintw (win, fmt, args)
    WINDOW *win;
    char *fmt;
    int  args;

    mvwprintw (win, y, x, fmt, args)
    WINDOW *win;
    short y, x;
    char *fmt;
    int  args;



                                                          17


   Функция wprintw выдает по формату fmt  параметры  args  в
окно win. Задание формата и параметров осуществляется анало-
гично стандартной функции языка Си printf. Функция mvwprintw
перед  выдачей  меняет  значения  текущих  координат на y/x.
Функции printw и mvprintw являются аналогами,  соответствен-
но, функций wprintw и mvwprintw для окна stdscr.


   2.26. Получить символ из текущей позиции (winch)


ФОРМАТ:

    inch () /* + */

    winch (win) /* + */
    WINDOW *win;


   Функция winch служит для получения символа с текущими ко-
ординатами из структуры WINDOW, относящейся к окну win.


   2.27. Считать символ с экрана терминала (wgetch)


ФОРМАТ:

    getch () /* + */

    wgetch (win)
    WINDOW *win;


   Функция wgetch возвращает символ, считанный с экрана тер-
минала.  Если  установлен режим ECHO символ высвечивается на
экране и заносится в структуру WINDOW, отведенную  под  окно
win. В противном случае символ не попадает ни на экран, ни в
структуру WINDOW, относящуюся к данному окну.

   Следует отметить, что ввод происходит из позиции, в кото-
рой остался курсор после последнего вызова функции wfefresh.
Если выдавалось не это окно, то корректность изображения  на
экране не гарантируется.

   Функция getch - аналог wgetch для окна stdscr.

   Обе функции возвращают значение ERR, если для окна win не
задан  режим  SCROLL,  и ввод происходит в последнюю колонку
последней строки.


   2.28. Считать строку с экрана терминала (wgetstr)


ФОРМАТ:

    getstr (str) /* + */
    char *str;

    wgetstr (win, str)


18

    WINDOW *win;
    char *str;


   Функция wgetstr считывает с экрана строку str.  Признаком
конца  строки  при  вводе  является  символ '\n' (new line).
Строка str дополняется нулевым байтом.

   Функция getstr - аналог wgetstr для окна stdscr.


   2.29. Форматный ввод (wscanw)


ФОРМАТ:

    scanw (fmt, args)
    char *fmt;
    int  args;

    mvscanw (y, x, fmt, args)
    short y, x;
    char *fmt;
    int  args;

    wscanw (win, fmt, args)
    WINDOW *win;
    char *fmt;
    int  args;

    mvwscanw (win, y, x, fmt, args)
    WINDOW *win;
    short y, x;
    char *fmt;
    int  args;


   Функция wscanw считывает данные из окна  win  по  формату
fmt.  Задание формата и параметров осуществляется аналогично
стандартной функции языка Си scanf. Функция  mvwscanw  перед
вводом  меняет  значения  текущих  координат на y/x. Функции
scanw и mvscanw являются аналогами функций wscanw и mvwscanw
для окна stdscr.





















                                                          19




               3. ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ


   В пакете curses имеются две подпрограммы,  которые  можно
использовать автономно. Подпрограмма:

    setterm (tty_name)
    char* tty_name;

предназначена для работы  с  файлом  описаний  характеристик
терминалов и, в зависимости от описания терминала tty_name в
файле /etc/termcap, определяет ряд  переменных,  необходимых
для  работы  пакета.  Если описание какого-либо свойства от-
сутствует,  то  значение  соответствующей  переменной  будет
равно нулю. Эта подпрограмма вызывается функцией initscr.

   В табл. 2 приводится список переменных, которые  устанав-
ливаются  функцией setterm. Звездочкой (*) помечены перемен-
ные, которые могут использоваться пакетом  curses,  а  двумя
звездочками  (**)  -  переменные, задание которых необходимо
для правильной работы пакета.

                                                   Таблица 2

              Переменные, определяемые setterm

------------------------------------------------------------
ТИП    ИМЯ     ОПИСАНИЕ
------------------------------------------------------------
char*  AL      вставить пустую строку;
bool   AM  **  терминал автоматически переходит на следующую
               строку при достижении конца текущей;
char*  BC  **  курсор назад (если не ^H);
bool   BS  **  терминал имеет код "шаг назад" (^H);
char*  BT      шаг табуляции назад;
char*  CA  **  терминал имеет возможность адресации курсора;
char*  CD  *   очистка экрана от текущей  позиции  до  конца
               экрана;
char*  CE  *   очистка строки от текущей позиции до конца;
char*  CL  **  очистка экрана;
char*  CM  **  способ адресации курсора;
char*  CR  **  возврат каретки  в  начало  строки,  если  не
               символ (^M);
char*  DA      терминал сохраняет строки, сдвинутые вверх за
               границу экрана;
char*  DB      терминал сохраняет строки, сдвинутые вниз  за
               границу экрана;
char*  DC      исключить символ;
char*  DL      исключить строку;
char*  DM      переход в режим исключения символов;
char*  DO  *   курсор вниз на одну строку;
char*  ED      конец режима исключения символов;
char*  EI      конец режима вставки символов;
bool   EO      пробел стирает наложенные символы;
char*  HO  **  курсор в начало экрана ("home");
------------------------------------------------------------





20


                                       Продолжение таблицы 2

------------------------------------------------------------
ТИП    ИМЯ     ОПИСАНИЕ
------------------------------------------------------------
char*  IC      вставить символ;
char*  IN      в режиме вставки символы "пробел"  и  "пусто"
               различаются;
char*  IM      включение режима вставки символов;
bool   IN      в режиме вставки символы "пробел"  и  "пусто"
               различаются;
char*  IP      код, выдаваемый после вставки символа;
char*  LL  **  переход в первую колонку последней строки;
bool   MI  *   признак того, что в режиме вставки можно дви-
               гать курсор;
bool   MS  **  возможность движения курсора в режиме выделе-
               ния;
bool   NC  **  запрет  на  использование  символа   "перевод
               строки" (^J);
char*  ND  *   курсор вправо;
char*  NL  **  как выдать  "перевод  строки"  (по  умолчанию
               ^J);
bool   OS      терминал допускает наложение символов;
char*  PC  **  символ-заполнитель (по умолчанию \000);
char*  SE  *   выключение режима выделения текста;
char*  SF      прокрутка текста вперед;
char*  SO  *   установка режима выделения текста;
char*  SR      прокрутить текст назад (снизу вверх);
char*  TA  **  символ табуляции (если не ^I);
char*  TE  **  конец режима адресации курсора;
char*  TI  **  начало режима адресации курсора;
char*  UC  *   подчеркивание одного символа;
char*  UE  *   конец режима подчеркивания;
bool   UL  *   возможно подчеркивание символов;
char*  UP  **  курсор вверх;
char*  US  *   включение режима подчеркивания;
char*  VB      видимый аналог звукового сигнала;
char*  VE  *   выключение режима выделения;
char*  VS  *   включение режима выделения;
bool   XN  **  перевод  строки   игнорируется   после   кода
               "возврат каретки" (^M);
------------------------------------------------------------

   Перечисленные переменные используются подпрограммой:

    mvcur (inline, incol, outline, outcol)
    short inline, incol, outline, outcol;

которая служит для оптимального перемещения курсора на экра-
не    терминала    из   позиции   inline/incol   в   позицию
outline/outcol.   Эта   подпрограмма   вызывается   функцией
wrefresh.

   В ряде случаев, когда структура  отображаемой  на  экране
информации  несложна,  можно  создавать программы, используя
только предложенные в этом  разделе  функции.  В  приложении
приводится пример такой программы.






                                                          21


     ПРИЛОЖЕНИЕ 1


   Приводится написанный  двумя  способами  демонстрационный
тест  работы  пакета curses. По углам экрана последовательно
рисуются квадратные рамки,  а  в  середине  экрана  -  слово
Demos.  Затем  все  стирается  в обратном порядке. И рамки и
слово изображаются с помощью символа звездочка (*). Схемати-
чески рисунок выглядит так:

                     ---------------------
                     |...             ...|
                     |. .             . .|
                     |...             ...|
                     |       Demos       |
                     |...             ...|
                     |. .             . .|
                     |...             ...|
                     ---------------------


   Первая программа  написана  с  использованием  нескольких
функций  пакета  curses,  вторая  только  с  помощью функций
setterm и mvcur. Текст программы 1 короче, более  понятен  и
не  требует глубоких знаний методов работы с терминалом. Тем
не менее, после трансляции  программы  2  получается  модуль
вдвое меньших размеров (с учетом того, в программе 1 динами-
чески захватывается память под окна).



































22

Программа 1
------------------------------------------------------------

# include <curses.h>
    /* Описание глобальных переменных
     * пакета curses.
     */

# include <signal.h>
    /* Описание сигналов допустимых
     * в ОС ДЕМОС.
     */

# define NC 4   /* Размер рамок в углах */
# define NL 4   /* ЭКРАНА.              */

# define MAX 10
    /* Число повторений картинки.       */

/* Задание символов. */
char *D[] = {
   "***  ","     ","     ","     ","     ",
   "*  * "," *** ","*   *"," *** "," *** ",
   "*   *","*   *","** **","*   *","*    ",
   "*   *","**** ","* * *","*   *"," *** ",
   "*  * ","*    ","*   *","*   *","    *",
   "***  "," *** ","*   *"," *** ","**** ",
};

# define VER 6  /* Размер символов. */
# define HOR 5
# define COU 5  /* Число символов. */

main()
{
   WINDOW *w[4],*d[5];
   short y[4],x[4];
   short Y,X,die();
   reg short i,j;

/* Инициализация экранной работы. */
   initscr();
/* Реакция на прерывания. */
   signal(SIGINT,die);
/* Отмена режима ECHO */
   noecho();

/* Вычисление начальных координат
 * рамок и первого символа.
 */
   y[0]=y[1]=0;
   x[0]=x[2]=0;
   y[2]=y[3]=LINES-NL-1;
   x[1]=x[3]=COLS-NC-1;
   Y=(LINES-VER)/2;
   X=(COLS-(HOR*COU+(COU-1)))/2;

/* Выделение ПОДОКОН для всех рамок.
 * Каждому подокну устанавливается
 * режим LEAVE.
 */
   for(i=0;i<4;i++) {


                                                          23

      w[i]=subwin(stdscr,NL,NC,y[i],x[i]);
      leaveok(w[i],TRUE);
   }

/* Выделение ПОДОКОН для всех символов.
 * Начальные координаты вычисляются от
 * координат первого символа.
 * Каждому подокну устанавливается
 * режим LEAVE.
 */
   for(i=0;i<COU;i++) {
      j=X+VER*i+i;
      d[i]=subwin(stdscr,VER,HOR,Y,j);
      leaveok(d[i],TRUE);
   }

/* Рисуем картинку. */
   for(j=0;j<MAX;j++) {

   /* Рисуем рамки по углам ЭКРАНА. */
      for(i=0;i<4;i++) {
         box(w[i],'*','*');
         wrefresh(w[i]);
      }

   /* Рисуем символы. */
      for(i=0;i<COU;i++)
         PutChar(d[i],i);

   /* Стираем символы в обратном порядке. */
      for(i=COU-1;i>=0;i--) {
         werase(d[i]);
         wrefresh(d[i]);
      }

   /* Стираем рамки в обратном порядке. */
      for(i=3;i>=0;i--) {
         werase(w[i]);
         wrefresh(w[i]);
      }
   }
   die ();
}

/* Завершение процесса. */
die()
{
/* Игнорировать последующие прерывания. */
   signal(SIGINT,SIG_IGN);

/* Стирание ЭКРАНА. */
   clear();
   refresh();

/* Возврат курсора в начало. */
   mvcur(0,0,0,0);

/* Завершение работы с экраном. */
   endwin();

/* Возврат. */
   exit(0);


24

}

/* Функция PutChar рисует символ в окне win
 * и выдает рисунок на ЭКРАН.
 */
PutChar(win,num)
WINDOW *win;
reg short num;
{
   reg short i;

   for(i=0;i<VER;i++) {
      wmove(win,i,0);
      waddstr(win,D[num+COU*i]);
   }
   wrefresh(win);
}















































                                                          25

                                                 Программа 2
------------------------------------------------------------

# include <curses.h>
    /* Описание глобальных переменных
     * пакета curses.
     */
# include <signal.h>
    /* Описание сигналов допустимых
     * в ОС ДЕМОС.
     */

# define NC 4   /* Размер рамок в углах */
# define NL 4   /* ЭКРАНА.              */

# define MAX 10
    /* Число повторений картинки.       */

/* Задание символов. */
char *D[]={
   "***  ","     ","     ","     ","     ",
   "*  * "," *** ","*   *"," *** "," *** ",
   "*   *","*   *","** **","*   *","*    ",
   "*   *","**** ","* * *","*   *"," *** ",
   "*  * ","*    ","*   *","*   *","    *",
   "***  "," *** ","*   *"," *** ","**** ",
};

# define VER 6  /* Размер символов. */
# define HOR 5
# define COU 5  /* Число символов. */

short y[4],x[4],Y,X;
short ly,lx;

main()
{
   reg short i,j;
   short die();
   char* term,getenv(),_putchar();

/* Инициализация экранной работы. */
   if(isatty(1)) {
      if((term=getenv("TERM"))!=0) {
         setterm(term);
         signal(SIGINT,die);
      }
      else Error();
   }
   else Error();

   _puts(TI);
       /* Начало режима адресации курсора */
   _puts(VS);
       /* Включение режима выделения */

   mvcur(ly,lx,0,0);
       /* Перевод курсора в начало экрана */
   tputs(CL,LINES,_putchar);
       /* Гашение экрана */

/* Вычисление начальных координат


26

 * рамок и первого символа.
 */
   y[0]=y[1]=0;
   x[0]=x[2]=0;
   y[2]=y[3]=LINES-NL-1;
   x[1]=x[3]=COLS-NC-1;
   Y=(LINES-VER)/2;
   X=(COLS-(HOR*5+4))/2;

/* Рисуем картинку. */
   for(j=0;j<MAX;j++) {

   /* Рисуем рамки по углам ЭКРАНА. */
      for(i=0;i<4;i++)
         Box(i,'*','*');

   /* Рисуем символы. */
      for(i=0;i<5;i++)
         PutChar(i);

   /* Стираем символы в обратном порядке. */
      for(i=4;i>=0;i--)
         ClearChar(i);

   /* Стираем рамки в обратном порядке. */
      for(i=3;i>=0;i--)
         Box(i,' ',' ');
   }
   die ();
}

/* Завершение процесса. */
die()
{
/* Игнорировать последующие прерывания. */
   signal(SIGINT,SIG_IGN);

/* Стирание ЭКРАНА. */
   mvcur(ly,lx,0,0);
   tputs(CL,LINES,_putchar);

/* Завершение работы с экраном. */
   _puts(VE);
   _puts(TE);

/* Возврат */
   exit(0);
}

/* Функция ClearChar стирает символ */
ClearChar(num)
reg short num;
{
   reg short i,j;

   j=X+VER*num+num;
   for(i=0;i<VER;i++) {
      mvcur(ly,lx,Y+i,j);
      puts("     ");
      ly=Y+i;
      lx=j+HOR+1;
   }


                                                          27

}

/* Функция PutChar рисует символ */
PutChar(num)
reg short num;
{
   reg short i,j;

   j=X+VER*num+num;
   for(i=0;i<VER;i++) {
      mvcur(ly,lx,Y+i,j);
      puts(D[num+5*i]);
      ly=Y+i;
      lx=j+HOR+1;
   }
}

Box (num,vert,hor)
reg short num;
char vert,hor;
{
   reg short i,j;

   for(i=0;i<NL;i++) {
      mvcur(ly,lx,(y[num]+i),x[num]);
      if(i==0 || i==NL-1)
         for(j=0;j<NC;j++)
            putchar(hor);
      else
         for(j=0;j<NC;j++)
            if(j==0 || j==NC-1)
               putchar(vert);
            else putchar(' ');
      ly=y[num]+i;
      lx=x[num]+NC+1;
   }
}

Error()
{
   printf ("Need a tty on stdout\n");
   exit(1);
}





















28



                         СОДЕРЖАНИЕ



ВВЕДЕНИЕ...............................................    2

1.  ОБЩИЕ СВЕДЕНИЯ.....................................    3

2.  ОПИСАНИЕ ФУНКЦИЙ...................................    5
    2.1. Режимы ввода/вывода...........................    8
    2.1.1. Режимы работы физического устройства........    8
    2.1.2. Режимы работы виртуального устройства.......    8
    2.2. Инициализация  работы  с   экраном   терминала
         (initscr).....................................    9
    2.3. Завершение   работы   с   экраном    терминала
         (endwin)......................................   10
    2.4. Заведение нового окна (newwin)................   10
    2.5. Заведение подокна (subwin)....................   10
    2.6. Уничтожение окна (delwin).....................   11
    2.7. Перемещение окна (mvwin)......................   11
    2.8. Заключение окна в рамку (box).................   12
    2.9. Проецирование содержимого окна на экран терми-
         нала (wrefresh)...............................   12
    2.10.Перепись окон (overwrite).....................   12
    2.11.Наложение окон (overlay)......................   12
    2.12.Выделение символов (standout).................   13
    2.13.Получение координат  текущей  позиции  в  окне
         (getyx).......................................   13
    2.14.Записать символ (waddch)......................   13
    2.15.Записать строку (waddstr).....................   14
    2.16.Вставить символ (winsch)......................   14
    2.17.Вставить пустую строку (winsertln)............   15
    2.18.Стирание информации в окне (werase)...........   15
    2.19.Стирание экрана (wclear)......................   15
    2.20.Стeреть до конца окна (wclrtobot).............   16
    2.21.Стереть до конца строки (wclrtoeol)...........   16
    2.22.Уничтожить символ (wdelch)....................   16
    2.23.Уничтожить строку (wdeleteln).................   17
    2.24.Измененить    значения    текущих    координат
         (wmove).......................................   17
    2.25.Форматный вывод (wprintw).....................   17
    2.26.Получить символ из текущей позиции (winch)....   18
    2.27.Считать символ с экрана терминала (wgetch)....   18
    2.28.Считать строку с экрана терминала (wgetstr)...   18
    2.29.Форматный ввод (wscanw).......................   19

3.  ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ.........................   20

ПРИЛОЖЕНИЕ 1...........................................   22













                                                          29

