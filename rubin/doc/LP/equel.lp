

                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL










         000000000000   00     00  00000000000000  00     00  00     00
         00     00  00     00  00        00     00  00     00
         00     00  00     00  00        00   00 00  00     00
         000000000000    000000000000  000000000000   00  00  00  00000000000000
         00              00  00     00  00 00   00  00     00
         00              00  00     00  00     00  00     00
         00        000000000000   000000000000   00     00  00     00






      СС ИИ СС ТТ ЕЕ ММ АА   УУ ПП РР АА ВВ ЛЛ ЕЕ НН ИИ ЯЯ   ББ АА ЗЗ ОО ЙЙ
                  ДД АА НН НН ЫЫ ХХ   РР УУ ББ ИИ НН


                          ВЕРСИЯ 2
           П Р О Г Р А М М И Р О В А Н И Е   Н А
                   Я З Ы К Е    E Q U E L

















                       ММоосскквваа 77//2244//8899

















                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


11..  ВВВВЕЕДДЕЕННИИЕЕ.. ЧЧТТОО ТТААККООЕЕ EEQQUUEELL


     Язык EEQQUUEELL -"встроенный (embedded) QUEL" является  язы-
ком  манипулирования  данными системы РРУУББИИНН. EQUEL встроен в
язык Си и обеспечивает доступ программ, написанных на  языке
Си, ко всем возможностям СУБД. Он представляет собой некото-
рое расширение языка Си, в который встроены операторы  языка
манипулирования  данными QQUUEELL, операторы управления системой
РРУУББИИНН и операторы описания.

     Программа, написанная на  языке  EQUEL,  обрабатывается
прекомпилятором   eeqquueell,  затем  транслируется  обычным  Си-
компилятором с использованием библиотеки служебных  программ
lliibbqq..aa.   При  выполнении  оператора  вызова СУБД вызывается
ядро СУБД РУБИН и начинает взаимодействовать с программой  с
помощью  программных каналов (скрыто от программиста). После
вызова СУБД программа может выдавать операторы манипулирова-
ния  данными  и  операторы  запроса  данных, и таким образом
обменивается информацией с базой данных.

     Обычно (при вызове с терминала) СУБД РУБИН  состоит  из
терминального  монитора и ядра, которые взаимодействуют сле-
дующим образом:


          <      Т  е  р  м  и  н  а  л        >        <  -  -  -  -  -  -  -  -  -  -  -  -  -  -  +
                      !    !                                                  ^
                      !    !                                                  !
        <    Т  е  р  м  и  н  а  л  ь  н  ы  й    м  о  н  и  т  о  р    >                      !
                      !    !                                                  !
                      !    !                                                  !
        <    Я  д  р  о    С  У  Б  Д    Р  У  Б  И  Н    >  -  -  -  -  -  д  а  н  н  ы  е  -  -  -  >  +



При вызове задачи, написанной на EQUEL, она заменяет  терми-
нальный монитор:

          [    <      Т  е  р  м  и  н  а  л        >    ]
                            !      !                                          ^
                            !      !                                          !
            <    П  р  о  г  р  а  м  м  а    н  а    E  Q  U  E  L       >                  !
                            !      !                                          !
          <    я  д  р  о    С  У  Б  Д    Р  У  Б  И  Н    >  -  -  -  -  д  а  н  н  ы  е  -  -  -  >  +


















                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


11..11..  ППооддггооттооввккаа ппррооггррааммммыы ннаа EEQQUUEELL

     Программа на EQUEL представлет собой смесь операторов и
описаний  EQUEL,  которые начинаются с двух символов "##", и
обычных операторов языка Си, и размещается в одном или  нес-
кольких  файлах  с расширением ".q".  Трансляция осуществля-
ется в несколько этапов.  Сначала  программа  обрабатывается
прекомпилятором  eeqquueell,  который  заменяет конструкции языка
EQUEL на обращения к соответствующим библиотечным функциям и
переписывает остальные строки программы без изменения:

     eeqquueell [_ф_л_а_г_и] _f_i_l_e_1.q [_ф_л_а_г_и] [_f_i_l_e_2.q] ...

(флаги описаны в справочном руководстве по СУБД РУБИН,  раз-
дел  eeqquueell((ddeemmooss))).  Результат записывается в файлы _f_i_l_e_1.c,
_f_i_l_e_2.c ...  Затем они компилируются транслятором языка Си с
использованием библиотеки языка EQUEL:

     cccc [_ф_л_а_г_и] _f_i_l_e_1.c ... --llqq

(возможна отдельная трансляция и редактирование связей, но в
любом случае должна быть подключена библиотека --llqq или заме-
няющая ее.)

     При программировании  на  EQUEL  некоторые  ограничения
налагаются  и  на  всю программу на языке Си, которая должна
вполне определенным образом обрабатывать прерывания с терми-
нала  и ошибки, возникающие при выполнении операторов EQUEL.
Кроме того,  глобальные  переменные  и  служебные  программы
EQUEL  начинаются  с символов II..., и такие имена не должны
применяться пользователем EQUEL.

11..22..  ППррооссттоойй ппррииммеерр

     Ниже будет рассмотрена простейшая  программа  на  языке
EQUEL.

    /*
    *  Это простой пример программы на EQUEL.
    *  Она работает с отношением СЛУЖАЩИЕ в
    *  базе данных "demo".
    *  После вызова программы введите фамилию
    *  служащего, и программа либо
    *  выдаст его оклад, либо сообщение о том,
    *  что такого служащего нет.
    *  Список служащих можно получить, набрав
    *  "?" в ответ на запрос имени.
    *
    *  Для выхода введите CTRL/D.
    *
    *  Трансляция и запуск этой программы на
    *  счет осуществляются
    *  командами:
    *
ВВВВЕЕДДЕЕННИИЕЕ.. ЧЧТТОО ТТААККООЕЕ EEQQUUEELL                                  22








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


    *  equel equeldemo.q
    *  cc    equeldemo.c -lq
    *  a.out
    */
    main(ac,av)
    int ac;
    /* 1.!Это пометка для данной инструкции!*/
    ##char *av[];
    {
    ##  char    NAME[20];
    ##  int     SAL;
        char    flag;
        if ( ac != 2)
    /* 2. */
    ##  rubin demo
        else
    /* 3. */
    ##  rubin av[1]
    /* 4. */
    ##  range of e is служащие
        while (eread(NAME))
        {
          if(NAME[0] == '?')
          {
    /* 5. */
    ##       print СЛУЖАЩИЕ
           continue;
           }
           flag = 0;
    /* 6. */
    ##   retrieve (SAL = e.оклад) where
    /* 7. */
    ##    e.имя = NAME
    /* 8. */
    ##    {
    printf("Тов. %s имеет оклад %d руб.\n",NAME,SAL);
             flag = 1;
    /* 9. */
    ##    }
        if(!flag)
    printf("Тов. %s неизвестен системе\n",NAME);
        }
    /* 10. */
    ##  exit
    }

    eread(p)
    char    *p;
    {
      int    c;
      printf("Введите имя служащего:");
      while((c = getchar()) > 0)
      {
              if(c == '\n')
33                                  ВВВВЕЕДДЕЕННИИЕЕ.. ЧЧТТОО ТТААККООЕЕ EEQQUUEELL








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


              {
                      *p = 0;
                      return(1);
              }
              *p++ = c;
      }
      return(0);
    }


     На примере данной программы рассмотрим простейшие  опе-
раторы EQUEL.  Все строки, относящиеся к EQUEL, начинаются с
"##". Первой такой строкой  является  строка,  следующая  за
комментарием  /*  1.  */  Это пример оператора описания - он
сообщает прекомпилятору о том, что описанная в нем  перемен-
ная является переменной EQUEL и может встречаться в последу-
ющих операторах языка.

     Номером /* 2. */ помечен  первый  исполняемый  оператор
EQUEL.  Как и следовало ожидать, этот оператор вызывает СУБД
и открывает базу данных  ddeemmoo.   В  данном  случае  оператор
просто  записан  в строке и выполняется без всяких подстано-
вок. А как же быть, если что-то  в  нем  неизвестно  заранее
(например,  это  может  быть имя базы данных)? В этом случае
как раз  и  используются  описанные  ранее  переменные,  что
иллюстрирует  строка  /* 3. */: в качестве имени базы данных
здесь используется имя символьной переменной  EQUEL,  и  при
выполнении  происходит  подстановка значения этой переменной
(в данном случае оно подставляется  в  качестве  имени  базы
данных).

     Строки /* 4. */ и /* 5. */ еще раз иллюстрируют принцип
языка  EQUEL - большинство операторов QUEL может быть просто
записано в EQUEL вслед за  двумя  символами  "##"  в  начале
строки.  При этом имена переменных EQUEL будут, как правило,
заменяться их текущим значением.

     Но как же программа получает информацию  из  базы?  Это
иллюстрируется  оператором  в  строках /* 6. */ - /* 9. */ -
оператором выборки rreettrriieevvee  без  результирующего  отношения
(эквивалентным выводу на экран при работе в мониторе). Такой
оператор состоит из запроса (строки 6, 7) и блока операторов
языка Си, взятого в скобки "##{", "##}" (строки 8 - 9).  Для
каждого выбранного в операторе кортежа производится присваи-
вание  полученных  значений переменным из списка результатов
(в данном случае значение присваивается переменной SSAALL,  см.
строку  6)  и  выполняется блок Си-программы между скобками.
Можно заметить также, что в строке  7  в  начале  выполнения
запроса в него подставляется значение переменной NNAAMMEE.

     И, наконец, работа СУБД завершается оператором "##exit"
(строка 10).  Конечно, такой пример крайне примитивен, но он
все-таки позволяет получить некоторое представление  о  том,
что же такое EQUEL.
ВВВВЕЕДДЕЕННИИЕЕ.. ЧЧТТОО ТТААККООЕЕ EEQQUUEELL                                  44








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


22..  ООССННООВВННЫЫЕЕ ППООННЯЯТТИИЯЯ


22..11..  ППррооггррааммммаа ннаа яяззыыккее EEQQUUEELL

     Программа на языке EQUEL состоит из смеси  произвольных
операторов языка Си, которые просто переписываются прекомпи-
лятором без изменений, и операторов  EQUEL,  начинающихся  с
символов  "##"  в начале строки.  При этом EQUEL не анализи-
рует синтаксическую правильность строк на Си, и любые ошибки
в ней выявляются на этапе трансляции.

     Операторы EQUEL делятся на следующие группы:

     - Операторы описания переменных EQUEL;

     - Выполняемые операторы; часть этих  операторов  просто
       повторяет  соответствующие  конструкции  языка  QUEL,
       имеются также операторы  вызова  и  окончания  работы
       СУБД,  операторы выбора данных и параметрические опе-
       раторы, отличающиеся  от  обычных  другим  механизмом
       подстановки значений переменных;

     - Операторы начала и конца блока Си, которые  использу-
       ются  для  ограничения  области действия переменных и
       выделения Си-блока в операторах выбора.

22..22..  ББааззооввыыее ккооннссттррууккццииии яяззыыккаа

     Предложения языка (кроме описаний  переменных)  состоят
из  ключевых слов и символов пунктуации языка QUEL, имен (не
совпадающих с именами переменных либо замаскированных), имен
переменных  и  констант.  Ниже будут разобраны все эти поня-
тия.

22..22..11..  ППееррееммеенннныыее,, иихх ттииппыы ии ооппииссаанниияя

     Все переменные Си, значения которых используются в опе-
раторах EQUEL, должны быть предварительно описаны.  Описание
представляет собой обычный оператор описания языка Си, перед
которым  (с  начала строки) вставлен префикс "####".  Возможны
следующие варианты:

     #### cchhaarr        _с_п_и_с_о_к__о_п_и_с_а_н_и_й;;
     #### sshhoorrtt       _с_п_и_с_о_к__о_п_и_с_а_н_и_й;;
     #### iinntt         _с_п_и_с_о_к__о_п_и_с_а_н_и_й;;
     #### lloonngg        _с_п_и_с_о_к__о_п_и_с_а_н_и_й;;
     #### ffllooaatt       _с_п_и_с_о_к__о_п_и_с_а_н_и_й;;
     #### ddoouubbllee      _с_п_и_с_о_к__о_п_и_с_а_н_и_й;;

Приведенные операторы определяют переменные целого и плаваю-
щего  типов.  _С_п_и_с_о_к__о_п_и_с_а_н_и_й составляется по правилам языка
Си, но возможность образования сложных типов (массивов, ука-
зателей  и т.п.) ограничена. Возможны следующие сложные типы
55                                  ВВВВЕЕДДЕЕННИИЕЕ.. ЧЧТТОО ТТААККООЕЕ EEQQUUEELL








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


данных:

      _и_м_я     - простой (скалярный) тип;
     **_и_м_я     - указатель;
      _и_м_я[[]]   - массив, длина массива может быть опущена;
     **_и_м_я[[]]   - массив указателей
                а также простейшие комбинации вида **имя,
                **имя[] и т.п...

Все остальные варианты запрещены, а переменные типа char  не
могут  быть скалярными переменными, так как этот тип исполь-
зуется для хранения строк. Не существует также никакого спо-
соба описать переменную, аналогичную формату i1 СУБД РУБИН.

     Кроме того, могут быть описаны структуры:

     #### ssttrruucctt [_и_м_я__с_т_р_у_к_т_у_р_ы] {{
     #### _о_п_и_с_а_н_и_я _э_л_е_м_е_н_т_о_в _с_т_р_у_к_т_у_р_ы
     ...
     #### }} _с_п_и_с_о_к__о_п_и_с_а_н_и_й;;

Ограничения на сложные формы описаний  аналогичны  вышепере-
численным.  Вложенные структуры не допускаются.

     Допустимы описания размещения объектов:  extern,  auto,
static.   Инициализируемые  переменные описываются следующим
образом:

     #### _т_и_п _с_п_и_с_о_к__о_п_и_с_а_н_и_й ==
      _и_н_и_ц_и_а_л_и_з_а_ц_и_я;;

Заметим, что вторая и последующие строки здесь не  обрабаты-
ваются  прекомпилятором.  Помещение  списка  инициализаций в
одну строку с описанием переменной, равно как и вынос  знака
"=" на следующую строку, ззааппрреещщеенныы.

     Все операторы описания прекомпилятор после обработки  и
удаления начальных "##" помещает в выходной файл на Си.

     Данные типа дата и время  хранятся  в  переменных  типа
long,  а  для  их ввода и вывода в библиотеку EQUEL включены
специальные функции преобразования (см. ниже раздел "Функции
преобразования. Работа с датой и временем").

     Для лучшего соответствия между описаниями в EQUEL  и  в
базе,    в    стандартный   файл   вставок   "   #   include
<rubin/equel.h>" и в прекомпилятор EQUEL включены  следующие
описания типов:

     typedef short  EQ_i2;
     typedef long   EQ_i4;
     typedef float  EQ_f4;
     typedef double EQ_f8;
     typedef long   EQ_date;
ООССННООВВННЫЫЕЕ ППООННЯЯТТИИЯЯ                                           66








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


     typedef long   EQ_time;

Эти типы могут использоваться в программе  наряду  со  стан-
дартными (если включен файл вставок "<rubin/equel.h>").

     Следует иметь в виду следующие ограничения:

     -  EQUEL  не  обрабатывает  операторы  CPP  (  #define,
       #include, #ifdef ...)

     - Имена переменных не должны совпадать с ключевыми сло-
       вами языка QUEL (записанными строчными буквами);

     Область действия переменных может быть ограничена  бло-
ком языка Си, если этот блок ограничен скобками EQUEL:

     ####{{ -- начало блока
     ####}} -- конец  блока

Такие скобки обрабатываются прекомпилятором и затем трансли-
руются в обычные скобки языка Си: "{" и "}".

     Формальные параметры могут быть описаны, как и  обычные
переменные,  но  они  будут иметь в EQUEL глобальную область
действия, поскольку не существует способа взять их в скобки.

     Примеры корректных описаний:

     ## extern long YEAR;
     ## static char NAME[MAXLEN], *myptr;
     ## char *av[];
     ## struct xxx { char nm[41];
     ## double fff;
     ## int num; } **ps;
     ## char *base =
     "mybase";

Примеры некоректных описаний:

     ## char l; -- Не допускается простой тип char
     ## long *fun();  -- Не допускаются функции
     ## int len = 10; -- Инициализация прямо в строке
     ## new_type xx;  -- не допускаются неизвестные типы
     ## struct { struct dir *d; } ppl;
        -- Не допускаются вложенные структуры









77                                           ООССННООВВННЫЫЕЕ ППООННЯЯТТИИЯЯ








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


22..22..22..  ККооннссттааннттыы

     Синтаксис констант EQUEL сходен с синтаксисом  констант
в  языке  QUEL.  Допускаются целые, вещественные и строковые
константы.  Не допускаются константы типа ДАТА  и  ВРЕМЯ,  а
также  форматы  констант,  допустимые  в Си и недопустимые в
QUEL.

22..22..33..  ППррааввииллаа ппооддссттааннооввккии ппееррееммеенннныыхх

     Все  выполняемые  операторы  EQUEL  представляют  собой
некоторое  расширение  операторов  языка  QUEL, записанных с
префиксом "##".  Почти везде, где допускаются  имена,  могут
быть  подставлены переменные либо простейшие выражения стро-
кового (char *)  типа из этих переменных. Везде, где в  QUEL
допускаются константы, в EQUEL могут быть использованы прос-
тейшие выражения строкового, целого или вещественного  типа.
Если  в операторе нужно явно указать имя, совпадающее с име-
нем существующей переменной, перед этим именем  нужно  доба-
вить символ "#" (замаскировать имя).

     Выражения могут содержать только имя_переменной, опера-
торы    (унарные)    "*"   и   "->",   операцию   индексации
[целое_выражение]; запрещено  использование  скобок  "()"  и
других операций.

     Например, пусть имеется следующее описание:

     ## char *p;
     ## struct xxx
     ## {
            int i;
     ##     char *px;
     ##     int *ip;
     ## }  **str_var;

Следующие операторы будут корректны:

     ## delete #p where #p.#ip = *str_var[0]->ip
     ## delete p  where p.name = str_var[i]->px

Заметим, что в первой строке оператор  относится  к  кортеж-
переменной p, а во второй ее имя берется из переменной p.  А
вот следующие конструкции будут некорректны:

     ## delete #p where #p.#ip = *(*str_var)->ip
     ## replace #p(ip = 10)
     ## delete #p where #p.#ip = (int)p;

В первом случае недопустимы скобки. Во втором операторе  имя
(в  скобках) задается переменной ip целого типа. В третьем -
используется оператор преобразования типа языка Си.


ООССННООВВННЫЫЕЕ ППООННЯЯТТИИЯЯ                                           88








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


     Сведем эти правила вместе.   В  выполняемых  операторах
EQUEL встречаются следующие конструкции:

     - ключевые слова и символы пунктуации должны быть запи-
       саны явно.

     - имена  (базы  данных,  кортеж-переменных,  отношений,
       атрибутов),   специальные   ключевые  слова  ("into",
       "from), имена функций записываются по одной из следу-
       ющих форм:

    ##_и_м_я подставляется само это имя;

    _п_р_о_с_т_е_й_ш_е_е _в_ы_р_а_ж_е_н_и_е _с_т_р_о_к_о_в_о_г_о _т_и_п_а
         в качестве имени подставляется значение этого выра-
         жения;   правила  составления  выражения  приведены
         выше;

    _и_м_я  если это имя не совпадает с именами описанных пере-
         менных,  то подставляется само это имя, иначе подс-
         тавляется значение соответствующей переменной.

     - константы могут быть либо записаны явно (в синтаксисе
       QUEL,  за  исключением  типа дата/время), либо в виде
       простейшего выражения из  переменных  EQUEL,  которое
       подставляется во время выполнения как константа соот-
       ветствующего типа.

     - в некоторых конструкциях языка  выражение  текстового
       типа заменяет целиком все условие выборки.

     - каждый элемент списка атрибутов в  операторе  выборки
       (retrieve  без  результирующего  отношения, подробнее
       см. ниже) имеет вид:

        _л_е_в_о_е__з_н_а_ч_е_н_и_е == _в_ы_р_а_ж_е_н_и_е__Q_U_E_L

       где левое_значение - это  либо  имя_переменной,  либо
       выражение, которое пригодно для левой части оператора
       присваивания языка Си (правила составления  выражений
       -  стандартные).  Численные значения преобразуются по
       обычным правилам, а для  преобразования  в  текстовый
       формат  и  обратно нужно использовать соответствующие
       функции QUEL.

     Заметим, что переменные и  выражения  символьного  типа
(char *) могут в зависимости от контекста трактоваться одним
из трех способов:

имя  - там, где может появиться имя;

строка
     - там, где может появиться текстовая константа;

99                                           ООССННООВВННЫЫЕЕ ППООННЯЯТТИИЯЯ








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


переменная для присваивания
     - в списке результата операторов выборки.

33..  ООППЕЕРРААТТООРРЫЫ EEQQUUEELL


     Выполняемые операторы можно условно поделить на  четыре
группы:

      операторы управления системой;
      операторы манипулирования данными;
      операторы выборки;
      параметрические операторы.

33..11..  ООппееррааттооррыы ууппррааввллеенниияя

     Для работы с  базой  данных  программа,  написанная  на
EQUEL, должна открыть ее оператором:

     #### rruubbiinn [""_ф_л_а_г_и" ...] _и_м_я__б_а_з_ы

И флаги, и имя базы могут быть заменены переменными.  Каждый
флаг  при  явном указании должен быть заключен в кавычки.  В
случае, если указанной базы данных не существует или СУБД не
может  быть  вызвана,  происходит  "системная  ошибка"  (см.
ниже).

     Завершить работу с базой данных можно, выполнив  опера-
тор

     ####eexxiitt

Выдача оператора ##rubin при уже открытой базе данных,  либо
выполнение  любого другого оператора языка EQUEL без предва-
рительного открытия базы данных диагностируется как "систем-
ная  ошибка".  Перейти к работе с другой базой можно только,
закончив работу со старой базой оператором "##exit" и выпол-
нив затем новый оператор "##rubin".

     Примеры:

     1.
        ##rubin demo /* Откроем базу demo */

     2.
        ## char *name =
        "base";
        ## rubin "-rheap" "-dDD.MM.YY" name
        /* Откроем базу "base", установив формат для
           ввода/вывода даты по умолчанию */
         ...
        ## exit /* Закрытие базы данных */


ООССННООВВННЫЫЕЕ ППООННЯЯТТИИЯЯ                                          1100








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


33..22..  ООппееррааттооррыы ммааннииппууллиирроовваанниияя ддаанннныыммии

     Следующие операторы языка EQUEL записываются и выполня-
ются аналогично соответствующим операторам языка QUEL. Имена
(отношений, атрибутов, кортеж-переменных,  функций,  файлов)
могут  заменяться  на  переменные  или выражения символьного
типа, то же относится и к ключевым словам "from" и "into"  в
операторе  "copy".   Везде,  где в QUEL допустимы константы,
могут использоваться выражения соответствующего типа.  Кроме
того,  условие  в конструкциях "where условие" может целиком
заменяться переменной символьного типа.

     Операторы, производящие в QUEL выдачу  на  терминал,  в
EQUEL  также  выдадут  свою  информацию  в  стандартный файл
вывода; эти операторы помечены в списке знаком ">".   Симво-
лом  "!"  помечены операторы, которые могут также быть запи-
саны в параметрической форме (см. ниже):

     ## append ...            !
     ## copy ...              !
     ## create ...            !
     ## define view ...
     ## define permit ...
     ## define integrity ...
     ## define переменная ...
     ## delete ...
     ## destroy
     ## help  ...            >
     ## help view ...        >
     ## help permit ...      >
     ## help integrity ...   >
     ## index ...
     ## modify ...
     ## print ...           >
     ## range ...
     ## replace ...         !
     ## retrieve [into] имя_отн ... !
     ## save    ...

Оператор retrieve без результирующего отношения  выполняется
как оператор выборки (см. ниже).

     Примеры:

     ## char file[] =
     "/mnt/archiv/out";
     ## char *s =
     "into";
     ## char *rel[10];
     ## int k;
     ...
     ...
     ## range of #s is rel[i]
     ## replace #s( #num = k) where #num = 0
1111                                           ООППЕЕРРААТТООРРЫЫ EEQQUUEELL








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


     ...
     ## copy rel[i](p1=c0comma,p2=c0nl) s file[i]
     ...


33..33..  ООппееррааттоорр ввыыббооррккии

     Для получения информации из  базы  программа  на  EQUEL
должна использовать оператор "retrieve" без указания резуль-
тирующего отношения - оператор выборки.  Он имеет  следующий
вид:

     #### rreettrriieevvee ((_с_п_и_с_о_к__о_б_ъ_е_к_т_о_в)) [wwhheerree _у_с_л_о_в_и_е]
     ####{{
     _Б_л_о_к _о_п_е_р_а_т_о_р_о_в _н_а _С_и
     ####}}

Список_объектов состоит из элементов вида:

     _п_е_р_е_м_е_н_н_а_я == _в_ы_р_а_ж_е_н_и_е__Q_U_E_L

перечисленных через запятую (аналогично QUEL), причем  пере-
менная  может  быть  и  выражением, допустимым в левой части
оператора присваивания и  составленным  по  правилам  EQUEL.
Выражение_QUEL  - это обычное выражение языка QUEL, перемен-
ные в нем подставляются по обычным правилам.

     Оператор выборки выполняется следующим образом:

11))   Выполняются подстановки переменных в условия и в  левые
     части в списке объектов;

22))   В базе данных выполняется поиск перечисленных в  списке
     значений;

33))   Для каждого найденного кортежа найденные значения прис-
     ваиваются  указанным  в  списке  объектов переменным, и
     выполняется Си-блоком.

     Таким образом, оператор ##retrieve аналогичен оператору
retrieve  языка  QUEL, но если в QUEL результатом его работы
является выводимая таблица с данными, то в EQUEL таблица  не
выводится,  а  для  каждой  строки  таблицы значения колонок
присваиваются EQUEL-переменным и выполняется Си-блок.

     ООггррааннииччеенниияя на Си-блок:

     - В нем не должно содержаться операторов EQUEL;

     - Запрещен вход в него снаружи по метке;

     - Выйти из блока раньше  времени  (не  обрабатывая  все
       найденные кортежи) можно только по оператору "break",
       перейти к следующему кортежу -  только  по  оператору
ООППЕЕРРААТТООРРЫЫ EEQQUUEELL                                           1122








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


       "continue".

     - Подстановка значений Си-переменных в запрос (в  усло-
       вии и в правых частях списка объектов) производится в
       начале выполнения всего запроса,  и  их  изменение  в
       Си-блоке не влияет на запрос.

     Фактически оператор  выборки  заменяется  таким  циклом
языка Си:

     <Инициализация запроса>
     while ( <Есть еще кортежи>)
     {
        <Присваивание переменным найденных значений>
         Си-блок
     }
     <Пропуск оставшихся кортежей>


     При присваивании найденных значений переменным, числен-
ные  значения преобразуются к нужному типу по обычным прави-
лам преобразования. Дата и время передаются  как  переменные
типа  i4.  Данные  символьного  типа передаются без проверки
длины соответствующей Си-переменной: если  длина  результата
равна  N, то соответствующая символьная Си-переменная должна
иметь длину не меньше  N+1  (один  символ  занимает  признак
конца строки - 0).  Преобразование числовых значений в текс-
товый вид не  производится:  для  этого  нужно  использовать
функции "ascii", "from_date", "from_time" языка QUEL.

     Примеры. Сначала напишем  фрагмент  программы,  который
печатает  фамилии  служащих  5-го отдела и их оклад, а затем
подводит итог (предполагаем, что база данных уже  открыта  и
существует отношение служащие с доменами фио(с20), отдел(i2)
и оклад(i2) (здесь приводятся  только  фрагменты  программы,
полный пример можно найти в ППррииллоожжееннииии):

      ## char fio[21];
      ## int oklad;
      int summa;
      ... Открытие базы
      ## range of ss is служащие
      printf("     Фамилия         Оклад\n")
      printf("    -------------   --------\n");
      summa = 0;
      ## retrieve (fio=ss.фио, orlad=ss.оклад)
      ## where  (ss.отдел = 5)
      ##{
      printf(".20s   %d\n",fio, oklad);
      summa += oklad;
      ##}
      printf("     Итого:          %d   \n",summa);
      ...

1133                                           ООППЕЕРРААТТООРРЫЫ EEQQUUEELL








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


     Следующий пример посложнее. Узнаем  номера  отделов,  и
будем проводить выдачу небольшими порциями, запрашивая подт-
верждение продолжения выдачи:

      ## char fio[21];
      ## int oklad;
      ## int otdel;
      int summa;
      int nline;
      char inbuf[80];
      ... Открытие базы
      /* Чтение номера отдела */
    in_otd:
      printf("Введите номер отдела:_");
      gets(inbuf);
      if(sscanf(inbuf,"%d", &otdel) != 1)
            {
                    printf("Повторите\n");
                    goto in_otd;
            }
      ## range of ss is служащие
    /* Обнуляем номер строки и сумму всех окладов */
      nline = 0;
      summa = 0;
    /* Начинаем цикл выборки */
      ## retrieve (fio=ss.фио, oklad=ss.оклад)
      ## where  (ss.отдел = otdel)
      ##{
    /* Проверяем, не кончилась ли страница */
      if ( nline > 24) {
            nline = 0;
            printf("Еще? (q - кончить)");
            gets(inbuf);
    /* Чтобы пропустить остаток, нужно выйти по
       оператору break из основного цикла */
            if(inbuf[0] == 'q') break;
      }
      if (nline == 0)
      {
          printf("     Фамилия         Оклад\n")
          printf("    -------------   --------\n");
          nline += 2;
      }
      printf(".20s   %d\n",fio, oklad);
      summa += oklad;
      nline++;
      ##}
      printf("    -------------   --------\n");
      printf("     Итого:          %d   \n",summa);
      ...




ООППЕЕРРААТТООРРЫЫ EEQQUUEELL                                           1144








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


33..44..  ППааррааммееттррииччеессккииее ооппееррааттооррыы

     В обычных операторах EQUEL могут использоваться  только
переменные  Си,  описанные  в  EQUEL-описаниях.   Обойти это
ограничение позволяют параметрические  операторы,  признаком
которых является слово "param" перед оператором.  Параметри-
ческим может быть условие поиска "where param (f,v)"  (обра-
тите  внимание,  что  здесь  "param" пишется после "where").
Параметрическими могут быть  почти  все  операторы,  имеющие
объектный  список  (append, retrieve, replace, copy, create,
define view - все эти операторы содержат список вида (a1=v1,
a2=v2, ...)). В параметрических операторах такой список фор-
мируется с помощью следующей конструкции:

     ((_t_l__f_o_r_m,, _a_r_g_v))

где _t_l__f_o_r_m - формат преобразования,  являющийся  указателем
на  строку  (строковая  константа, либо выражение типа (char
*)), а _a_r_g_v - массив ссылок  на  аргументы  оператора  (типа
char *argv[]).

     Формат содержит произвольный текст  и  форматы  подста-
новки  вида "%формат", которые описывают тип соответствующей
переменной из  массива  ссылок.   При  выполнении  оператора
манипуляции данными текст из формата просто переписывается в
запрос, а форматы подстановки заменяются на  значение  соот-
ветствующей переменной (начиная с argv[0]), на которую пока-
зывает очередной элемент массива ссылок, при  этом  тип  его
должен быть согласован с форматом подстановки.  Правильность
получившейся конструкции компилятором EQUEL не  проверяется.
Полученные в результате замены значения трактуются как конс-
танты (то есть таким образом  нельзя  подставить,  например,
имя переменной).

     Напротив,  в  операторах  выборки  форматы  подстановки
могут  встречаться  только  в  левой  части  элемента списка
(%формат = значение).  Соответствующий элемент массива  argv
в этом случае определяет адрес переменной для записи найден-
ного значения, а формат определяет тип этой переменной.

     Допустимы следующие форматы подстановки:

%%ii11  - переменная типа char, используемая как целое;

%%ii22  - переменная типа short;

%%ii44  - переменная типа long;

%%ff44  - переменная float;

%%ff88  - переменная double;

%%cc   - массив символов (char []).

1155                                           ООППЕЕРРААТТООРРЫЫ EEQQUUEELL








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


     Для записи самого символа % используется %%.

     В операторах  "param append", "param  replace",  "param
copy"  может  производиться  замена  правой  части элементов
списка:

     double ff;
     long l;
     int iok;
     char *tl_av[] =
     { "New_s", (char *)&ff, (char *)&l };
     char *tl_av1[] =
     {  (char *)&iok };
     char *tl_av2[] =
     {  "c0,", "c5" };
     char *f = "оклад=%i2";
     ## param append new("s=%c, ff=%f8, cnt=%i4",tl_av)
     ## param replace служащие (f,tl_av1)
     ## param copy("s1=%c, s2=%c,d3=nl",tl_av2)

Заметим, что подстановка применяется только там, где в  QUEL
может встретиться константа соответствующего типа.

     В условии "param where ..." параметрическим должно быть
все условие:

     ## delete служащие
     ## param where ("отдел=%i2 and должность=%c", av)


     В  операторах  "param  create",  "param  define   view"
использование  подстановки практического смысла не имеет (за
исключением констант в правой части целевого  списка  опера-
тора  "define view"), но использование параметрического опе-
ратора по прежнему позволяет сформировать  параметры  опера-
тора заранее в виде текстовой строки:

     char *f = "имя=c12, длина=i4";
     ## param create a(f,NULL)


     В  операторе  "param  retrieve"  описатель  подстановки
"%формат"  ддооллжжеенн присутствовать во всех левых частях списка
объектов, например:

     ## param retrieve ("%c=a.name, %i4=a.date, %i2=a.cnt", tl_av)
     ##{
     <Си-блок>
     ##}

При этом формат должен быть строго согласован с типом  пере-
менной,  на  которую  указывает  соответствующий  указатель.
Использование формата в правой части или  пропуск  описателя
формата    в    очередном   элементе   списка   приводят   к
ООППЕЕРРААТТООРРЫЫ EEQQUUEELL                                           1166








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


непредсказуемым ошибкам на этапе выполнения программы.

     Пример  использования  параметрических  операторов.   В
примере        используется        отношение       "служащие
(имя=c20,оклад=i2)".

    /* Описываем данные. Заметьте, что
     * все описания сделаны так, что
     * в операторах EQUEL информация о
     * структуре данных отстутствует, она
     * вся собрана здесь
     */
    ## char rel_name[] =
            "служащие";
     struct slug {
            char s_name[21];
            short s_okl;
            } s_slug;
     char *v_slug[] = {
           &s_slug.s_name,
           &s_slug.s_okl };
     char *ret_slug = "%c = s.имя, %i2 = s.оклад";
     /* Для операторов записи/обновления формат
       выглядел бы так:
       "имя=%c, оклад=%i2"
      */
     ... Начало программы. Здесь нет накакой зависимости
     ... от структуры отнешения и данных
     ## range of s is rel_name
     ## param retrieve(ret_slug, v_slug)
     ## {
     my_print( &s_slug);
     ## }
     ...


     Итак,  параметрические  операторы  при  их   правильном
использовании обеспечивают независимость операторов EQUEL от
структур данных, с которыми они оперируют.  Ниже перечислены
наиболее  ччаассттыыее оошшииббккии в использовании параметрических опе-
раторов:

1)   Попытка использовать  подстановку  там,  где  требуется
     имя.

2)   Использование подстановки в правой  части  в  операторе
     выбора.

3)   Использование ссылок на переменные типа  "int",  формат
     которых зависит от типа ЭВМ.

4)   Несоответствие формата и типа переменной.


1177                                           ООППЕЕРРААТТООРРЫЫ EEQQUUEELL








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


5)   Использование списка переменных вместо массива  ссылок,
     либо неправильная инициализация этого массива.

     В ППррииллоожжееннииии имеется пример программы на EQUEL, исполь-
зующей параметрические операторы.

44..  ББИИББЛЛИИООТТЕЕЧЧННЫЫЕЕ ФФУУННККЦЦИИИИ


     Все предыдущее описание EQUEL шло в предположении,  что
все  всегда  правильно, что не бывает ни ошибок, ни прерыва-
ний, не возникает необходимости  преобразовывать  данные.  В
данной  главе  описаны  дополнительные  возможности системы,
которые реализуются в первую очередь  библиотечными  функци-
ями.

     Для использования библиотеки EQUEL в  программу  должен
быть включен файл вставок "rubin/equel.h":

     # include <rubin/equel.h>

В  дистрибутиве  этот  файл  помещен  в  справочнике  files:
"files/equel.h".

44..11..  ККооддыы ооттввееттаа

     Программа на EQUEL может использовать следующие  инфор-
мационные переменные (описанные в <rubin/equel.h>):

IIerrflag
     Признак  ошибки.  Устанавливается  в  0  перед  началом
     выполнения  очередного  оператора;  если при выполнении
     оператора возникли какие-либо ошибки, то  в  переменную
     IIerrflag  записывается код последней ошибки (см. "Опи-
     сание ошибок" в Справочном руководстве).   Подробно  об
     обработке ошибок сказано с следующем параграфе.

IItupcnt
     После операций обновлений (replace, delete,  append)  в
     эту  переменную (типа long) записывается число изменен-
     ных (замененных,  добавленных,  исключенных)  кортежей.
     Следует  только  иметь в виду, что, если при обновлении
     кортежа его содержимое не изменилось, то он не попадает
     в  число  измененных.  Так,  после операции "## replace
     a(dom=a.dom)", tupcnt всегда будет равно 0.

     Кроме того, для отладки можно использовать переменную:

     char *IImainpr;

которая определяет, какая команда будет выполнена для вызова
СУБД (по умолчанию это "rubin").


ООППЕЕРРААТТООРРЫЫ EEQQUUEELL                                           1188








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


44..22..  ООббррааббооттккаа оошшииббоокк ии ппррееррыывваанниийй

     Обработка ошибок и прерываний является одним из  тонких
мест в программе на EQUEL. Это связано с тем, что СУБД уста-
навливает свою реакцию на ошибки и  прерывания,  которые  не
могут быть выключены, поскольку включают операции восстанов-
ления связи процессов, входящих в СУБД.   При  работе  прог-
раммы  на EQUEL могут возникнуть три особых ситуации: преры-
вание с терминала (сигнал SIG_INT), ошибка оператора EQUEL и
фатальная  (системная)  ошибка (хотя она не обязательно выз-
вана ошибкой системы).

44..22..11..  ООббррааббооттккаа ппррееррыывваанниийй

     Прерывания при работе программы  на  EQUEL  могут  либо
игнорироваться,  либо обрабатываться самой системой. Реакция
на прерывания устанавливается системой при выполнении опера-
тора "#rubin", и ее отмена или изменение после открытия базы
данных приведет к фатальным последствиям.

     Во первых, до выполнения оператора  "#rubin"  программа
может  отменить  реакцию на прерывания с терминала. При этом
ядро СУБД не будет прерываться  символом  INTERRUPT  (CTRL-C
или  DEL  в  зависимости  от  умолчаний),  а программа после
выполнения оператора "rubin" сможет распоряжаться этим  пре-
рыванием  по своему усмотрению (например, открыть его снова,
но теперь уже только для самой себя). При этом нужно помнить
о  том, что из цикла выборки данных выйти можно только через
оператор "continue".

     Во вторых, программа может воспользоваться  стандартной
реакцией  на  прерывание.  При  этом система восстанавливает
программные каналы связи с ядром СУБД, а  затем  анализирует
переменную IIinterrupt, описанную в <rubin/equel.h>:

     extern int (*IIinterrupt)();

Если эта переменная не определена, система  EQUEL  завершает
работу,  вызывая системную ошибку. Пользователь может задать
собственную программу обработки, записав ее адрес в IIinter-
rupt, и она будет вызвана таким образом:

     (*IIinterrupt)(-1);

Пример использования:

     /*
      * Сначала напишем функцию для возврата из прерывания
      */
     # include <setjmp.h>

     static jmp_buf myjmp;
     myreset(val)
     {
1199                                      ББИИББЛЛИИООТТЕЕЧЧННЫЫЕЕ ФФУУННККЦЦИИИИ








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


       longjmp(myjmp, val);
     }
     myset()
     {
     return(setjmp(myjmp));
     }

     /* А теперь фрагмент головной программы */
     ...
     ## rubin base
     myset();
     IIinterrupt = myreset;
     while(1)
             main_loop();
     ...

Теперь, если  произойдет  прерывание,  программа  после  его
обработки выйдет на начало основного цикла.

44..22..22..  ДДииааггннооссттииккаа оошшииббоокк

     Обработка ошибок РУБИН и EQUEL  управляется  следующими
указателями на функции (они описаны в include-файле):

     extern int (*IIprint_err)();
     extern int (*IIout_err)();

Реакция системы на ошибки RUBIN и EQUEL выглядит так:

1)   Приводятся  в  исходное  состояние  программные  каналы
     связи  с ядром СУБД (за исключением тех ошибок, которые
     не обрывают текущий оператор); код ошибки  заносится  в
     IIerrflag.

2)   Вызывается  функция,  на  которую  ссылается  указатель
     IIprint_err:

                код_ошибки = (*IIprint_err)(код_ошибки)


3)   Анализируется возвращенный этой программой код. Если он
     равен 0 - производится выход из программы диагностики.

4)   Если код отличен от нуля, вызывается  программа  печати
     диагностики.   Она находит сообщение об ошибке и выдает
     его, обращаясь с каждой строкой диагностики  к  функции
     по указателю IIout_err:

          (*IIout_err)(строка_сообщения)

     Если этот указатель равен 0, то выдача  идет  на  стан-
     дартный вывод.


ББИИББЛЛИИООТТЕЕЧЧННЫЫЕЕ ФФУУННККЦЦИИИИ                                      2200








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


     Для  управления  диагностикой  используются   следующие
макро:

EQ_ONERR
     - включить стандартную реакцию на ошибки;

EQ_OFFERR
     - выключить диагностику ошибок;

EQ_ERR
     - возвращает 1, если была ошибка, и 0, если- нет.

     Кроме того, программа может записать в IIprint_err ука-
затель на свою функцию и сама анализировать ошибки.

     Приведем пример использования упомянутых макро:

     # include <rubin/equel.h>
       ...
     EQ_OFFERR;
     ## delete temp
     EQ_ONERR;
     ## retrieve unique temp(name=otd.name) where otd.otd = 2
     if (EQ_ERR) IIsyserr("Не могу создать рабочее отношение `temp'");
       ...

(IIsyserr - функция для печати сообщения о фатальной  ошибке
из библиотеки системы EQUEL).

     Для печати диагностик в экранных  программах  использу-
ется функция IIerr_out.  Как правило, программа печати сооб-
щения выводит очередную строку сообщения в выделенную  часть
экрана  и ждет нажатия любой клавиши для того, чтобы продол-
жить работу. Например, при  использовании  экранного  пакета
DIXY (разработки АЗЛК) она выглядит так:

    err_print(s)
    char *s;
    {
     char buf[80];
     sprintf(buf,"!!!%.60s!!!Нажмите ВК",s);
     f_wto(buf,"s"); /* Вывод сообщения */
     s_get(fmswin);  /* Ожидание нажатия */
     return;
    }
    IIout_err = err_print;


     Диагностику рекомендуется отменять в тех случаях, когда
ошибка  может возникнуть по идее работы программы, например,
при уничтожении рабочих отношений (их может просто  не  ока-
заться).


2211                                      ББИИББЛЛИИООТТЕЕЧЧННЫЫЕЕ ФФУУННККЦЦИИИИ








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


44..22..33..  ССииссттееммнныыее оошшииббккии

     Системными в EQUEL называются  ошибки,  не  позволяющие
программе  дальше работать с базой. Система выдает сообщение
с префиксом "SYSTEM ERROR" (СИСТЕМНАЯ ОШИБКА) и  заканчивает
работу.   Программа  может перехватить управление, установив
адрес собственной функции обработки ошибок в переменную:

     extern (*IIabort)();

Если эта переменная не равна 0, то  перед  выдачей  exit(-1)
система EQUEL вызовет указанную функцию:

     (*IIabort)(-1);

При работе экранных программ в IIabort  обычно  записывается
ссылка на функцию восстановления режимов терминала.

     Печать сообщения об системной ошибке идет через  указа-
тель  IIout_err  аналогично остальным сообщениям об ошибках.
Программа может сама инициировать системную ошибку, обратив-
шись к функции IIsyserr:

     IIsyserr(формат, параметры...)

параметры аналогичны функции "printf".

44..33..  РРааббооттаа сс ддааттоойй ии ввррееммееннеемм.. ФФууннккццииии ппррееооббррааззоовваанниияя

     В СУБД РУБИН имеется два специальных типа  данных:  тип
"date"  предназначен  для  хранения дат, а тип "time" - вре-
мени. Оба этих типа данных занимают длинное  целое  число  -
long.  Время хранится в секундах, дата - в днях, прошедших с
начала нашей эры. Во  всех  арифметических  операциях  языка
QUEL  они ведут себя подобно числам формата i4, а при выводе
на терминал в языке QUEL автоматически преобразуются в текс-
товый вид. Кроме того, в языке QUEL имеются функции преобра-
зования даты и времени в текстовое представление  и  обратно
по заданному шаблону.

     В операциях манипулирования данными языка EQUEL дата  и
время ведут себя точно так же; например, при печати операто-
ром "print"  они  будут  автоматически  преобразовываться  в
текстовый  вид.  Отличия  начинаются,  когда  дату или время
необходимо передать из задачи в базу или  выбрать  из  базы.
Констант  типа  "date"  и "time" в языке EQUEL не предусмот-
рено, дата и время передаются в виде длинных чисел.  В стан-
дартных описаниях EQUEL имеются специальные обозначения этих
типов: EQ_date и EQ_time (оба определены как long).

     В языке EQUEL можно использовать два способа преобразо-
вания  даты и времени в текст и обратно. Во первых, это пре-
образование можно делать непосредственно в операторах EQUEL,
используя   стандартные   функции  преобразования  -  ascii,
ББИИББЛЛИИООТТЕЕЧЧННЫЫЕЕ ФФУУННККЦЦИИИИ                                      2222








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


from_date, from_time - для получения текстового  представле-
ния при считывании из базы, и date4, time4, to_date, to_time
- при записи в базу. Это плохо  только  тем,  что  возможные
ошибки в дате или времени будут определяться непосредственно
в операторах взаимодействия с базой;  кроме  того,  возможны
ошибки  в  определении длины результата преобразования, да и
объем данных, пересылаемых между базой  и  программой,  нес-
колько увеличивается.

     Во вторых, обмен с базой можно вести в исходном формате
(long),  а для преобразования использовать функции, записан-
ные в библиотеку EQUEL.  Для использования  этих  функций  в
программу нужно включить файл описаний:

     # include <rubin/datetime.h>


     Преобразования даты и времени в текст и обратно  прово-
дятся по шаблону преобразования, который задается явно, либо
используется по умолчанию. Шаблон - это  строка,  в  которую
могут  входить  идентификаторы  преобразования (определенные
последовательности прописных букв, которые обозначают  подс-
тановку  той или иной компоненты даты), символы пунктуации и
произвольный текста, взятый в кавычки. Например,  "DD.MM.YY"
или  "DD МЕСЯЦА YYYY 'года'": DD, MM, YY, YYYY, МЕСЯЦА - это
идентификаторы  преобразования,  которые  обозначают   дату,
номер  месяца, две или четыре цифры года, название месяца на
русском языке.  Существуют следующие идентификаторы преобра-
зования даты:

DD   - день месяца (1-31);

MM   - номер месяца (1-12);

YY   - две последние  цифры  года  (при  выводе);  последние
       цифры 19YY года - при вводе;

YYYY - четыре цифры года;

W    - номер дня недели (0-6, воскресенье - 0);

Н    - (русское Н) - то же самое;

MON  - английское  сокращенное  название  месяца,  например,
       Jan;

MONTH
     - английское полное название месяца;

МЕС  - русское сокращенное название месяца (Янв,  Фев,  Мар,
       Апр, Май, Июн, Июл, Авг, Сен, Окт, Ноя, Дек);

МЕСЯЦ
     - русское полное название месяца в именительном падеже;
2233                                      ББИИББЛЛИИООТТЕЕЧЧННЫЫЕЕ ФФУУННККЦЦИИИИ








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


МЕСЯЦА
     - русское полное название месяца в дательном падеже;

DAY  - сокращенное английское название дня недели (San, Mon,
       ...);

DAYWEEK
     - английское полное название дня недели;

ДЕН  - русское сокращенное название дня  недели  (Пон,  Вто,
       Сре, Чет, Пят, Суб, Вос);

ДЕНЬНЕД
     - русское полное название дня недели;

     Преобразование времени проще:

HH   - число часов;

MI   - минут;

SS   - секунд.

     При переводе даты/времени в текст идентификаторы преоб-
разования  заменяются на соответствующую часть даты или вре-
мени, а все остальные символы просто выводятся без изменений
(при этом снимаются кавычки "'", а две кавычки заменяются на
одну). При вводе на месте идентификаторов ожидается (и  вво-
дится)  соответствующая  часть  даты или времени, символ "?"
означает "ЛЮБОЙ СИМВОЛ", а остальные  символы  в  шаблоне  и
строке  ввода  должны  совпадать.  При  вводе полей, имеющих
текстовое значение (название месяца) идет поиск по всем воз-
можным  названиям  месяца,  а не только по указанному в шаб-
лоне.  Имеются умолчания: шаблон "DD-MON-YYYY"  для  даты  и
"HH:MI:SS"  для  времени.   Примеры вывода и ввода 12 апреля
1985 года (для времени аналогично)::

"DD.MM.YY"
     - Вывод: "12.04.85"; Ввод: "12.04.85".

"DD-MON-YYYY"
     - Вывод: "12-Apr-1985". Ввод: допустимы  "12-Апр-1985",
       "12-Apr-1985" и даже "12-Апреля-1985".

"'Сегодня' DD МЕСЯЦА YYYY 'года', ДЕНЬНЕД"
     - Получится "Сегодня 12  Апреля  1985  года,  четверг".
       Ввод имеет мало смысла, так как день недели не анали-
       зируется;  однако  выведенная  строка  введется  пра-
       вильно.

"DD?MM?YY"
     - Ввести по этому формату можно как "12.04.1985", так и
       "12 4 1985".

ББИИББЛЛИИООТТЕЕЧЧННЫЫЕЕ ФФУУННККЦЦИИИИ                                      2244








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


     Все функции, входящие в библиотеку, можно разделить  на
следующие группы.

1)   Функции преобразования по шаблону из текстового  предс-
     тавления в формат даты или времени:


          EQ_date char_date(in,ss)
          char *in; /* Текстовое представление */
          char *ss; /* Шаблон преобразования   */

          EQ_time char_time(in,ss)
          char *in; /* Текстовое представление */
          char *ss; /* Шаблон преобразования   */


     Эти функции преобразуют дату или  время  из  текстового
     вида  (in)  в  числовой  формат  по  шаблону (ss). Если
     вместо шаблона стоит NULL, то  используется  шаблон  по
     умолчанию.   В случае ошибки возвращается отрицательное
     значение.

2)   Функции преобразования из даты/времени в текст:


          char *date_char(date, ss)
          EQ_date date;  /* Дата   */
          char *ss;      /* Шаблон */

          char *time_char(time, ss)
          EQ_time time;  /* Время  */
          char *ss;      /* Шаблон */


     При ошибке (она возможна в шаблоне) возвращается  NNUULLLL.
     Если  шаблон  не  задан (NULL), используется умолчание.
     Правильный результат возвращается в статической области
     памяти (возвращается указатель на эту область), и зати-
     рается при следующем обращении к любой из перечисленных
     функций.

3)   Запрос длины даты/времени, описанных в шаблоне.

          int date_len(ss)
          char *ss; /* Шаблон */
          int time_len(ss)
          char *ss; /* Шаблон */

     Возвращается число  символов,  которые  будут  занимать
     дата или время, полученные по указанному шаблону.

4)   Функции распаковки/запаковки даты и времени. В распако-
     ванной  форме  дата  и  время  записывается в следующие
     структуры,     описанные      в      файле      вставок
2255                                      ББИИББЛЛИИООТТЕЕЧЧННЫЫЕЕ ФФУУННККЦЦИИИИ








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


     <equel/datetime.h>:

          /* Дата */
          struct cd_date {
          int cd_year; /*  Год */
          int cd_month; /* Месяц: 1-12 */
          int cd_day;   /* День месяца: 1-31 */
          int cd_2year; /* Год текущего века */
          int cd_week;  /* День недели, 1-7 */
          };
          struct cd_time {
          int cd_hh;     /* Часов */
          int cd_mm;     /* Минут*/
          int cd_ss;     /* Секунд */
          }

     Программы преобразования переводят дату и время из фор-
     мата длинного целого в указанные структуры и обратно:

          /* Дату в структуру */
          date_cd(date, pcd)
          EQ_date date;
          struct cd_date *pcd;
          /* Время в структуру */
          time_cd (time, pcd)
          EQ_time time;
          struct cd_time *pcd;
          /* Структуру в дату */
          EQ_date cd_date(pcd)
          struct cd_date *pcd;
          /* Структуру во время */
          EQ_time cd_time(pcd)
          struct cd_time *pcd;

     Для получения правильной даты должны быть указаны день,
     месяц  и  либо  год,  либо  (для 19ГГ года) 2 последние
     цифры года в cd_2year.

5)   Запрос текущих даты и времени:

          d = get_date() - запрос даты
          t = get_time() - запрос времени
          new_datime - обновление даты/времени

     Это не функции, а макро. Выдается время и дата  первого
     обращения к указанным функциям после последнего обраще-
     ния к new_datime, что гарантирует согласованность  даты
     и времени даже в момент смены даты (24 часа 00 минут).






ББИИББЛЛИИООТТЕЕЧЧННЫЫЕЕ ФФУУННККЦЦИИИИ                                      2266








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


44..44..  ФФууннккццииии ддлляя ррааббооттыы ссоо ссттррооккааммии

     В библиотеку EQUEL входят несколько функций для  работы
со  строками,  которые используются самой системой, но могут
быть полезны и программисту:


     Преобразование из текста в целое:
     IIatoi(s,i)
     char *s; int *i;
     Вводятся только |целые| < 32767
     Код ответа: 0 - преобразовано
                -1 - ошибка
                +1 - переполнение

     Перепись из s в d массива длиной l:
     IIbmove(s,d,l)
     char *s, *d;
     int l;

     Слияние нескольких строк:
     char *IIconcatv(buf, s1, s2,..., NULL)
     char *buf, *s1, s2...
     Все строки s1, s2 ... сливаются вместе
     и записываются в buf.
     Возвращается указатель на конец
     полученной строки.
     Последний аргументом должен быть
     NULL (то есть (char *)0)

     Преобразование целого в текстовый вид:
     char *IIitos(i)
     int i;
     Возвращается указатель на статическую
     область памяти.

     Определение длины строки
     int IIlength(s)
     char *s;
     Эта функция имеет особенность: если
     длина строки больше 255, возвращается ответ 255.

     Проверка равенства двух строк:
     IIsequal(s1, s2)
     char *s1, *s2;
     Ответ: 1 - равны, 0 - не равны.








2277                                      ББИИББЛЛИИООТТЕЕЧЧННЫЫЕЕ ФФУУННККЦЦИИИИ








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


55..  ППРРИИЕЕММЫЫ ППРРООГГРРААММММИИРРООВВААННИИЯЯ ННАА EEQQUUEELL


     При программировании на языке EQUEL у начинающих обычно
возникают  одни и те же проблемы. Ниже делается попытка сис-
тематизировать и разрешить некоторые из них.

55..11..  ИИссппооллььззооввааннииее ttiidd ддлляя ссооззддаанниияя ккууррссоорроовв

     Одно из больных мест языка  EQUEL  (который  в  будущем
будет  разрешен),  это  отсутствие встроенного механизма для
последовательного просмотра найденных записей с  одновремен-
ным  их изменением.  В некоторых языках манипулирования дан-
ными для этого используются "курсоры" - указатели на найден-
ную  информацию,  которые  позволяют  сначала  найти  нужные
записи, а потом просматривать и обновлять их.  В  EQUEL  это
надо делать явно:

1)   Сначала организуется поиск требуемых записей. Для того,
     чтобы  в  дальнейшем можно было обратиться к любой най-
     денной записи (кортежу), запрашиваются tid-ы (идентифи-
     каторы кортежей), которые записываются в файл или, если
     предполагаемые объемы информации  небольшие,  просто  в
     массив.

     tid - это внутренний  номер  кортежа  в  отношении.  Он
     имеет  формат  i4,  уникален внутри данного отношения и
     позволяет найти любой кортеж в  отношении  без  какого-
     либо  поиска. Цикл поиска будет выглядеть примерно так.
     Допустим,  у  нас  есть  отношение   "служащие(имя=с20,
     отдел=i2,  оклад=i2, принят=date)".  Имеется запрос (он
     сделан параметрическим, чтобы выделить  всю  конкретную
     информацию):

           /* Описания данных для считывания и поиска */
           struct { char name[21]; short okl;} s_in;
           struct { short otd; EQ_date datein; }w_wh;
           char *v_in[] =    { s_in.name, &s_in.okl };
           char *v_where[] = { &w_wh.otd, &w_wh.datein };
          ... Запрос ...
          ## range of s is служащие
          ## param retrieve ("%c=s.имя, %i2 = s.оклад", v_in)
          ## param where ("s.отдел = %i4 and s.принят > %i4", v_where)
          ##{
            что_то_делаем(&s_in);
          ##}

     Все хорошо, но в "что_то_делаем( &s_in) " мы  не  можем
     ничего делать с базой данных. Перепишем теперь запрос с
     использованием tid (для имитации курсора).

           /* Описания данных для считывания и поиска */
           struct { char name[21]; short okl;} s_in;
           struct { short otd; EQ_date datein; }w_wh;
ББИИББЛЛИИООТТЕЕЧЧННЫЫЕЕ ФФУУННККЦЦИИИИ                                      2288








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


           char *v_in[] =    { s_in.name, &s_in.okl };
           char *v_where[] = { &w_wh.otd, &w_wh.datein };

          /* Опишем переменные для записи tid */
          ## long tid_s;
          int nfind; /* Счетчик найденных записей */
          /* А это описатель файла для записи tid */
          FILE *fd;
          /* Естественно, файл нужно открыть */
              fd = fopen("TEMP1", "w+");

          ... Запрос ...
          nfind = 0;
          ## range of s is служащие
          ## retrieve (tid_s = s.tid)
          ## param where ("s.отдел=%i4 and s.принят>%i4",v_where)
          ##{
            /* Теперь мы пишем tid в файл */
            fwrite(fd, &tid_s, 4,1);
            nfind++;
          ##}
          /* Переходим к началу файла.         */
          /* В nfind - число найденных записей */
          fseek(fd, 0l, 0);
          /* А вместо запроса теперь будет цикл по массиву */
          for(i=0; i<nfind; i++)
          {
                 fread(fd, &tid_s, 4, 1);
           ## param retrieve ("%c=s.имя, %i2 = s.оклад", v_in)
           ## where s.tid = tid_s
           ##{
           /* Нет, мы еще ничего не делаем. Этот поиск пройдет
            * ровно один раз, так как s.tid указан точно   */
           ##}
           /* А теперь можно делать все что угодно */
           что_то_делаем(&s_in, tid_s);
          }
          fclose(fd);
          unlink("TEMP1");

     Теперь в программе "что_то_делаем" мы можем  обращаться
     к базе данных, например, изменить выбранный кортеж. Для
     его точной идентификации достаточно указать  в  условии
     "where  s.tid  = tid_s" (для того его туда и передали в
     качестве параметра).

     В этом примере не затрагивается проблема блокировки  от
одновременного обновления. Решение ее зависит от конкретного
случая; можно, например, в условие "s.tid=s_tid" добавить  и
проверку  остальных  условий с тем, чтобы при изменении дан-
ного кортежа он просто не был бы выбран.



2299                          ППРРИИЕЕММЫЫ ППРРООГГРРААММММИИРРООВВААННИИЯЯ ННАА EEQQUUEELL








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


55..22..  ГГееннеерраацциияя ууннииккааллььнныыхх ззннааччеенниийй

     При добавлении новой информации  в  базу  данных  часто
возникает  необходимость присвоить какому-либо полю уникаль-
ное значение. Например,  при  записи  нового  служащего  ему
нужно  обычно  присвоить  номер, на который можно будет ссы-
латьсся в дальнейшем.  Для этого используется аппарат  пере-
менных  QUEL. Переменная QUEL - это именованное длинное (i4)
число, доступное всем, работающим с данной базой. Над  пере-
менными в языке QUEL определены две основные операции:

ser_next("имя")
     - получить текущее значение переменной, а затем  увели-
       чить значение переменной в базе на 1 (аналогично опе-
       ратору v++ языка Си);

ser_last("имя")
     - выдается только после ser_next и возвращает  повторно
       значение  переменной, полученное в последней операции
       "ser_next".

     Имеется еще оператор инициализации "define"  и  функция
присваивания "ser_set".

     Например, в программе на EQUEL нужно записать  информа-
цию  об эксперименте в три отношения: `эксперимент', `значе-
ния', `комментарий'.  Во всех трех есть поле `номер', содер-
жащее  номер  данного  эксперимента.   Заведем в базе при ее
создании переменную `num_ex' и присвоим ей значение 1:

     /* Это программа создания базы */
     ## define num_ex 1

Фрагмент программы записи будет выглядеть так:


     ## append to эксперимент
     ##       (номер=ser_next("num_ex"), ..........)

     ## append to значения
     ##       (номер=ser_last("num_ex"), ..........)

     ## append to комментарий
     ##       (номер=ser_last("num_ex"), ..........)










ППРРИИЕЕММЫЫ ППРРООГГРРААММММИИРРООВВААННИИЯЯ ННАА EEQQUUEELL                          3300








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


55..33..  ИИссппооллььззооввааннииее ccooppyy ддлляя ммаассссооввооггоо ввввооддаа ддаанннныыхх

     Еще одной проблемой является  ввод  в  систему  больших
объемов  данных.   Дело в том, что вводить данные оператором
"append" можно только при  небольших  их  количествах,  пос-
кольку  он  довольно медленно работает.  Лучший способ ввода
при больших объемах - использовать "copy".  Тогда ввод  сос-
тоит из следующих этапов:

1)   Программа готовит данные и записывает их в файл.

2)   Программа вызывает оператор "copy" и  считывает  их  во
     временное отношение.

3)   Программа добавляет данные  из  временного  в  основное
     отношение, используя "append".

4)   Рабочее отношение уничтожается.

     Если данных очень много, есть смысл выполнять  все  эти
действия через несколько сотен записей, тогда объемы рабочих
файлов будут не очень большими.  Рабочее отношение не нужно,
если основное не имеет вторичных индексов и модифицировано в
"heap" или "shash".

66..  ССЛЛУУЖЖЕЕББННЫЫЕЕ ФФУУННККЦЦИИИИ EEQQUUEELL.. ППРРЯЯММААЯЯ ВВЫЫДДААЧЧАА ККООММААННДД QQUUEELL


     В некоторых случаях возможностей языка EQUEL  может  не
хватать.   Так,  например,  он не позволяет выполнить произ-
вольную команду языка QUEL, введенную,  например,  с  терми-
нала.  Поскольку все операторы EQUEL переводятся прекомпиля-
тором в конце концов в  вызовы  функций,  возникает  соблазн
использовать для работы сами эти функции.

     Функции системы EQUEL достаточно сложны и системнозави-
симы  для того, чтобы все их можно было использовать в поль-
зовательских программах (пусть даже это сложный терминальный
монитор).  Однако  можно отобрать несколько функций, которые
позволяют простыми средствами выполнить произвольную команду
QUEL из программы на Си и тем самым при необходимости обойти
любые ограничения языка EQUEL.   Единственное,  чего  нельзя
сделать  -  это  выполнить  оператор  "retrieve"  c  выводом
результата на терминал - в EQUEL такой оператор работает как
оператор выборки.

     Рассмотрим простейший запрос на EQUEL:

     ## print rel1, rel2

Он транслируется  так:

     IIwrite("print rel1, rel2"); IIsync();

3311                          ППРРИИЕЕММЫЫ ППРРООГГРРААММММИИРРООВВААННИИЯЯ ННАА EEQQUUEELL








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


При этом IIwrite просто переписывает свой аргумент в запрос,
а  IIsync  означает конец ввода и начинает выполнение опера-
тора QUEL.  Несколько вызовов IIwrite можно ставить  подряд.
Единственное, что нужно помнить - что оператор не может быть
оператором "retrieve" без результирующего отношения.

     Сложнее с оператором выборки и с подстановкой  перемен-
ных.  Подстановку  в общем-то можно сделать при формировании
строки запроса, а функции EQUEL  использовать  нежелательно,
так  как  код типа переменной зависит и от версии системы, и
от машины. Довольно легко можно  воспользоваться  параметри-
ческой подстановкой. Рассмотрим два оператора:

     ## param replace a(f,v) where s
     ## param retrieve (ff,vv)
     ##{
      fun();
     ##}

Результат будет такой:

    char*s;
    {
            IIwrite("replace a(");
            IIw_right(f,v);
            IIwrite(")where");
            IIwrite(s);
            IIsync(0);
    }
    {
            IIwrite("retrieve(");
            IIw_left(ff,vv);
            IIwrite(")");
            IIsetup();
            while(IIgettup(0)){
                    fun();
            }
            IIflushtup(0);
    }

Функция IIw_right(f,v) осуществляет параметрическую  подста-
новку  параметров  "v" в шаблон "f" (правила такие же, как у
параметрического оператора).  Скобки она сама не  ставит,  и
может  быть  легко использована для формирования строки зап-
роса (подробнее см. Справочное руководство).

     Функция IIw_left(ff,vv) работает аналогично, но она  не
подставляет аргументы в шаблон, а запоминает их для присваи-
вания значений в цикле выборки.  Функция IIsetup()  начинает
выполнение  цикла выборки, а функция IIgettup(0) присваивает
очередные значение переменным  выборки,  указанным  ранее  в
IIw_left(ff,vv).  И,  наконец, IIflushtup(0) служит для про-
пуска оставшихся значений и начальных установок при заверше-
нии цикла выборки.
ССЛЛУУЖЖЕЕББННЫЫЕЕ ФФУУННККЦЦИИИИ EEQQUUEELL.. ППРРЯЯММААЯЯ ВВЫЫДДААЧЧАА ККООММААННДД QQUUEELL        3322








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


     Сведем описания вместе:


     Передача строки запроса ядру СУБД:
     IIwrite(s) char *s;

     Выполнить оператор QUEL:
     IIsync(NULL)

     Передать строку f в качестве запроса,
     выполнив параметрическую подстановку
     из списка указателей v:
     IIw_right(f,v)
     char *f;
     char *v[];

     Передать строку ff в качестве запроса и запомнить
     аргументы для оператора выборки в соответствии
     с их форматом в ff:
     IIw_left(ff,vv)
     char *ff;
     char *vv[];

     Начать основной цикл оператора выборки:
     IIsetup();

     Выбрать очередной кортеж и присвоить
     значение переменным:
     IIgettup(NULL);

     Окончить оператор выборки:
     IIflushtup(NULL);

     Съимитировать прерывание:
     IIresync();



















3333        ССЛЛУУЖЖЕЕББННЫЫЕЕ ФФУУННККЦЦИИИИ EEQQUUEELL.. ППРРЯЯММААЯЯ ВВЫЫДДААЧЧАА ККООММААННДД QQUUEELL








                 ППррооггррааммммииррооввааннииее ннаа EEQQUUEELL


                         СОДЕРЖАНИЕ



1.  ВВЕДЕНИЕ. ЧТО ТАКОЕ EQUEL .........................    1
1.1.  Подготовка программы на EQUEL ...................    2
1.2.  Простой пример ..................................    2

2.  ОСНОВНЫЕ ПОНЯТИЯ ..................................    5
2.1.  Программа на языке EQUEL ........................    5
2.2.  Базовые конструкции языка .......................    5
2.2.1.  Переменные, их типы и описания ................    5
2.2.2.  Константы .....................................    8
2.2.3.  Правила подстановки переменных ................    8

3.  ОПЕРАТОРЫ EQUEL ...................................   10
3.1.  Операторы управления ............................   10
3.2.  Операторы манипулирования данными ...............   11
3.3.  Оператор выборки ................................   12
3.4.  Параметрические операторы .......................   15

4.  БИБЛИОТЕЧНЫЕ ФУНКЦИИ ..............................   18
4.1.  Коды ответа .....................................   18
4.2.  Обработка ошибок и прерываний ...................   19
4.2.1.  Обработка прерываний ..........................   19
4.2.2.  Диагностика ошибок ............................   20
4.2.3.  Системные ошибки ..............................   22
4.3.  Работа с датой и временем.  Функции  преобразова-
      ния .............................................   22
4.4.  Функции для работы со строками ..................   27

5.  ПРИЕМЫ ПРОГРАММИРОВАНИЯ НА EQUEL ..................   28
5.1.  Использование tid для создания курсоров .........   28
5.2.  Генерация уникальных значений ...................   30
5.3.  Использование copy для массового ввода данных ...   31

6.  СЛУЖЕБНЫЕ  ФУНКЦИИ  EQUEL.  ПРЯМАЯ  ВЫДАЧА   КОМАНД
    QUEL ..............................................   31
















ССЛЛУУЖЖЕЕББННЫЫЕЕ ФФУУННККЦЦИИИИ EEQQUUEELL.. ППРРЯЯММААЯЯ ВВЫЫДДААЧЧАА ККООММААННДД QQUUEELL        3344






