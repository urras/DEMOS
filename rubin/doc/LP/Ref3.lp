



DDAAYYFFIILLEE((FFIILLEESS))    ССУУББДД РРУУББИИНН.. ССТТРРУУККТТУУРРАА ФФААЙЙЛЛООВВ     DDAAYYFFIILLEE((FFIILLEESS))



ИИММЯЯ
     .../files/dayfile* - регистрационные сообщения РУБИН.

ООППИИССААННИИЕЕ
     Содержимое _d_a_y_f_i_l_e* включаeт информацию  пользователя  обще-
     системного  плана, она более или менее аналогична /_e_t_c/_m_o_t_d*
     в ДЕМОС.  Файлы не имеет установленного формата; они  просто
     копируется во время регистрации на стандартный вывод монито-
     ром, если не были запрошены опции -_s или  -_d.   Более  того,
     _d_a_y_f_i_l_e*  не являются обязательными и их отсутствие не вызы-
     вает появление ошибок; то же самое  справедливо,  если  _d_a_y_-
     _f_i_l_e* присутствуют, но не имеют разрешение на чтение.

ФФААЙЙЛЛЫЫ







































                              - 1 -








DDBBTTMMPPLLTT((FFIILLEESS))    ССУУББДД РРУУББИИНН.. ССТТРРУУККТТУУРРАА ФФААЙЙЛЛООВВ     DDBBTTMMPPLLTT((FFIILLEESS))



ИИММЯЯ
     .../files/dbtmplt - шаблон базы данных.

ООППИИССААННИИЕЕ
     Этот файл содержит шаблон базы данных, используемый командой
     _c_r_e_a_t_d_b.  Он имеет набор входов для каждого отношения, кото-
     рое должно быть создано в базе данных.  Набор входов  разде-
     ляется строкой пробелов.  Файл завершают две строки пробелов
     или конец файла.

     Первая строка файла - это состояние базы данных и  состояние
     отношения по умолчанию, разделенные двоеточием.  В остальной
     части файла описываются  отношения.   Первая  строка  каждой
     группы  задает  имя  отношения, за которым следует состояние
     отношения, отделенное двоеточием.  Остальные строки в каждой
     группе  - это имя атрибута и тип, разделенные символом табу-
     ляции.

     Все поля состояния задаются в восьмеричной системе  и  имеют
     синтаксис  отдельного числа, за которым следует список пар в
     виде:
             +-x+-N
     который говорит о том, что если  в  строке  команды  _c_r_e_a_t_d_b
     введен ключ +-_x, то нужно установить (стереть) биты заданные
     _N.

     Первый набор входов должен служить для каталога отношений, а
     второй - для каталога атрибутов.

ППРРИИММЕЕРР
     3-c-1+q+2:010023
     relation:-c-20
     relid   c12
     relowner        c2
     relspec i1

     attribute:-c-20
     attrelid        c12
     attowner        c2
     attname c12

             (другие дескрипторы отношений)

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     creatdb(демос)








                              - 1 -








EERRRROORR((FFIILLEESS))      ССУУББДД РРУУББИИНН.. ССТТРРУУККТТУУРРАА ФФААЙЙЛЛООВВ       EERRRROORR((FFIILLEESS))



ИИММЯЯ
     .../files/error[E,R]_? - файлы с ошибками РУБИН

ООППИИССААННИИЕЕ
     Эти файлы содержат сообщения об ошибках  РУБИН.   Существует
     один  файл для каждого разряда тысяч; например, номер ошибки
     2313 будет находиться в файлах error[E,R]_2.

     Каждый файл состоит из последовательности сообщений об ошиб-
     ках  с  соответствующим номером ошибок.  Когда ошибка посту-
     пает на вход системы, в соответствующем файле ищется ее  но-
     мер, если номер находится, то печатается диагностическое со-
     общение, в противном случае, печатается диагностическое  со-
     общение первого параметра.

     Каждое сообщение имеет формат
             номер <TAB> сообщение тильда.
     Диагностическое  сообщение  заканчивается  символом   тильда
     (`~').    Перед  печатью  сообщение  просматривается.   Если
     встречается последовательность %%_n (где _n - цифра от 0 до 9),
     то проставяется параметр _n, где %0 первый параметр.

     Параметры могут располагаться в  любом  порядке.   Например,
     сообщение  об  ошибке  может  ссылаться на %2 перед тем, как
     ссылаться на %0.

ППРРИИММЕЕРР
     1003    строка %0, ошибочное имя базы данных %1~
     1005    в purge %1, ошибочное %0 вызывает выполнение до останова~
     1006    Нет процесса, попытайтесь повторить~

ФФААЙЙЛЛЫЫ





















                              - 1 -








LLIIBBQQ((FFIILLEESS))       ССУУББДД РРУУББИИНН.. ССТТРРУУККТТУУРРАА ФФААЙЙЛЛООВВ        LLIIBBQQ((FFIILLEESS))



ИИММЯЯ
     libq - библиотека поддержки EQUEL на фазе  выполнения.

ФФООРРММААТТ
      /*  ФФааййллыы ввссттааввоокк
      # include <rubin.equel.h>
      # include <rubin/datetime.h>

      /* РРааббооттаа ссоо ссттррооккааммии ии ппррееооббррааззооввааннииее   */
      IIatoi(s,i)  char *s; int *i;
      IIbmove(s,d,l)  char *s, *d; int l;
      char *IIconcatv(buf, s1, s2, ..., NULL)
      char *buf, *s1, *s2 ...;

      char *IIitos(i) int i;
      int IIlength(s) char *s;
      int IIsequal(s1, s2) char *s1, *s2;

      /*  ППррееооббррааззоовваанниияя ддааттаа--ввррееммяя<<-->>ттеекксстт    */
      EQ_date char_date(in, ss) char *in, *ss;
      EQ_time char_time(in,ss) char *in; char *ss;

      char *date_char(date,ss) EQ_date date; char *ss;
      char *time_char(time,ss) EQ_time time; char *ss;

      int date_len(ss) char *s;
      int time_len(ss) char *s;

      /* ССттррууккттууррыы рраассппааккоовваанннноойй ддааттыы ии ввррееммееннии   */
      /* ООппииссаанныы вв rruubbiinn//ddaatteettiimmee..hh */
      struct cd_date {
       int cd_year, cd_month, cd_day, cd_2year, cd_week;}
      struct cd_time {
       int cd_hh, cd_mm, cd_ss; }

      /*  РРаассппааккооввккаа вв ссттррууккттуурруу  */
      date_cd(date,pcd) EQ_date date;struct cd_date *pcd;
      time_cd(time,pcd) EQ_time time;struct cd_time *pcd;

      /*  ЗЗааппааккооввккаа иизз ссттррууккттууррыы   */
      EQ_date cd_date(pcd) struct cd_date *pcd;
      EQ_time cd_time(pcd) struct cd_time *pcd;

      d = get_date() - текущая дата
      t = get_time() - текущее время


      /* ММааккрроо ууппррааввллеенниияя ддииааггннооссттииккоойй оошшииббоокк */
      EQ_ONERR - включить
      EQ_OFFERR - выключить
      EQ_ERR - 1, если была ошибка, 0 - если нет.


                              - 1 -








LLIIBBQQ((FFIILLEESS))       ССУУББДД РРУУББИИНН.. ССТТРРУУККТТУУРРАА ФФААЙЙЛЛООВВ        LLIIBBQQ((FFIILLEESS))


      /* ППееррееммеенннныыее ((ооппииссаанныы вв rruubbiinn//eeqquueell..hh)) */
      extern int (*IIinterupt)();  - прерывание
      extern int (*IIprint_err)(); - вызов по ошибке
      extern int (*IIout_err)(); - печать строки сообщения
      extern int (*IIabort)(); - пришла системная ошибка
      extern int IIerrflag; - код ошибки
      extern int IItupcnt;  - число полученных/измененных  корте-
     жей
      extern char *IImainpr; - имя программы `rubin'

      /* ВВыыззоовв ссииссттееммнноойй оошшииббккии  */
      IIsyserr(form, p1, ...) char *form;



ООППИИССААННИИЕЕ
     Библиотека libq содержит служебные подпрограммы языка  Equel
     и ряд подпрограмм и переменных, полезных пользователю Equel.
     Для работы с ними необходимо в программу на Equel или на  Си
     включить файл вставок:

      # include <rubin/equel.h>

     Для работы с подпрограммами преобразования  даты  и  времени
     необходимо добавить:

      # include <rubin/datetime.h>


11.. ППееррееммеенннныыее EEqquueell
     Они позволяют управлять обработкой ошибок  и  прерываний,  и
     опрашивать   результат  выполнения  операторов.   Переменная
     IIIIiinntteerruupptt позволяет указать адрес  функции,  которую  нужно
     вызвать  в  случае  прерывания  задачи с, терминала (функция
     ssiiggnnaall для такого указания не годится, поскольку  прерывание
     сначала  должно  быть правильно обработано системной Equel).
     После обработки прерывания Equel вызывает указанную функцию:

      if ( IIinterupt) (*IIinterupt)(-1);

     Переменная IIIIaabboorrtt указывает на функцию обработки  фатальных
     ошибок.  При появлении такой ошибки Equel после выдачи сооб-
     щения осуществляет вызов:

      if ( IIabort) (*IIabort)(-1);
      exit(1);

     Переменные IIIIpprriinntt__eerrrr и IIIIoouutt__eerrrr позволяют  управлять  пе-
     чатью сообщений об ошибках. При приходе ошибки или предупре-
     дительного сообщения Equel сначала вызывает функцию, указан-
     ную в IIIIpprriinntt__eerrrr:



                              - 2 -








LLIIBBQQ((FFIILLEESS))       ССУУББДД РРУУББИИНН.. ССТТРРУУККТТУУРРАА ФФААЙЙЛЛООВВ        LLIIBBQQ((FFIILLEESS))


      ko= (*IIprint_err)(код_ошибки);

     Затем, если код ответа _k_o отличен от 0, вызывается программа
     печати  диагностического  сообщения об ошибке, номер которой
     берется из полученного кода ответа. Программа печати  извле-
     кает  строки сообщения из файла диагностик, делает все необ-
     ходимые подстановки и затем для каждой строки сообщения  вы-
     зывает функцию печати по адресу, указанному в IIIIoouutt__eerrrr:

      for ( для каждой строки сообщения )
      (*IIout_err)(строка_сообщения);

     Имеются два макро, которые позволяют  включить  и  выключить
     печать сообщений об ошибках:

      EEQQ__OONNEERRRR - включить печать;
      EEQQ__OOFFFFEERRRR - выключить печать;

     Они просто засылают в IIIIpprriinntt__eerrrr адреса  стандартных  подп-
     рограмм  Equel IIIIrreett__eerrrr и IIIInnoo__eerrrr, возвращающих код ошибки
     и 0 соответственно.

     Переменная IIIIeerrrrffllaagg содержит код завершения очередного опе-
     ратора  Equel:  00  означает  успешное  завершения оператора,
     иначе переменная содержит код последней ошибки. После выпол-
     нения  операторов манипулирования данными или выборки данных
     в переменную IIIIttuuppccnntt засылается число кортежей, выбранных в
     операторе выборки либо изменившихся после операторов aappppeenndd,
     rreeppllaaccee или исключенных в операторе ddeelleettee.  (Нужно иметь  в
     виду, что считаются только кортежи, изменившие свое содержа-
     ние, оператор `replace a(name=a.name)' не приведет ни к  ка-
     ким реальным изменения кортежей и IIIIttuuppccnntt будет равен 0).

     Для опроса ошибок служит макро EEQQ__EERRRR, например:

      ## replace ....
      if (EQ_ERR) сообщение об ошибке;

     Переменная IIIImmaaiinnpprr содержит имя  команды  управления  базой
     данных;  по  умолчанию  это "rubin". Эта переменная служит в
     основном для отладки.


22.. ВВссппооммооггааттееллььнныыее ффууннккццииии

          IIIIaattooii(s,i) char *s;int *i;
               преобразование строки _s  в  целую  переменную  *_i.
               Код  ответа:  0  -  хорошо, 1 - переполнение, -1 -
               ошибка.
          IIIIbbmmoovvee(s,d,l) char *s, *d; int l;
               перепись из _s в массив _d массива длиной _l байт.
          cchhaarr **IIIIccoonnccaattvv(buf,s1,s2,...,NULL) char *buf,*s1,*s2,...;


                              - 3 -








LLIIBBQQ((FFIILLEESS))       ССУУББДД РРУУББИИНН.. ССТТРРУУККТТУУРРАА ФФААЙЙЛЛООВВ        LLIIBBQQ((FFIILLEESS))


               Все  строки _s_1,_s_2,... сливаются вместе и переписы-
               ваются в _b_u_f.  Код ответа - указатель на конец по-
               лученной строки.
          cchhaarr **IIIIttooss(i) int i;
               Преобразование целого в текстовый  вид.  Возвраща-
               ется  указатель на статическую область память, ко-
               торая портится  при  следующем  обращении  к  этой
               функции.
          IIIIlleennggtthh(s) char *s;
               Возврашает длину строки,  если  она  не  превышает
               255, иначе 255.
          IIIIsseeqquuaall(s1,s2) char *s1,*s2;
               Возвращает 0, если строки  не  равны,  и  1,  если
               равны.
          IIIIssyysseerrrr(form,p1,p2,...) char *form;
               Печать сообщения о системной ошибке с  последующим
               завершением    программы.   Параметры   аналогичны
               pprriinnttff.

33.. ППррееооббррааззооввааннииее ддааттыы ии ввррееммееннии
     Для использования функций, описанных в этом разделе, в прог-
     рамму нужно добавить файл вставок:

      # include <rubin/datetime.h>

     В Equel дата и время представляются в виде длинных целых чи-
     сел.   Переменные  типа  date  и time могут быть описаны как
     EEQQ__DDAATTEE и EEQQ__TTIIMMEE соответственно.  Для их  преобразования  в
     текстовый формат и обратно служат следующие функции:
          EEQQ__DDAATTEE cchhaarr__ddaattee iinn,,ssss (char) *in,
          EEQQ__TTIIMMEE ttiimmee__ddaattee iinn,,ssss (char) *in,
               Эти функции преобразуют строку _i_n в  дату  (время)
               по  формату  _s_s  либо  по  формату умолчания, если
               ss==NULL.   Описания  форматов  даны   в   разделе
               date(quel).   Если строка _i_n не соответствует фор-
               мату _s_s либо формат содержит ошибки,  возвращается
               отрицательное значение.
          cchhaarr **ddaattee__cchhaarr(date,ss) EQ_date date;char *ss;
          cchhaarr **ttiimmee__cchhaarr(time,ss) EQ_time time;char *ss;
               Эти функции преобразуют дату (время)  в  текстовый
               вид  и  возвращают указатель на статический буфер.
               NULL означает ошибку в формате.
          ddaattee__lleenn ssss (char) *ss;"
          ttiimmee__lleenn ssss (char) *ss;"
               Возвращают длину даты (времени) в текстовом  виде,
               которые  будут  получаться по шаблону _s_s.  0 озна-
               чает ошибку в шаблоне.







                              - 4 -








LLIIBBQQ((FFIILLEESS))       ССУУББДД РРУУББИИНН.. ССТТРРУУККТТУУРРАА ФФААЙЙЛЛООВВ        LLIIBBQQ((FFIILLEESS))


44.. РРаассппааккооввккаа//ззааппааккооввккаа ддааттыы ии ввррееммееннии
     Дата или время могут быть представлены не только в  компакт-
     ной или текстовой форме, но и в виде структуры

      struct cd_date {
      int cd_year;  /* Год */
      int cd_month; /* Месяц 1-12 */
      int cd_day;   /* День месяца */
      int cd_2year; /* Год % 100 */
      int cd_week;  /* День недели, 1-7 */
      } - ДАТА

      struct cd_time {
      int cd_hh;    /* Часов */
      int cd_mm;    /* Минут */
      int cd_ss;    /* Секунд*/
      } - ВРЕМЯ

     Для преобразования служат функции:
          ddaattee__ccdd(date,pcd) EQ_date date;struct cd_date *pcd;
          ttiimmee__ccdd(time,pcd) EQ_time time;struct cd_time *pcd;
               Преобразование даты (времени) в структуру.
          EEQQ__ddaattee ccdd__ddaattee(pcd) struct cd_date *pcd;
          EEQQ__ttiimmee ccdd__ttiimmee(pcd) struct cd_time *pcd;
               Обратное преобразование.


55.. ЗЗааппрроосс ддааттыы ии ввррееммееннии
          ggeett__ddaattee()
          ggeett__ttiimmee()
               Это не функции, а макро. Они дают текущую дату или
               время  при первом обращении, а затем повторяют от-
               вет. Для обновления текущих даты и  времени  нужно
               вызвать  макро  nneeww__ddaattiimmee.   Между  вызовами этой
               функции ggeett__ddaattee и ggeett__ttiimmee дают согласованный от-
               вет  (время  первого  вызова или последнего вызова
               nneeww__ddaattiimmee).

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
      Equel(quel) - описание языка Equel
      equel(demos) - описание прекомпилятора
      "Программирование на языке Equel" - подробное руководство.












                              - 5 -








PPRROOCCTTAABB((FFIILLEESS))    ССУУББДД РРУУББИИНН.. ССТТРРУУККТТУУРРАА ФФААЙЙЛЛООВВ     PPRROOCCTTAABB((FFIILLEESS))



ИИММЯЯ
     .../files/proctab* - информация о конфигурации РУБИН времени
     выполнения

ООППИИССААННИИЕЕ
     Таблица процесса описывает  конфигурацию  системы  РУБИН  во
     время  ее работы.  Каждая строка таблицы процесса имеет спе-
     циальное  значение,  которое  определяется  первым  символом
     строки.   Строки из пробелов и строки, начинающиеся со звез-
     дочки являются комментариями.  Все  другие  строки  включают
     последовательность  полей,  разделенных  двоеточиями.   Поля
     описания межпроцессных каналов состоят из прописных  букв  и
     цифр;  если это цифры, то они заменяются на дескрипторы фай-
     лов по ключу  или @.

     DD определяет макрокоманду.  Первое поле - односимвольное имя
     макрокоманды.   Второе поле - строка, используемая, как зна-
     чение.  Макрокоманда расширяется  с помощью  ``$_x'',  где  _x
     есть  имя  макрокоманды.   Макро  ``P'' ранее определен, как
     полное имя поддерева РУБИН.

     PP вводит описание процесса.   Все  строки  вплоть  до  конца
     файла или другая строка P описывают отдельный процесс.  Пер-
     вое поле это номер процесса.  Следующее поле  -  полное  имя
     выполняемого  файла  этого процесса.  Третье поле - имя про-
     цесса, используемое для  выдачи  диагностических  сообщений.
     Четвертое  поле - должно быть одной прописной буквой опреде-
     ляющей направление входного потока, который обычно  считыва-
     ется,  если не указано никакого специального направления или
     вертикальным штрихом, за которым следует одна цифра, обозна-
     чающая считывание из файла с указанным дескриптором.  Следу-
     ющее поле содержит набор ключей в восьмеричном виде, относя-
     щихся  к  обработке  этого  процесса;  они описываются ниже.
     Последнее поле - одна буква, сообщающая какой  ключ  трасси-
     ровки используется этим процессом.

     LL определяет, какие модули локально определяются  этим  про-
     цессом.   Первое поле - номер модуля для внутреннего исполь-
     зования.  Второе поле - набор ключей, описывающих выполнение
     этого  модуля:  единственный  определяемый бит 0001, который
     позволяет выполнить этот  модуль  непосредственно  пользова-
     телю.   Третье поле - функциональный номер в процессе, кото-
     рый определяет этот модуль.  Последнее поле - номер  модуля,
     который  должен  выполняться после обработки данного модуля;
     ноль не означает ничего (возврат).

     RR определяет модули, известные этому  процессу,  но  которые
     должны быть переданы на выполнение другому процессу.  Первое
     поле - это номер процесса, в котором будут найдены  эти  мо-
     дули.   Второе  поле - это направление записи передаваемое в
     этот процесс.  Третье поле - направление  чтения  информации


                              - 1 -








PPRROOCCTTAABB((FFIILLEESS))    ССУУББДД РРУУББИИНН.. ССТТРРУУККТТУУРРАА ФФААЙЙЛЛООВВ     PPRROOCCTTAABB((FFIILLEESS))


     от  этого процесса.  Четвертое поле - набор ключей: 0001 оз-
     начает запись  в выходной поток, если вы получили сообщение,
     0002 означает, что процесс физически помещен в поток на чте-
     ние, и 0004 означает, что процесс помещен в поток на запись.
     Пятое и последующие поля - это номера модулей, которые опре-
     деляются данным процессом.

     Имеются следующие биты состояний строки PP::

             000010  отменить выдачу диагностик
             000004  закрыть стандартный ввод
             000002  выполнять в каталоге пользователя, а не базе данных
             000001  выполнить как пользователь, а не как РУБИН


     Процесс с наименьшим номером становится основой всех  других
     процессов.

     ЗЗААММЕЕЧЧААННИИЯЯ  Выдача  разрешения  пользователю  для   заведения
     чьей-либо  собственной таблицы процесса  позволит обойти лю-
     бые средства защиты, прЕдусматриваемые РУБИН.   Эта  возмож-
     ность должна быть предусмотрена только для отладки системы!

ППРРИИММЕЕРР
     Следующий пример иллюстрирует функционирование  трехпроцесс-
     ной системы:

         DB:$P/bin
         DS:$P/source
         ****  Process 0 -- terminal monitor
         P0:$B/monitor:MONITOR:h:0003:M
         L0:0:0:0
         R1:0:a:h:0007:1
         *  Process 1 -- parser
         P1:$B/parser:PARSER:a:0014:P
         L3:1:0:0
         R0:0:h:a:0006:0
         R2:0:b:g:0007:5:6:7
         *  Process 2 -- data base utilities
         P2:$B/alldbu:DBU:b:0014:Z
         L5:0:6:0
         L6:0:0:0
         L7:0:1:0
         R0:0:g:b:0000
         R1:0:g:b:0006

ФФААЙЙЛЛЫЫ
     инструкций
     инструкций





                              - 2 -








SSTTAARRTTUUPP((FFIILLEESS))    ССУУББДД РРУУББИИНН.. ССТТРРУУККТТУУРРАА ФФААЙЙЛЛООВВ     SSTTAARRTTUUPP((FFIILLEESS))



ИИММЯЯ
     .../files/startup - стартовый файл РУБИН

ООППИИССААННИИЕЕ
     Этот файл считывается монитором во время входа. Для правиль-
     ной  работы РУБИН его наличие необязательно.  Он считывается
     перед запуском стартового файла пользователя,  определенного
     в  регистрационном файле.  Основным назначением является оп-
     ределение нового редактора и/или  интерпретатора  командного
     языка для вызова команд монитора РУБИН \\ee и \\ss..

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     monitor(quel), users(files)








































                              - 1 -








UUSSEERRSS((FFIILLEESS))      ССУУББДД РРУУББИИНН.. ССТТРРУУККТТУУРРАА ФФААЙЙЛЛООВВ       UUSSEERRSS((FFIILLEESS))



ИИММЯЯ
     .../files/users - коды и параметры пользователей РУБИН

ООППИИССААННИИЕЕ
     Этот файл содержит информацию о пользователях в полях разде-
     ленных двоеточиями.  Эти поля следующие:
     * Имя пользователя, берется из файла //eettcc//ppaasssswwdd..
     * Код пользователя, устанавливается супер-пользователем  РУ-
         БИН.  Это должен быть уникальный двухсимвольный код.
     * Идентификатор пользоваетеля ДЕМОС.  Он ДОЛЖЕН вводиться из
         файла //eettcc//ppaasssswwdd..
     * Идентификатор группы пользователя в ДЕМОС.  Некоторые  ко-
         ментарии прилагаются.
     * Слово состояния в восьмеричном коде.  Значения битов  сле-
         дующие:
         0000001 разрешение на создание базы данных
         0000002 разрешение на подавление некоторой группы последних изменений
         0000004 разрешение на изменение системных каталогов
         0000020 можно использовать ключи трассировки
         0000040 можно отменять модификатор запросов
         0000100 можно использовать произвольные таблицы процессов
         0000200 можно использовать форму =proctab
         0100000 супер-пользователь РУБИН
     * Список ключей,  автоматически  устанавливаемый  для  этого
         пользователя.
     * Таблица процессов предоставленная для этого пользователя.
     * Файл инициализации, считываемый монитором во время входа в
         систему.
     * Неназначено.
     * Список имен баз данных, разделенных запятой.  Если  список
         пуст, пользователь может войти во все базы данных.  Если
         он начинается с `-', то пользователь может войти во  все
         базы  данных,  исключая указанные.  Однако, пользователь
         может только войти в указанные базы данных.

     Выдача разрешения пользователю на использование произвольной
     таблицы  процессов равносильно отключению защиты системы для
     данного пользователя.

ППРРИИММЕЕРРЫЫ..
     rubin:aa:5:2:177777:-d:=special:/mnt/rubin/.rubin::
     guest:ah:35:1:000000:::::demo,guest

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     initucode(IV)








                              - 1 -




