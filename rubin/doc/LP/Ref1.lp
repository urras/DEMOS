



EEQQUUEELL((QQUUEELL))     ССУУББДД РРУУББИИНН.. ООппееррааттооррыы QQUUEELL ДДЕЕММООСС      EEQQUUEELL((QQUUEELL))



ИИММЯЯ
     equel - встроенный в язык C интерфейс с QUEL

ООППИИССААННИИЕЕ
     _E_Q_U_E_L предоставляет пользователю возможности сопряжения уни-
     версального  языка  программирования ``C'' с РУБИН, при этом
     используется препроцессор и библиотека EQUEL.

     Компиляция осуществляется по команде eeqquueell, которая  описана
     в разделе equel(demos) данного руководства. Здесь будет опи-
     сан язык EQUEL, встроенные переменные и  библиотечные  функ-
     ции.


11.. ККооммааннддыы EEQQUUEELL

     Команды EQUEL помечаются указанием в начале строки двух сим-
     волов  "диез" (``##'').  Остальные строки на Си просто копи-
     руются в результирующий файл без изменения.

     Команды EQUEL бывают нескольких типов:

     1. Команды, являющиеся  по  сути  просто  операторами  языка
     QUEL.  Практически любой оператор языка QUEL, за исключением
     оператора выборки на терминал retrieve (без  результирующего
     отношения)  может быть записан в EQUEL путем простого добав-
     ления ## с начала каждой строки. Если в  этом  операторе  не
     содержится  имен переменных, описанных в описаниях EQUEL, он
     просто выполняется так, как записан.

     Например:

      ## destroy my_name

     2. Специфические команды управления  базой  данных,  которым
     нет  аналога  в  QUEL.  Это команды вызова СУБД "## rubin" и
     окончания связи с СУБД  "## exit",  параметрические  команды
     (они  позволяют  подставлять не описанные в EQUEL переменные
     Си в текст запроса QUEL) и команды выборки (они  служат  для
     получения  данных из базы программой на Си). Все эти команды
     реализуют различные обращения к базе данных.

     3. Описания переменных. По сути это операторы описания  дан-
     ных  языка  Си, перед которыми добавляются символы ``##'' (с
     некоторыми ограничениями на возможные  типы  данных).  Имена
     переменных распознаются прекомпилятором в операторах EQUEL и
     по определенным правилам их значения подставляются в  запрос
     либо,  напротив,  этим  переменным присваиваются значения (в
     операторах выборки).

     4. Скобки `####{{' и `####}}'. Они транслируются в скобки языка Си


                              - 1 -








EEQQUUEELL((QQUUEELL))     ССУУББДД РРУУББИИНН.. ООппееррааттооррыы QQUUEELL ДДЕЕММООСС      EEQQUUEELL((QQUUEELL))


     и одновременно служат для указания области действия перемен-
     ных и операторов выборки в EQUEL.


22.. ББааззооввыыее ээллееммееннттыы яяззыыккаа

     Команды языка могут включать следующие элементы:
          _к_л_ю_ч_е_в_ы_е _с_л_о_в_а -
                         Сюда входят все ключевые слова  QUEL,  а
                         также ключевые слова языка Си (за незна-
                         чительными исключениями).  Они не  могут
                         использоваться  в качестве имен перемен-
                         ных.
          ##_и_м_е_н_а _я_з_ы_к_а _Q_U_E_L -
                         имена,  перед  которыми   стоит   символ
                         ``##'',  считаются именами оператора QUEL
                         и просто транслируются в  результирующий
                         оператор  без  изменения.  Символ ``##'',
                         таким образом, позволяет  при  необходи-
                         мости  указать в запросе любое имя QUEL,
                         даже  совпадающее  с  именем  переменной
                         EQUEL или ключевым словом Си.
          _И_м_е_н_а _п_е_р_е_м_е_н_н_ы_х _E_Q_U_E_L -
                         Если в тексте оператора встречается  имя
                         переменной,  описанной  в EQUEL, или до-
                         пустимое (см. ниже)  выражение  с  такой
                         переменной,  то  происходит  подстановка
                         значения  этой  переменной  в   оператор
                         QUEL.  Правила подстановки описаны ниже.
          _И_м_е_н_а, _н_е _с_о_в_п_а_д_а_ю_щ_и_е _с _и_м_е_н_а_м_и _п_е_р_е_м_е_н_н_ы_х _E_Q_U_E_L -
                         Такие имена просто передаются  дальше  в
                         оператор  QUEL, аналогично именам, поме-
                         ченным символом ``##''.
          _В_ы_р_а_ж_е_н_и_я _С_и - Там, где  допускаются  имена  переменных
                         EQUEL, могут быть записаны также некото-
                         рые простейшие выражения языка Си,  сос-
                         тоящие  из операторов: `[[]]', `**' (указа-
                         тель), `..' (селекция поля), `-->>' (селек-
                         ция поля).  В этом случае осуществляется
                         подстановка данного выражения.
          _В_ы_р_а_ж_е_н_и_я _Q_U_E_L -Все остальные арифметические и логичес-
                         кие операторы и выражения трактуются как
                         выражения языка QUEL и передаются в зап-
                         рос СУБД.


33.. ООппииссаанниияя ппееррееммеенннныыхх EEQQUUEELL

     Операторы описания типов транслируются в программу на Си без
     изменения  (убирается префикс) и, кроме того, сообщают преп-
     роцессору информацию о переменных (тип, имя, ...).



                              - 2 -








EEQQUUEELL((QQUUEELL))     ССУУББДД РРУУББИИНН.. ООппееррааттооррыы QQUUEELL ДДЕЕММООСС      EEQQUUEELL((QQUUEELL))


     Синтаксис оператора описания EQUEL:

      #### _т_и_п _с_п_и_с_о_к__о_п_и_с_а_н_и_й;;

                    либо

      #### _т_и_п _с_п_и_с_о_к__о_п_и_с_а_н_и_й==
      _и_н_и_ц_и_а_л_и_з_а_ц_и_я;;


     _Т_и_п - один из типов: cchhaarr, sshhoorrtt, iinntt, lloonngg, ffllooaatt,  ddoouubbllee,
     _о_п_и_с_а_н_и_е__с_т_р_у_к_т_у_р_ы.   В  целом имеются следующие ограничения
     по сравнению с описаниями Си:

     11.. Допустимы простые переменные (кроме char), массивы,  ука-
     затели  и структуры. Описания массивов и указателей не могут
     содержать скобок, то есть элементы  списка  описаний  должны
     иметь следующую форму:

      [ **... ] _и_м_я [ [[ [ _р_а_з_м_е_р_н_о_с_т_ь ] ]] ...]

     (здесь ... означает возможность  повторения  этой  конструк-
     ции).  Не допустимы простые переменные символьного типа, так
     как в выражениях символьного типа результатом всегда  должен
     быть указатель или массив символов.

     22.. Описания структур не должны быть вложенными.   Они  имеют
     вид:

      #### ssttrruucctt [_и_м_я _с_т_р_у_к_т_у_р_ы] {{
      #### _о_п_и_с_а_н_и_е _э_л_е_м_е_н_т_о_в _с_т_р_у_к_т_у_р_ы
      ...
      #### }} _с_п_и_с_о_к _о_п_и_с_а_н_и_й;;

     Можно использовать отдельное описание типа  структуры,  если
     оно снабжено префиксом `####'.

     33.. Не допустимы объединения и вложенные структуры.

     44.. Допустимы описания размещения extern, auto, static.  Ини-
     циализированные переменные описываются следующим образом:

      #### _о_п_и_с_а_н_и_е ==
      _и_н_и_ц_и_а_л_и_з_а_ц_и_я;;

     то есть список значений выносится на отдельную строку.

     55.. Данные типа ddaattee и ttiimmee хранятся в переменных типа lloonngg.

     Примеры:

      ## char *p, buf[20];


                              - 3 -








EEQQUUEELL((QQUUEELL))     ССУУББДД РРУУББИИНН.. ООппееррааттооррыы QQUUEELL ДДЕЕММООСС      EEQQUUEELL((QQUUEELL))


      ## char *my_name =
      "Alex";
      ## struct xx {
      ## short x;
      ## short y;
      ## char *name[2];
      ## } *xy1[MAX], *pxy;




44.. ООббллаассттьь ооппррееддееллеенниияя ппееррееммеенннныыхх

     Правила для области определения такие же, как  и  для  языка
     Си, но учитываются только блоки, ограниченные скобками `####{{'
     и `####}}':

      Глобальные определения
      ## {
      Локальные определения
      блок
      ##}




55.. ППррааввииллаа ппооддссттааннооввккии

     Везде, где встречается имя переменной EQUEL  (не  замаскиро-
     ванное символом `##'), производится подстановка значения этой
     переменной. Можно использовать выражения  с  операциями  `**'
     (ссылка),  `[[]]' (выборка из массива), `..' и `-->>' (выборка из
     структуры) при условии, что выражение не содержит  скобок  и
     результат  имеет  один  из  типов: short, int, long, double,
     float, char* .  Например (см. описание выше):

      *p
      my_name
      xy1[2]->x
      xy1[1]->name

      Недопустимо:

      *(xy1+2).x
      &(xy1[1]->name[1])

     Подстановка осуществляется следующим образом (за исключением
     операторов быборки, про которые ниже):

     1. Если по контексту на месте подстановки может стоять конс-
     танта или имя файла в кавычках, то значение переменной подс-
     тавляется в качестве константы или имени файла;


                              - 4 -








EEQQUUEELL((QQUUEELL))     ССУУББДД РРУУББИИНН.. ООппееррааттооррыы QQUUEELL ДДЕЕММООСС      EEQQUUEELL((QQUUEELL))


     2. Если на месте подстановки должно  быть  имя  (какого-либо
     объекта QUEL) имя функции или ключевое слово `iinnttoo', `ffrroomm',
     то переменная (или выражение) должны быть типа  `cchhaarr  **'  и
     значение подставляется в качестве имени или ключевого слова.

     3. Имя базы данных и ключи в операторе `####rruubbiinn' могут  быть
     заменены на переменную символьного типа.


66.. УУппррааввлляяюющщииее ооппееррааттооррыы EEQQUUEELL

     1. Начать работу с базойц данныхщ:

      #### rruubbiinn [""_к_л_ю_ч_и""] _и_м_я__б_а_з_ы__д_а_н_н_ы_х

     Ключи могут быть текстовой переменной,  имя  базы  данных  -
     тоже.   При  непосредственной  записи  в  строке ключи нужно
     брать в кавычки.  Этот оператор должен предшествовать  любым
     операторам работы с базой данных.

     2. Окончить работу с базой данных:

      #### eexxiitt

     Одновременно программа может работать только с  одной  базой
     данных.

77.. ``ООббыыччнныыее'' ооппееррааттооррыы EEQQUUEELL

     Следующие операторы Quel могут быть записаны в EQUEL (с уче-
     том правил подстановки) и работают точно так же:


               _a_p_p_e_n_d      _c_o_p_y        _c_r_e_a_t_e      _d_e_f_i_n_e
               _d_e_l_e_t_e      _d_e_s_t_r_o_y     _h_e_l_p        _i_n_d_e_x
               _m_o_d_i_f_y      _p_r_i_n_t       _r_a_n_g_e       _r_e_p_l_a_c_e
               _s_a_v_e        `_r_e_t_r_i_e_n_e _i_n_t_o'

     Заметим, что оператор retrieve должен в данном случае  иметь
     результирующее отношение.


88.. ППааррааммееттррииччеессккииее ооппееррааттооррыы

     Параметрические операторы позволяют осуществлять подстановку
     произвольных  переменных  языка  Си  по  форматному списку и
     списку адресов переменных, которые могут в  этом  случае  не
     описываться  в EQUEL. Основой этих операторов является пара-
     метрический список вида:

      ((_f_o_r_m,,_a_r_g_v))
      char *form;


                              - 5 -








EEQQUUEELL((QQUUEELL))     ССУУББДД РРУУББИИНН.. ООппееррааттооррыы QQUUEELL ДДЕЕММООСС      EEQQUUEELL((QQUUEELL))


      char *argv[];

     где _f_o_r_m  -  формат,  то  есть  строка  текста;   а  _a_r_g_v  -
     массив_адресов,  то  есть  массив  указателей на переменные.
     Формат может содержать произвольный  текст,  который  просто
     переносится  в результирующий оператор QUEL, и ссылки на пе-
     ременные из массива адресов вида:

      %%<_т_и_п><_д_л_и_н_а>

     Допустимые следующие ссылки:
             _И_м_я     _Т_и_п _в _я_з_ы_к_е _С_и
             %_i_1     _c_h_a_r
             %_i_2     _s_h_o_r_t
             %_i_4     _l_o_n_g
             %_f_4     _f_l_o_a_t
             %_f_8     _d_o_u_b_l_e
             %_c      (_c_h_a_r *)
     По формату происходит  подстановка  очередного  значения  из
     списка  argv в результирующий оператор в качестве константы.
     Особым образом обрабатывается параметрический список в  опе-
     раторе выборки, см. ниже.

     Параметрическими могут быть следующие  операторы  (операторы
     выборки см. ниже):

      #### ppaarraamm aappppeenndd _и_м_я ((_f_o_r_m,, _a_r_g_v)) [wwhheerree _у_с_л_о_в_и_е]
      #### ppaarraamm ccooppyy _и_м_я__о_т_н((_f_o_r_m,,_a_r_g_v)) _н_а_п_р_а_в_л_е_н_и_е _и_м_я__ф_а_й_л_а
      #### ppaarraamm ccrreeaattee _и_м_я__о_т_н((_f_o_r_m,,_a_r_g_v))
      #### ppaarraamm rreeppllaaccee _и_м_я ((_f_o_r_m,,_a_r_g_v)) [ wwhheerree _у_с_л_о_в_и_е]
      #### ppaarraamm rreettrriieevvee iinnttoo _и_м_я ((_f_o_r_m,,_a_r_g_v)) [wwhheerree _у_с_л_о_в_и_е]
      #### ppaarraamm ddeeffiinnee vviieeww _и_м_я ((_f_o_r_m,,_a_r_g_v)) [wwhheerree _у_с_л_о_в_и_е]

     В параметрических операторах ccooppyy и  ccrreeaattee  подстановка  по
     формату  ннее  ииммеееетт ссммыыссллаа, так как в них не бывает текстовых
     констант.  Параметрическая форма оператора позволяет  в  них
     сформировать объектный список или список атрибутов заранее в
     текстовом виде и использовать его в операторе.

     Пример:

      char *form="name=%c, bdate=%i4, staj=%i2";
      char name[32];
      long bdate;
      short staj;
      char *av[]= {
      (char *)&name[0],
      (char *)&bdate,
      (char *)&staj };

      ...
      ## param append to users(form,av)


                              - 6 -








EEQQUUEELL((QQUUEELL))     ССУУББДД РРУУББИИНН.. ООппееррааттооррыы QQUUEELL ДДЕЕММООСС      EEQQUUEELL((QQUUEELL))



88.. УУссллооввииее WWHHEERREE
     В EQUEL можно использовать три формы  условия  `where  ...'.
     Первая  форма  совпадает с QUEL с тем отличием, что произво-
     дится подстановки EQUEL-переменных.

      #### wwhheerree _в_ы_р_а_ж_е_н_и_е__Q_U_E_L

     Вторая имеет форму:

      #### wwhheerree _т_е_к_с_т_о_в_а_я__п_е_р_е_м_е_н_н_а_я

     В этом случае условие берется целиком из текстовой  перемен-
     ной.

     Третия форма имеет вид:

      #### wwhheerree ppaarraamm((_f_o_r_m,, _a_r_g_v))

     Производится подстановка по правилам параметрических  опера-
     торов.

99.. ООппееррааттооррыы ввыыббооррккии ддаанннныыхх
     Эти операторы позволяют программе на Си получить  данные  из
     базы по запросу QUEL. Обычный оператор выборки имеет формат:

      #### rreettrriieevvee ((_и_м_я==_в_ы_р_а_ж_е_н_и_е,, ...)) [ wwhheerree _у_с_л_о_в_и_е]
      ####{{
      _С_и-_б_л_о_к
      ####}}

     Где _и_м_я - имя EQUEL-переменной, _в_ы_р_а_ж_е_н_и_е - обычное  выраже-
     ние,  допустимое в правой части оператора QUEL с учетом пра-
     вил подстановки EQUEL.

     Оператор выборки работает так. Сначала ффооррммииррууееттссяя ззааппрроосс  к
     базе  данных, при этом производится подстановка переменных в
     правых частях выражений и в условии выборки. Затем ддлляя  ккаажж--
     ддооггоо найденного кортежа найденные значения ппррииссввааииввааююттссяя ппее--
     ррееммеенннныымм,  которые  стоят  в  левых  частях  результирующего
     списка,  и ввыыппооллнняяееттссяя ССии--ббллоокк с этими подставленными значе-
     ниями.

     Си-блок не должен содержать операторов EQUEL. Выход  из  Си-
     блока  возможен либо при исчерпании найденных кортежей, либо
     по оператору `bbrreeaakk'.  Оператор выборки транслируется в цикл
     выборки  кортежей,  за которым следует обращение к программе
     пропуска оставшихся кортежей на случай преждевременного  вы-
     хода их этого цикла.

     Параметрический оператор выборки позволяет не описывать  пе-
     ременные в EQUEL.  Он выглядит так:


                              - 7 -








EEQQUUEELL((QQUUEELL))     ССУУББДД РРУУББИИНН.. ООппееррааттооррыы QQUUEELL ДДЕЕММООСС      EEQQUUEELL((QQUUEELL))


      #### ppaarraamm rreettrriieevvee ((_f_o_r_m,,_a_r_g_v)) [wwhheerree _у_с_л_о_в_и_е]
      #### {{
      _С_и-_б_л_о_к
      #### }}

     Отличие в том, что список выборки  задается  параметрически,
     причем формат должен иметь вид:

      ""%%<_ф_о_р_м_а_т>==_в_ы_р_а_ж_е_н_и_е, ...""

     Каждый элемент результирующего списка начинается  с  формата
     очередной  переменной  в  массиве аргументов и означает, что
     значение выражения будет присваиваться этой переменной в со-
     ответствии  с указанным форматом.  В остальном оператор ана-
     логичен предыдущему.

     Пример:

      char *av[] = { &long_var,         &name[0],         &flt };
      char *form="%i4=rel.num, %c=rel.name, %f4=rel.val";
      ...
      ## param retrieve (form, av) where rel.count > 10
      ##{
      printf("Num=%ldname=%sval=%g0, long_var, name, flt);
      ##}

     В результате для каждой найденной записи из отношения  `rel'
     будут напечатаны поля `num', `name', `val'.

1100.. ББииббллииооттееккаа ии ппееррееммеенннныыее EEQQUUEELL
     При трансляции программы, полученной прекомпилятором  EQUEL,
     ее  необходимо  собирать  с  библиотекой `libq.a' (то есть с
     ключом `-lq').  Для  использования  этой  библиотеки  непос-
     редственно  из  операторов  Си  (а не только через операторы
     EQUEL) необходимо подключить файл вставок:

      # include <rubin/equel.h>

     При этом становятся доступными служебные подпрограммы EQUEL,
     управляющие  взаимодействием с базой данных, и ряд специаль-
     ных переменных EQUEL.

     Основные переменные:


          IIIIeerrrrffllaagg -    Признак ошибки (0 - ошибки  в  последнем
                         операторе не было);
          IIIIttuuppccnntt -     Число считанных или изменившихся в  пос-
                         леднем операторе кортежей;
          IIIIiinntteerruupptt -
          IIIIaabboorrtt -      Адрес пользовательских программ  реакции
                         на прерывание и на системную ошибку;


                              - 8 -








EEQQUUEELL((QQUUEELL))     ССУУББДД РРУУББИИНН.. ООппееррааттооррыы QQUUEELL ДДЕЕММООСС      EEQQUUEELL((QQUUEELL))


          IIIIpprriinntt__eerrrr -
          IIIIoouutt__eerrrr -    адреса пользовательских программ  печати
                         ошибки и печати очередной строки сообще-
                         ния об ошибке;

     Кроме того, в  библиотеку  входят  программы  преобразования
     дынных  (в особенности даты и времени) и программы работы со
     строками.  Подробное  описание  см.  в  разделе  lliibbqq((ffiilleess))
     справочного руководства.

1111.. ССииггннааллыы ии ппррееррыывваанниияя
     Прерывания при работе программы на EQUEL должны либо обраба-
     тываться самой системой EQUEL, либо игнорироваться. Перехват
     реакции на прерывания программой с помощью функции  `ssiiggnnaall'
     может привести к фатальным последствиям. Программа может вы-
     полнить свою реакцию на прерывание,  установив  адрес  соот-
     ветствующей функции в переменную

      extern int (*IIinterupt)();

     Единственным исключением является  случай,  когда  программа
     закрывает прерывания перед выполнением оператора `#### rruubbiinn',
     а затем устанавливает свою реакцию  на  прерывания.  В  этом
     случае  работа  базы данных прерываться не будет, и перехват
     прерываний не скажется на правильности функционирования сис-
     темы  (если  не нарушается требование об выходе из оператора
     выборки через оператор `bbrreeaakk').

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ

      libq(files), equel(demos), "РРууккооввооддссттввоо ппоо ппррооггррааммммииррооввааннииюю
     ннаа EEQQUUEELL".






















                              - 9 -








MMAACCRROOSS((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        MMAACCRROOSS((QQUUEELL))



ИИММЯЯ
     macros - средства макрообработки, поддерживаемые  терминаль-
     ным монитором

ООППИИССААННИИЕЕ
     Средства макрообработки, поддерживаемые терминальным монито-
     ром,  предоставляют возможности расширять язык запросов QUEL
     в соответствии со вкусами пользователей.  Макросредства поз-
     воляют  удалять  строки текста из потока запросов и заменять
     их другим текстом.  Кроме того, некоторые встроенные  макро-
     команды  изменяют  рабочую  среду на момент выполнения прог-
     раммы.

     ООссннооввнныыее ппоонняяттиияя

     Все макрокоманды состоят из двух частей - _ш_а_б_л_о_н_н_о_й и  _з_а_м_е_-
     _щ_а_ю_щ_е_й.   _Ш_а_б_л_о_н определяет когда должна быть вызвана макро-
     команда.  Например, шаблон ``_r_e_t'' приводит к  вызову  соот-
     ветствующей  макрокоманды,  когда во входном потоке встреча-
     ется слово ``_r_e_t''.  Когда встречается  такая  макрокоманда,
     то  шаблонная  часть  удаляется  и  заменяется на заменяющую
     часть макрокоманды.  Например, если замещающей частью макро-
     команды  ``_r_e_t''  была  ``_r_e_t_r_i_e_v_e'', то все вхождения слова
     ``_r_e_t''  во  входной  текст,  будут  заменены  словом  ``_r_e_-
     _t_r_i_e_v_e'', как, например, в операторе

             ret (p.all)

     Макрокоманды могут иметь параметры, помечаемые  знаком  дол-
     лара.   Например, шаблон ``_g_e_t $_1'' вызывает запуск макроко-
     манды по слову ``_g_e_t'' за которым может следовать любое дру-
     гое  слово.   Слово,  следующее  за ``_g_e_t'' запоминается для
     дальнейшего использования.  Например, если замещающая  часть
     макрокоманды ``_g_e_t'' была:

             retrieve (p.all) where p.pnum = $1

     то в этом случае, при печати ``_g_e_t _3_5'',  должна  выбираться
     вся  информация о запасной части под номером 35.  (см. отно-
     шение parts)

     ООппррееддееллееннииее ммааккррооккооммаанндд

     Макрокоманды определяются  специальной  макрокомандой  ``_d_e_-
     _f_i_n_e''.   Макрокоманда ``_d_e_f_i_n_e'' имеет (примерно) такой об-
     щий формат:

             {{ddeeffiinnee;; $_t;; $_r}}

     где $_t и $_r -  это  соответственно  шаблонная  и  замещающая
     части.


                              - 1 -








MMAACCRROOSS((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        MMAACCRROOSS((QQUUEELL))


     Приведем несколько примеров.  Обсуждавшаяся  ранее  макроко-
     манда ``_r_e_t'' определяется следующим образом:

             {define; ret; retrieve}

     После того, как эта последовательность считается,  макропро-
     цессор  удаляет все, находящееся между {{}}, и обновляет неко-
     торые таблицы таким образом, что ``_r_e_t'' будет распознано  и
     заменено  словом ``_r_e_t_r_i_e_v_e''.  Макрокоманда ``_d_e_f_i_n_e'', за-
     мещаемая пустой строкой, будет воспринята как исчезнувшая.

     Рассмотрим работу макропроцессора на примере полезной макро-
     команды, сокращающей указание переменной для отношения.  Она
     может быть определена так:

             {define; rg $v $r; range of $v is $r}

     По этой макрокоманде слово ``_r_g'', за  которым  следуют  два
     слова,  должно  быть заменено словами ``_r_a_n_g_e _o_f'', за кото-
     рыми будет следовать слово, стоящее первым после ``_r_g'', за-
     тем  слово  ``_i_s'',  и, наконец, слово, стоящее вторым после
     ``_r_g''.  Т.е., входная строка

             rg p parts

     будет преобразована

             range of p is parts


     ППррооццеесссс ввыыччииссллеенниияя

     Точно так же, как и запросы накапливающиеся в буфере, но  не
     выполняющиеся  до  подачи  команды  монитору, так и оператор
     ``_d_e_f_i_n_e'' не обрабатывается сразу после ввода.  До тех пор,
     пока не будет вычислен буфер запросов никакой обработки мак-
     роопределений не производится.  Оператор define  вычисляется
     после  выполнения команд монитора \\ggoo или \\eevvaall.  Буфер зап-
     росов вычисляется по командам \\ggoo, \\lliisstt, и \\eevvaall; \\ggoo посы-
     лает  результаты  в РУБИН, \\lliisstt печатает их на терминале, а
     \\eevvaall возвращает результаты макроподстановки в буфер  запро-
     сов.

     Макроопределения обязательно должны быть вычислены,  в  про-
     тивном  случае  они  как бы вообще отсутствуют.  Ниже приво-
     дится стандартный способ определения макрокоманды:

             {define . . . }
             \eval
             \reset

     Если команда \\eevvaall будет пропущена,  макрокоманда  не  будет


                              - 2 -








MMAACCRROOSS((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        MMAACCRROOSS((QQUUEELL))


     вычислена.

     ЭЭккррааннииррооввааннииее

     Иногда строки символов должны пропускаться  макропроцессором
     без  обработки. В таких случаях для выделения необрабатывае-
     мого символьного текста, используются знаки прямых и  обрат-
     ных  кавычек `` и ''.  Например, для того, чтобы слово ``_r_e_t''
     не преобразовывалсь в слово  ``_r_e_t_r_i_e_v_e''  оно  должно  быть
     забрано в кавычки

             `ret'

     Кроме того, экранирование применяется для образования  пара-
     метров.  Если параметр состоит более, чем из одного слова, а
     синтаксис допускает параметр,  состоящий  только  из  одного
     слова, то образующую параметр цепочку, заключают в одинарные
     кавычки.

     Символ обратной косой черты \\ экранирует только следующий за
     ним символ (подобно заключению символа в одинарные кавычки).
     В частности, прямая одинарная кавычка может использоваться в
     качестве обычного символа, если ей предшествует обратная ко-
     сая черта.

     Поскольку  макрокоманды  должны  состоять  только  из  одной
     строки,  символ \\ используется в конце строки для маскирова-
     ния символа новой строки.  Например,  чтобы  ввести  длинную
     макрокоманду ``_g_e_t'' следует напечатать:
             {define; get $n; retrieve (e.all ) \
             where e.name = "$n"}

     \\ всегда экранирует следующий символ, даже если этим  симво-
     лом  является  \\.  Поэтому, чтобы получить сам символ \\ вве-
     дите его дважды.

     ЕЕщщее оо ппааррааммееттрраахх

     Параметры могут и не ограничиваться одним словом.  Например,
     в шаблоне описания оператора define:

             {define; $t; $r}

     Параметр $_t оканчивается первой точкой с запятой, а параметр
     $_r  оканчивается первой правой фигурной скобкой.  Общее пра-
     вило такое: если символ, следующий за обозначением параметра
     в  шаблоне  макро,  не является символом пробела, табуляции,
     новой строки или конца шаблона (;), то этот символ  является
     признаком  конца параметра при подстановке; иначе в качестве
     параметра подставляется очередное слово.

     Так же, как и у всех хороших правил, у  этого  правила  есть


                              - 3 -








MMAACCRROOSS((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        MMAACCRROOSS((QQUUEELL))


     исключения.   Т.к. системные макрокоманды всегда заключаются
     в фигурные скобки, макропроцессор думает, что для них соблю-
     дается правильная вложенность.  Так, в операторе

             {define; x; {sysfn}}

     первая правая фигурная скобка будет закрывать ``_s_y_s_f_n'' а не
     ``_d_e_f_i_n_e''.  А правильное макроопределение будет таким:

             {define; x; `{sysfn}'}


     Слова определяются обычным образом, как  цепочки,  состоящие
     из букв, цифр и символов подчеркивания.

     ВВссттррооеенннныыее ммааккррооккооммааннддыы

     В системе имеются различные встроенные макрокоманды.  В сле-
     дующем  далее  описании  некоторые  из параметров помечаются
     двумя знаками доллара, а не одним.  Это об'ясняется  в  раз-
     деле о предварительном просмотре параметров.

     {{ddeeffiinnee;; $$_t; $$_r}} определяет  макрокоманду  описанным  выше
     способом.  Проводится специальная обработка шаблонной части;
     это будет обсуждаться в следующем разделе.

     {{rraawwddeeffiinnee;; $$_t;; $$_r}} - другая форма определения: при  таком
     определении специальная обработка уже не проводится.

     {{rreemmoovvee;; $$_n}} удаляет макрокоманду с именем $_n.   Так  можно
     удалить больше одной макрокоманды, т.к. этот макрооператор в
     действительности удаляет все макрокоманды, имена которых при
     некоторых  обстоятельствах  могут  подпадать под определение
     аргумента $n.  Например, ввод следующих макроопределений

             {define; get part $n; . . . }
             {define; get emp $x; . . . }
             {remove; get}

     приведет к уничтожению обоих макроопределений.  А вызов

             {remove; get part}

     удалит только первую макрокоманду.

     {{ttyyppee $$_s}} выводит $_s на терминал.

     {{rreeaadd $$_s}} печатает $_s и затем считывает строку с терминала.
     Считанная  с терминала строка замещает макрокоманду.  Макро-
     команда ``{_r_e_a_d_c_o_u_n_t}'' определяется  как  содержащий  число
     считанных  символов.   Если  введен  символ Control-D (конец
     файла), то значением макрокоманды становится -1, если введен


                              - 4 -








MMAACCRROOSS((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        MMAACCRROOSS((QQUUEELL))


     символ  новой  строки,  то значением макрокоманды стaновится
     ноль, и т.д.

     {{rreeaaddddeeffiinnee;; $$_n;; $$_s}} также печатает $_s и считывает строку,
     но  помещает  строку в макрокоманду с именем $_n.  Замещающий
     текст - число символов в строке.  {{rreeaaddccoouunntt}} тем  не  менее
     остается определенным, т.е. сохраняет свое значение.

     {{iiffssaammee;; $$_a;; $$_b;; $_t;; $_f}} сравнивает строки $_a и $_b.   Если
     они  полностью  совпадают,  то замещающим текстом становится
     $_t, в противном случае - $_f.

     {{iiffeeqq;; $$_a;; $$_b;; $_t;; $_f}} работает аналогично, но  производит
     численное сравнение.

     {{iiffggtt;; $$_a;; $$_b;; $_t;; $_f}} подобно iiffeeqq, но проверяется, чтобы
     $_a было строго больше чем $_b.

     {{ssuubbssttrr;; $$_f;; $$_t;; $$_s}} возвращает часть строки $_s, располо-
     женную  между  символами в позициях $_f и $_t, нумерующимися с
     единицы.  Если $_f или $_t находятся вне диапазона, то они, по
     мере возможности, помещаются в диапазон.

     {{dduummpp;; $$_n}} возвращает значение макрокоманды  (или  макроко-
     манд),  соответствующих $_n, используя алгоритм работы макро-
     команды remove.  Результатом вывода является оператор rraawwddee--
     ffiinnee,  для  того,  чтобы он мог быть считан обратно.  {{dduummpp}}
     без аргументов выгружает все макрокоманды.

     ММееттаассииммввооллыы

     Некоторые символы используются макропроцессором  специальным
     образом.   Как  правило, вы их даже не будете видеть, но они
     могут появиться в выводе команды dump, и могут  иногда  быть
     использованы для создания весьма причудливых макрокоманд.

     \\|| соответствует любому числу пробелов, знаков табулции  или
     символов новой строки.  Он даже может представлять ноль про-
     белов, \\ и \\, но только между словами, как в  случае  знаков
     препинания.   Например, \\|| будет соответствовать месту между
     последним символом слова и следующей за ним запятой.

     \\^^ соответствует точно одному пробелу, знаку  табуляции  или
     символу новой строки.

     \\&& соответствует точно нолю пробелов, знаков  табуляции  или
     символов новой строки, но только между словами.

     ППррооццеесссс ооппррееддееллеенниияя

     Когда вы определяете свою  макрокоманду,  используя  ddeeffiinnee,
     выполняются  некоторые  действия  по  обработке определения.


                              - 5 -








MMAACCRROOSS((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        MMAACCRROOSS((QQUUEELL))


     Отметим, что ddeeffiinnee не является функционально полной  макро-
     командой (т.е. она не позволяет определить произвольный шаб-
     лон), но все же отвечает  большинству  требований.  Если  от
     макрокоманды  при определении шаблона требуется большая мощ-
     ность, то пользуются макрокомандой rraawwddeeffiinnee; отличие ddeeffiinnee
     от  rraawwddeeffiinnee состоит в том, что в ddeeffiinnee определяется обра-
     зец, который ППРРЕЕООББРРААЗЗУУЕЕТТССЯЯ КК ШШААББЛЛООННУУ, а rraawwddeeffiinnee явным  об-
     разом ЗЗААДДААЕЕТТ ШШААББЛЛООНН со всеми метасимволами.  Однако, пользо-
     ваться rraawwddeeffiinnee нужно достаточно аккуратно, т.к. можно  на-
     сажать ошибок в самых неожиданных местах.

     В шаблонной части макрокоманды ddeeffiinnee все последовательности
     пробелов,  символов табуляции и символов новой строки, также
     как и все ``_н_е_п_р_о_б_е_л_ы'' между словами, сворачиваются в  сим-
     вол \\||.  Если шаблон оканчивается параметром, в конец добав-
     ляется символ \\&&.

     Если необходимо явно обозначить табуляцию или новую  строку,
     используйте  символы  \\tt  или  \\nn соответственно.  Например,
     макрокоманда, которая  читает всю вводимую строку и  интерп-
     ретирует ее, как имя служащего, может быть определен так:

             {define; get $n\n; \
                 ret (e.all) where e.name = "$n"}

     Этой макрокомандой можно пользоваться следующим образом: на-
     печатав

             get *Stan*

     вы получите информацию о каждом служащем, имя  которого  со-
     держит ``_S_t_a_n''.  Попутно заметим, что было бы полезно вклю-
     чить в определение макро ``_g_e_t'' макро ``_r_e_t''.

     ППррееддввааррииттееллььннааяя ооббррааббооттккаа ппааррааммееттрроовв

     Бывает необходимо провести макрообработку  параметра,  перед
     его  использованием  в замещающей части.  Это особенно важно
     при использовании некоторых встроенных макрокоманд.

     Для выполнения предварительной макрообработки  нужно  соблю-
     дать  два  правила:  Первое:  параметр в шаблоне должен быть
     указан с двумя _з_н_а_к_а_м_и _д_о_л_л_а_р_а вместо одного; и второе: фак-
     тический  параметр  должен начинаться с символа "комерческий
     at" ``@@'', который при обработке опускается.

     Примеры  предварительной  макрообработки  рассматриваются  в
     разделе ``ССппееццииааллььнныыее ммааккррооккооммааннддыы''.






                              - 6 -








MMAACCRROOSS((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        MMAACCRROOSS((QQUUEELL))


     ССппееццииааллььнныыее ммааккррооккооммааннддыы

     Некоторые специальные макрокоманды используются терминальным
     монитором  для управления средой и возврата результата поль-
     зователю.

     {{bbeeggiinnttrraapp}} выполняется в начале выполнения запроса.

     {{eennddttrraapp}} выполняется после того, как тело  запроса  переда-
     ется РУБИН.

     {{ccoonnttiinnuueettrraapp}} выполняется после полного выполнения запроса.
     Разница  между  ним и {{eennddttrraapp}} состоит в том, что {{ееnnddttrraapp}}
     выполняется после того, как запрос был подготовлен к  выпол-
     нению,  но  перед его выполнением, а {{ccoonnttiinnuueettrraapp}} выполня-
     ется после выполнения запроса.

     {{eeddiittoorr}} его значение определяет полное имя программы редак-
     тора, используемого в команде \\eeddiitt.

     {{sshheellll}} его значение определяет  полное  имя  интерпретатора
     shell для использования в команде \\sshheellll.

     {{ttuupplleeccoouunntt}} его значение устанавливается  после  выполнения
     каждого запроса (но перед тем как выполнится {{ccoonnttiinnuueettrraapp}})
     и равно числу кортежей, которые удовлетворяют  условию  зап-
     роса  в команде retrieve или числу измененных кортежей.  Эта
     макрокоманда не работает для  обслуживающих  программ  СУБД.
     Если  одновременно  выполняются  несколько  запросов, то его
     значение равняется  числу  кортежей,  которые  удовлетворяют
     последнему выполненному запросу.

     Например, для печати числа рассматривавшихся в запросе  кор-
     тежей вы должны напечатать:
             {define; {begintrap}; {remove; {tuplecount}}}
             {define; {continuetrap}; \
                {ifsame; @{tuplecount}; {tuplecount};; \
                  {type @{tuplecount} tuples touched}}}

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     monitor(quel)













                              - 7 -








QQUUEELL((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          QQUUEELL((QQUUEELL))



ИИММЯЯ
     quel - QQUUEEry LLanguage (язык запросов) РУБИН

ООППИИССААННИИЕЕ
     В разделе приводится полное описание синтаксиса QUEL.  Конк-
     ретные  операторы  и  команды QUEL описаны в соответствующих
     разделах документации; этот раздел описывает  синтаксические
     классы, из элементов которых строятся операторы языка запро-
     сов QUEL.  Введение в язык QUEL содержится в отдельном доку-
     менте: ""ВВввееддееннииее вв яяззыыкк QQUUEELL"".

     1. ККооммммееннттаарриийй

     Комментарий это  последовательность  символов,  ограниченная
     слева ``//**'' и справа ``**//'':

     /* Это комментарий */

     2. ИИддееннттииффииккааттооррыы ((ииммееннаа))

     Имена в QUEL - это последовательности не  более  чем  из  12
     букв  или цифр, начинающиеся с буквы. Знак подчеркивания (__)
     считается буквой.  Все заглавные буквы, появляющиеся  везде,
     исключая  строки,  автоматически и без сообщений перекодиру-
     ются в свои строчные эквивалент, если только при вызове сис-
     темы этот режим не отменен (см. rubin(demos)).

     3. ССллуужжееббнныыее ссллоовваа

     Следующие идентификаторы зарезервированы для использования в
     качестве служебных слов и иначе использоваться не могут:

          aabbss                 aallll                 aanndd
          aannyy                 aappppeenndd              aasscciiii
          aatt                  aattaann                aavvgg
          aavvgguu                bbyy                  ccoonnccaatt
          ccooppyy                ccooss                 ccoouunntt
          ccoouunnttuu              ccrreeaattee              ddeeffiinnee
          ddeelleettee              ddeessttrrooyy             eexxpp
          ffllooaatt44              ffllooaatt88              ffrroomm
          ggaammmmaa               hheellpp                iinn
          iinnddeexx               iinntt11                iinntt22
          iinntt44                iinntteeggrriittyy           iinnttoo
          iiss                  lloogg                 mmaaxx
          mmiinn                 mmoodd                 mmooddiiffyy
          nnoott                 ooff                  oonn
          oonnttoo                oorr                  ppeerrmmiitt
          pprriinntt               rraannggee               rreeppllaaccee
          rreettrriieevvee            ssaavvee                ssiinn
          ssqqrrtt                ssuumm                 ssuummuu
          ttoo                  uunniiqquuee              uunnttiill


                              - 1 -








QQUUEELL((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          QQUUEELL((QQUUEELL))


          vviieeww                wwhheerree
          ddaattee44               cchhaarr44               ffrroomm__ddaattee
          ttoo__ddaattee             ffrroomm__ttiimmee           ttoo__ttiimmee
          sseerr__nneexxtt            sseerr__llaasstt            sseerr__iinniitt

     44.. ВВыырраажжеенниияя

     Выражением называется один из следующих об'ектов:

          _к_о_н_с_т_а_н_т_а
          _а_т_р_и_б_у_т
          _ф_у_н_к_ц_и_о_н_а_л_ь_н_о_е _в_ы_р_а_ж_е_н_и_е
          _а_г_р_е_г_а_т _и_л_и _а_г_р_е_г_а_т_н_а_я _ф_у_н_к_ц_и_я
          _к_о_м_б_и_н_а_ц_и_я _ч_и_с_л_о_в_ы_х _в_ы_р_а_ж_е_н_и_й _и _а_р_и_ф_м_е_т_и_ч_е_с_к_и_х _о_п_е_р_а_т_о_р_о_в


     В данном руководстве на произвольное выражение ссылаются  по
     имени _в_ы_р_а_ж_е_н_и_е.

     5. ФФооррммааттыы

     Каждое _в_ы_р_а_ж_е_н_и_е имеет формат, обозначаемый  буквой  (cc,,  ii,,
     или ff,, для символьных, целых и данных с плавающей точкой со-
     ответственно), и число, указывающее количество байтов, отво-
     димых  под об'ект данного типа. Кроме того, есть еще форматы
     ddaattee и ttiimmee, которые могут также быть записаны  как  _d_4  или
     _m_4,  специально для хранения даты и времени.  В текущей вер-
     сии поддерживаются перечисленные ниже  форматы.   В  скобках
     указываются диапазоны значений, принимаемые соответствующими
     числовыми типами:

          cc11 -- cc225555      символьные данные длиной 1-255 символов.
          ii11             1-байтовое целое (-128 до +127)
          ii22             2-байтовое целое (-32768 до +32767)
          ii44             4-байтовое  целое   (-2.147.483.648   до
                         +2.147.483.647)
          ff44             4-байтовое число с плавающей  точкой  (-
                         10**38  до +10**38, 7 знаков после запя-
                         той)
          ff88             8-байтовое число с плавающей  точкой  (-
                         10**38 до +10**38, 17 знаков после запя-
                         той)
          ddaattee           4-х байтовое представление даты  в  виде
                         числа  дней от 1 января 0000 года по но-
                         вому стилю;
          ttiimmee           4-х байтовое представление времени в се-
                         кундах.

     Один числовой формат может быть преобразован в любой  другой
     числовой формат или просто заменен на него.




                              - 2 -








QQUUEELL((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          QQUUEELL((QQUUEELL))


     6. ППррееооббррааззооввааннииее ттииппоовв

     При работе с двумя числовыми доменами различных типов  РУБИН
     осуществляет  необходимые преобразования для приведения их к
     одному типу.

     При работе с целым числом и числом с плавающей точкой, перед
     выполнением операции целое преобразуется в число с плавающей
     точкой.  При работе с двумя целыми разной длины, целое мень-
     шей  длины  преобразуется  к  длине  большего.  При работе с
     двумя числами с плавающей точкой разной длины, большее  пре-
     образуется  в  меньшее.   При  работе с датой и временем они
     рассматриваются просто как целые числа формата ii44, а резуль-
     тату присваивается тип ddaattee, если хотя бы один из аргументов
     операции имел такой тип, и тип ttiimmee, если один из аргументов
     операции имел такой тип и тип результата не ddaattee.

     Следующая таблица описывает все возможные комбинации:

                 i1      i2      i4      f4      f8

         i1 -    i1      i2      i4      f4      f8
         i2 -    i2      i2      i4      f4      f8
         i4 -    i4      i4      i4      f4      f8
         f4 -    f4      f4      f4      f4      f4
         f8 -    f8      f8      f8      f4      f8

     В РУБИН имеются 7 операторов преобразования типов,  предназ-
     наченных для блокировки проводящихся по умолчанию преобразо-
     ваний типов, и еще 4 функции преобразования даты  и  времени
     по шаблону.  Операторы:

         iinntt11((_в_ы_р_а_ж_е_н_и_е))   результирующий тип ii11
         iinntt22((_в_ы_р_а_ж_е_н_и_е))   результирующий тип ii22
         iinntt44((_в_ы_р_а_ж_е_н_и_е))   результирующий тип ii44
         ffllooaatt44((_в_ы_р_а_ж_е_н_и_е)) результирующий тип ff44
         ffllooaatt88((_в_ы_р_а_ж_е_н_и_е)) результирующий тип ff88
         ttiimmee44((_в_ы_р_а_ж_е_н_и_е))  результирующий тип ttiimmee
         ddaattee44((_в_ы_р_а_ж_е_н_и_е))  результирующий тип ddaattee
         aasscciiii((_в_ы_р_а_ж_е_н_и_е))  результирующий тип cchhaarr
         ffrroomm__ddaattee((_в_ы_р_а_ж_е_н_и_е,,_ш_а_б_л_о_н))   результат cchhaarr
         ffrroomm__ttiimmee((_в_ы_р_а_ж_е_н_и_е,,_ш_а_б_л_о_н))   результат cchhaarr
         ttoo__ddaattee((_с_т_р_о_к_а,,_ш_а_б_л_о_н))        результат ddaattee
         ttoo__ttiimmee((_с_т_р_о_к_а,,_ш_а_б_л_о_н))        результат ttiimmee

     Операторы преобразования типа преобразуют свои аргументы _в_ы_-
     _р_а_ж_е_н_и_е  в  требуемый  тип.   _В_ы_р_а_ж_е_н_и_е может быть всем, чем
     угодно, в том числе и символом.  Если значение значение сим-
     вола  не  может быть преобразовано в числовое, то происходит
     ошибка и обработка прекращается.  Это может произойти только
     в  том случае, когда некорректен синтаксис значения символа.
     Преобразование в символьный  вид  производится  по  правилам


                              - 3 -








QQUUEELL((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          QQUUEELL((QQUUEELL))


     умолчания,  которые могут быть изменены при вызове базы дан-
     ных.  Преобразования даты и времени подробно описаны в  раз-
     деле date(quel) справочного руководства.

     При преобразованиях типов проверка на переполнение не произ-
     водится.

     7. ККооннссттааннттыы

     Существует семь типов констант,  соответстующих  семи  типам
     данных QUEL, используемых в РУБИН.

     7.1. ССттррооккии

     Строка в QUEL это последовательность не  более  чем  из  255
     символов  кода  ASCII, ограниченная двойными кавычками ( "" ""
     ). Прописные буквы в строках не переводятся в строчные  (как
     в  идентификаторах).  Если необходимо поместить в строку ка-
     вычки, то перед ними необходимо ставить символ `\\' .  Анало-
     гичное соглашение принято и для самого символа `\\'.

     Внутри строк разрешены только печатные символы.   Непечатные
     символы (т.е. управляющие) преобразуются в пробелы.

     7.2. ЦЦееллыыее ккооннссттааннттыы

     Целые константы в QUEL лежат в диапазоне  от  -2.147.483.647
     до  +2.147.483.647.   Целые  константы, не попадающие в этот
     диапазон значений, преобразуются в числа с плавающей точкой.
     Если  целое число меньше, чем 32.767 или больше чем -32.767,
     то оно будет представлено как двухбайтовое целое.  В против-
     ном случае оно будет преобразовано в четырехбайтовое целое.

     7.3. ККооннссттааннттыы сс ппллааввааюющщеейй ттооччккоойй

     Константы с плавающей точкой состоят из целой  части,  деся-
     тичной  точки и дробной части, символов e или E и целого по-
     казателя (экспоненты), возможно, со  знаком.  Эти  константы
     представляются в следующем формате:

             {<_ц_и_ф_р_а>} [.<_ц_и_ф_р_а>] [ee||EE [+|-] {<_ц_и_ф_р_а>}]

     Где <_ц_и_ф_р_а> ооббооззннааччааеетт ццииффрруу,, [] ооббооззннааччааеетт нноолльь  ииллии  ооддиинн,,
     {}  обозначает ноль или более, и | обозначает альтернативное
     представление.  Экспонента без мантиссы, рассматривается как
     имеющая  мантиссу  1.  В цепочке, представляющей константы с
     плавающей точкой, не должно быть  никаких  других  символов.
     Принимается, что константы с плавающей точкой это величины с
     двойной точностью,  принимающие  значения  из  диапазона  от
     -10**38 до +10**38 с точностью до 17 десятичных знаков.




                              - 4 -








QQUUEELL((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          QQUUEELL((QQUUEELL))


     7.3. ККооннссттааннттыы ттииппаа ddaattee ии ttiimmee

     Константы, описывающие дату, задаются следующим образом:

      ''_д_а_т_а__в__ф_о_р_м_а_т_е__п_о__у_м_о_л_ч_а_н_и_ю''

     Умолчания такие же, как и для функции ddaattee44. Если  умолчание
     для ввода/вывода даты не изменены при вызове, они такие:

      DDDD--MMOONN--YYYYYYYY

      DDDD - 2 цифры месяцв
      MMoonn - краткое 3-х буквенное обозначение месяцв
      YYYYYYYY - четырехзначный номер года

     Подробно  форматы  даты  и   времени   описаны   в   разделе
     date(quel); здесь только заметим, что название месяца должно
     начинаться с прописной  буквы,  может  быть  сокращенным  (3
     буквы)  или полным, на русском или английском языках. Напри-
     мер:

      12-Apr-1957
      22-Января-1960

     Константа, описывающая время, задается аналогично, ее  отли-
     чительной чертой является символ "::" в формате по умолчанию:

      '22:10:00'
      '02:12:20'

     Константы типа date и time преобразуются в численное  предс-
     тавление даты и времени, принятое в системе.

     7.4. ССииссттееммнныыее ккооннссттааннттыы

     Системные константы представляют собой специальные идентифи-
     каторы, с которыми связаны некоторые значения. Это ssyyssttiimmee -
     текущее время в формате ttiimmee, ssyyssddaattee - текущая дата в  фор-
     мате ddaattee, а также ddbbaa и uusseerr - константы типа c2, использу-
     емые для служебных целей (двухбуквенный идентификатор  поль-
     зователя и администратора базы данных).

     8. ААттррииииббууттыы

     Атрибутом является конструкция вида:

             ппееррееммееннннааяя..ддооммеенн

     _П_е_р_е_м_е_н_н_а_я означает некоторое  отношение  и  рассматривается
     как  представляющая строки или кортежи этого отношения.  Пе-
     ременная  связывается  с  отношением  посредством  оператора
     rraannggee, либо по умолчанию (если существует отношение, имя ко-


                              - 5 -








QQUUEELL((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          QQUUEELL((QQUUEELL))


     торого совпадает с именем переменной).  _Д_о_м_е_н это имя одного
     из  столбцов отношения, которое обозначается указанной _п_е_р_е_-
     _м_е_н_н_о_й.  Вместе они образуют атрибут, представляющий  значе-
     ния указанного домена.

     8.1. ССппееццииааллььнныыйй ддооммеенн TTIIDD

     В каждом отношении существует псевдо-атрибут - _t_i_d.  Он  со-
     держит  физический  адрес  кортежа в файле.  Домен _t_i_d (типа
     i4) не хранится в физической памяти, а вычисляется  при  вы-
     борке  данных  и может использоваться в операторе _r_e_t_r_i_e_v_e в
     списке атрибутов и в операторах  _r_e_p_l_a_c_e  ,    _r_e_t_r_i_e_v_e  или
     _d_e_l_e_t_e в квалификаторе условия вида

      where имя.tid = число

     для точного указания требуемого кортежа.

     9. ААррииффммееттииччеессккииее ооппееррааттооррыы

     Арифметические операторы в качестве операндов используют вы-
     ражения  численного  типа.   Унарные  операторы  выполняются
     справа налево; бинарные операторы - слева  направо.   Укажем
     операторы в порядке убывния их приоритета:

             +,-   (унарные) плюс, минус
             **    возведение в степень
             *,/   умножение, деление
             +,-   (бинарные) сложение, вычитание

     Для изменения порядка выполнения операций используются круг-
     лые  скобки.   Арифметическое переполнение и деление на ноль
     не проверяется при операциях над целыми.  Операции над  чис-
     лами  с плавающей точкой проверяются на переполнение, потерю
     значимости и деление на ноль только в том  случае,  если  на
     ЭВМ  имеются  и корректно используются ее аппаратные возмож-
     ности.


     10. ЦЦееллееввоойй ссппииссоокк

     Целевой список - заключенный в скобки список,  состоящий  из
     одного  или более элементов, разделенных запятыми, каждый из
     которых должен быть представлен в одной из следующих форм:

     a) _и_м_я__р_е_з_у_л_ь_т_а_т_а iiss _в_ы_р_а_ж_е_н_и_е

     _И_м_я__р_е_з_у_л_ь_т_а_т_а это имя создаваемого атрибута, или, в  случае
     операторов  изменения  (append, replace), имя уже существую-
     щего атрибута.  Знак равенства (``='') эквивалентен  iiss..   В
     случае, когда _в_ы_р_а_ж_е_н_и_е является чем-нибудь другим, чем один
     атрибут, такая форма должна  использоваться  для  присвоения


                              - 6 -








QQUUEELL((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          QQUUEELL((QQUUEELL))


     выражению имени результата.

     b) _а_т_р_и_б_у_т

     В случае использования  оператора  _r_e_t_r_i_e_v_e,  результирующий
     домен получает то же имя, что и имя выбираемого атрибута.  В
     случае  использования  операторов  обновления  (_a_p_p_e_n_d,  _r_e_-
     _p_l_a_c_e),  изменяемое  отношение должно иметь домены с теми же
     именами.

     В целевом списке для представления сразу всех доменов  может
     быть использовано ключевое слово aallll..  Например:

          range of e is employee
          retrieve (e.all) where e.salary > 10000

     при этом будут получены все домены  из  отношения  employee,
     кортежи  которых  удовлетворяют условию.  AAllll может быть ис-
     пользовано в целевом списке операторов  rreettrriieevvee  и  aappppeenndd..
     Домены будут храниться в порядке их ``создания'', т.е. в том
     порядке, в котором они перечислены в операторе ccrreeaattee..

     11. ООппееррааттооррыы ссррааввннеенниияя

     Операндами операторов сравнения могут быть любые выражения.

             <       (меньше)
             <=      (меньше или равно)
             >       (больше)
             >=      (больше или равно)
             =       (равно)
             !=      (не равно)

     Все они имеют одинаковый приоритет.  При сравнении  символь-
     ных  атрибутов все пробелы игнорируются.  Дата и время срав-
     ниваются, как и любыек целые числа.

     12. ЛЛооггииччеессккииее ооппееррааттооррыы

     Операндами логических операторов являются предложения;  опе-
     раторы выполняются слева направо:

             not     (логическое нет, отрицание)
             and     (логическое и, конъюнкция)
             or      (логическое или, дизъюнкция)

     Наивысший приоритет из этих трех операторов  имеет  оператор
     nnoott..   AAnndd  и  oorr имеют равный приоритет.  Для изменения по-
     рядка выполнения операторов пользуются скобками.





                              - 7 -








QQUUEELL((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          QQUUEELL((QQUUEELL))


     13. УУссллооввиияя

     _У_с_л_о_в_и_е состоит из произвольного числа предложений,  связан-
     ных логическими операторами.  Предложение - это пара выраже-
     ний, связанная логическим оператором:

             выражение оператор_сравнения выражение

     Для изменения порядка выполнения операторов пользуются скоб-
     ками.  Т.о. условие может иметь вид:

         _п_р_е_д_л_о_ж_е_н_и_е
         nnoott _у_с_л_о_в_и_е
         _у_с_л_о_в_и_е oorr _у_с_л_о_в_и_е
         _у_с_л_о_в_и_е aanndd _у_с_л_о_в_и_е
         ( _у_с_л_о_в_и_е )

     14. ФФууннккццииооннааллььнныыее ввыырраажжеенниияя

     _Ф_у_н_к_ц_и_о_н_а_л_ь_н_о_е _в_ы_р_а_ж_е_н_и_е состоит из имени функции, за  кото-
     рым  следует заключенный в скобки операнд или список операн-
     дов.  Функциональные выражения  могут  иметь  любой  уровень
     вложенности.  В следующем списке имеющихся функций (_n) обоз-
     начает выражение любого численного типа.  Формат  результата
     указывается справа.

          aabbss((_n)) -       такой же как и у _n (абсолютное значение)
          aasscciiii((_n)) -     символьная строка (преобразует  числа  в
                         символ)
          aattaann((_n)) -      f8 (арктангенс)
          ccoonnccaatt((_a,_b)) -  символьный (конкатенация  символов.  См.
                         16.2)
          ccooss((_n)) -       f8 (косинус)
          eexxpp((_n)) -       f8 (степень _n числа e)
          ggaammmmaa((_n)) -     f8 (гамма-функция)
          lloogg((_n)) -       f8 (натуральный логарифм)
          mmoodd((_n,_b)) -     такой же, как и у _b (_n по модулю _b. _n  и
                         _b должны быть i1, i2, или i4)
          ssiinn((_n)) -       f8 (синус)
          ssqqrrtt((_n)) -      f8 (квадратный корень)
          ffrroomm__ddaattee((_d)) - строка (вывод даты по шаблону)
          ffrroomm__ttiimmee((_t)) - строка (вывод времени по шаблону)
          ttoo__ddaattee((_s)) -   date (строка - в дату по шаблону)
          ttoo__ttiimmee((_s)) -   time (строка - во время по шаблону)
          sseerr__nneexxtt((_s)) -  i4 (получить следующее значение перемен-
                         ной)
          sseerr__llaasstt((_s)) -  i4 (получить последнее значение перемен-
                         ной)
          sseerr__sseett((_s)) -   i4 (установить новое  значение  перемен-
                         ной, получив старое)
     Подробное описание работы с переменными см. в serial(quel).



                              - 8 -








QQUUEELL((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          QQUUEELL((QQUUEELL))


     15. ААггррееггииррууюющщииее ввыырраажжеенниияя

     Агрегирующие выражения являются средством выполнения  вычис-
     лительных  операций над выделяемыми ими подмножествами атри-
     бутов.

     15.1. ААггррееггииррууюющщииее ооппееррааттооррыы

     Ниже перечислены определения агрегирующих функций.

          ccoouunntt -        (i4) подсчет всех вхождений
          ccoouunnttuu -       (i4) подсчет неповторяющихся вхождений
          ssuumm -          суммирование
          ssuummuu -         суммирование неповторяющихся значений
          aavvgg -          (f8) среднее (sum/count)
          aavvgguu -         (f8) среднее по всем различным значениям
                         (sumu/countu)
          mmaaxx -          максимум
          mmiinn -          минимум
          aannyy -          (i2) значение будет 1, если любой кортеж
                         удовлетворяет  условию, в противном слу-
                         чае - 0.

     15.2. ППррооссттоойй ааггррееггаатт

     _А_г_р_е_г_и_р_у_ю_щ_и_й _о_п_е_р_а_т_о_р (_в_ы_р_а_ж_е_н_и_е [ wwhheerree _у_с_л_о_в_и_е ])

     Вычисленным значением простого агрегата  является  скалярная
     величина.   _В_ы_р_а_ж_е_н_и_е вычисляется для набора кортежей, удов-
     летворяющих условию (или для всех кортежей из области дейст-
     вия выражения, если не задано условие).  Операторы _s_u_m и _a_v_g
     требуют чтобы _в_ы_р_а_ж_е_н_и_е было числового типа; _c_o_u_n_t, _a_n_y, _m_a_x
     и  _m_i_n допускают атрибут символьного типа, равно как и _в_ы_р_а_-
     _ж_е_н_и_е числового типа.

     _П_р_о_с_т_ы_е _а_г_р_е_г_а_т_ы _н_и_ч_е_м _н_е _с_в_я_з_а_н_ы _с  _о_с_т_а_л_ь_н_о_й  _ч_а_с_т_ь_ю  _з_а_п_-
     _р_о_с_а.  Т.е. они как-бы выделяются из запроса, обрабатываются
     отдельно и заменяются на свое скалярное значение.

     15.3. ААггррееггаатт ````aannyy''''

     Бывает полезно знать, существует ли кортеж,  удовлетворяющий
     некоторому  условию.   Для  этого используют агрегат ccoouunntt и
     проверяют, равно ли нолю возвращаемое им значение.   Исполь-
     зование  aannyy вместо ccoouunntt более эффективно, т.к.  дальнейшая
     обработка прекращается, как только встретится первый кортеж,
     удовлетворяющий условию.

     AAnnyy возвращает значение 1, если условие  принимает  значение
     истина и 0- в противном случае.




                              - 9 -








QQUUEELL((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          QQUUEELL((QQUUEELL))


     15.4. ААггррееггииррууюющщииее ффууннккццииии

             _А_г_р_е_г_и_р_у_ю_щ_и_й _о_п_е_р_а_т_о_р (_в_ы_р_а_ж_е_н_и_е bbyy _b_y__д_о_м_е_н
                     {, _b_y__д_о_м_е_н} [ wwhheerree _у_с_л_о_в_и_е ])

     Агрегирующие функции являются развитием идеи простых агрега-
     тов.  Оператор bbyy собирает (т.е. подразделяет) множество от-
     вечающих  условию  кортежей  по  значениям   из   указанного
     _b_y__д_о_м_е_н_а.   Если  в  запросе задано более одного _b_y__д_о_м_е_н_а,
     собранные значения являются об`единением отдельных  значений
     _b_y__д_о_м_е_н_о_в.   _В_ы_р_а_ж_е_н_и_е  -такое  же как в простых агрегатах.
     Результатом работы агрегирующей функции  является  множество
     собранных  значений,  по одному для каждого подмножества, на
     которые было разбито множество отвечающих условию  кортежей.
     Значение агрегата, использовавшееся во время вычисления зап-
     роса, является тем значением, которое связано с  той  частью
     атрибута,  которой соответствует обрабатываемый в данный мо-
     мент кортеж.

     В отличие от простых агрегатов, агрегатные функции связаны с
     остальной  частью запроса.  _B_y__с_п_и_с_о_к, отличающий агрегатные
     функции от простых агрегатов, глобален для запроса.   Домены
     в  _b_y__с_п_и_с_к_е  автоматически  связываются  с другими доменами
     запроса, из того же самого отношения.

     Пример:
           //** ВВыыддааттьь ссррееддннюююю ззааррааббооттннууюю ппллааттуу ддлляя ссллуужжаащщиихх,,
           ррааббооттааюющщиихх уу ккаажжддооггоо ууппррааввлляяюющщееггоо **//
           rraannggee ooff ee iiss eemmppllooyyeeee
           rreettrriieevvee ((ee..mmaannaaggeerr,,
                     aavveessaall==aavvgg((ee..ssaallaarryy bbyy ee..mmaannaaggeerr))))

     15.5 ААггррееггааттыы ннаа ууннииккааллььнныыхх ззннааччеенниияяхх

     Иногда необходимо проводить агрегирующие действия  над  уни-
     кальными значениями выражения.  Агрегирующие операторы aavvgguu,
     ssuummuu и ccoouunnttuu удаляют повторяющиеся значения перед  выполне-
     нием.  Например:

             count(e.manager)

     подсчитывает общее  число  входящих  в  отношение  элементов
     _e._m_a_n_a_g_e_r а

             countu(e.manager)

     подсчитывает,   сколько   существует   уникальных   значений
     _e._m_a_n_a_g_e_r






                             - 10 -








QQUUEELL((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          QQUUEELL((QQUUEELL))


     16. Специальные символьные операторы.

     В QUEL имеются средства, специально предназначенные для  ра-
     боты с символьными доменами.

     16.1 ММееттаассииммввооллыы,, ииссппооллььззууееммыыее вв шшааббллооннаахх

     Имеются четыре символа, принимающих специальные значения,  в
     случае их использования в символьных константах (строках):

         **     соответствует любой строке,  содержащей  ноль  или
               более символов.
         ??     соответствует одному любому символу
         [[..]]  соответствует любому символу  из  перечисленных  в
               квадратных скобках.

     Эти символы могут быть использованы в любой  комбинации  для
     формирования проверяющих условий.  Например:

          where e.name = "*" - соответствует любому имени.
          where e.name = "E*" - соответствует любому имени, начи-
                              нающемуся с "E".
          where e.name = "*ein" - соответствует всем именам, кон-
                              чающимся на "ein".
          where  e.name  =  "*[aeiou]*"  -  соответствует  любому
                              имени,                  содержащему
                                                         хотя  бы
                              одну гласную.
          where e.name = "Allman?" - соответствует  любому  имени
                              из  семи букв,
                              начинающемуся с "Allman".
          where e.name = "[A-J]*" - соответствует  любому  имени,
                              начинающемуся                     с
                              букв A,B,...J.

     Специальное значение описанных символов можно отменять, пос-
     тавив  перед  ними  `\'.   Так ``\*'' означает символ ``*''.
     Если специальные символы появляются  в  целевом  списке,  их
     специальные значения экранируются символом `\'.  Например:

             title = "\*\*\* rubin \*\*\*"

     правильный способ присвоения строки ``*** rubin ***'' домену
     ``title''.

     16.2 ССццееппллееннииее ((ккооннккааттееннаацциияя))

     Имеется оператор сцепления, формирующий одну символьную  це-
     почку  из  двух.   Его  синтаксис  имеет  вид:''concat(цеп1,
     цеп2)''.  Размер новой символьной цепочки -  сумма  размеров
     двух первоначальных.  Пробелы в конце первой цепочки отсека-
     ются, второе поле сцепляется с первым, а дополнение до  сум-


                             - 11 -








QQUUEELL((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          QQUUEELL((QQUUEELL))


     марной  длины  производится  пробелами. Однако результат ни-
     когда не усекается до нулевой длины.  Concat может быть про-
     извольным образом вложено в другие concat. Например:

           имя = concat(concat(x.второеимя, ","), x.первоеимя)

     будет сцеплять x.второеимя с запятой и затем с x.первоеимя.

     16.3 ФФууннккцциияя aasscciiii ((ппррееооббррааззооввааннииее ччииссеелл вв ссттррооккии))

     Функция aasscciiii используется для преобразования числового поля
     в  его символьное представление.  Это проименяется при срав-
     нении числового значения с символьным.  Например:

             retrieve ( ... )
                     where x.симвдомен = ascii(x.числдомен)

     AAsscciiii может иметь своим аргументом  и  символьную  величину.
     Результатом  будет та же неизменившаяся символьная величина.
     Форматы числовых преобразований определяются  форматами  вы-
     вода (см. rubin(демос)).

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     append(quel),  delete(quel),   range(quel),   replace(quel),
     retrieve(quel), date(quel), serial(quel), rubin(демос)

ООШШИИББККИИ ИИ ООГГРРААННИИЧЧЕЕННИИЯЯ
     Максимальное количество переменных, которые могут  присутст-
     вовать в одном запросе - 10.

     Численное переполнение, потеря значимости и деление на  ноль
     не отлавливаются.

     При преобразованиях из одного числового типа в  другой  про-
     верка на переполнение не производится.



















                             - 12 -








AAPPPPEENNDD((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        AAPPPPEENNDD((QQUUEELL))



ИИММЯЯ
     append - добавить кортежи к отношению

ФФООРРММААТТ
     aappppeenndd [ttoo] имя_отн (список_объектов) [wwhheerree условие]

ООППИИССААННИИЕЕ
     _A_p_p_e_n_d добавляет  кортежи,  которые  удовлетворяют  _у_с_л_о_в_и_ю.
     _И_м_я__о_т_н  должно представлять собой имя существующего отноше-
     ния.  _С_п_и_с_о_к__о_б_ъ_е_к_т_о_в задает значения атрибутов  тех  корте-
     жей, которые должны быть добавлены к отношению _и_м_я__о_т_н.  Ат-
     рибуты могут перечисляться в любом  порядке.   Атрибуты  ре-
     зультирующего   отношения,   которые   не   присутствуют   в
     _с_п_и_с_к_е__о_б_ъ_е_к_т_о_в, получают значение по умолчанию: 0 для  чис-
     ленных атрибутов или пробел для символьных атрибутов.

     Значения или выражения любого численного типа могут  исполь-
     зоваться  для  задания значения домена численного типа.  При
     этом происходит преобразование в результирующий тип  домена.
     Численные  значения  не  могут непосредственно приписываться
     символьным доменам.  Преобразование из численного в символь-
     ный  тип  может  быть произведено с использованием оператора
     aasscciiii (см. quel(quel)).  Символьные значения не могут непос-
     редственно  присваиваться численным доменам.  Для преобразо-
     вания символьных значений в  числовые,  используйте  функции
     iinntt11, iinntt22 и т.д. (см. quel(quel))

     Ключевое слово aallll может  использоваться  для  присоединения
     ввссеехх доменов отношения.

     Команда _a_p_p_e_n_d может запускаться только владельцем отношения
     или пользователем, имеющем разрешение _a_p_p_e_n_d на данное отно-
     шение.

ППРРИИММЕЕРР
     /* Ввести нового служащего Джонса, работающего для Смита */
        range of n is newemp
        append to emp(n.name, n.sal, mgr = "Smith", bdate = 1975-n.age)
                     where n.name = "Jones"
     /* Присоединить отношение newemp1 к newemp */
        range of n1 is newemp1
        append to newemp(n1.all)

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     copy(quel), permit(quel), quel(quel), retrieve(quel)

ДДИИААГГННООССТТИИККАА
     Использование выражения численного типа для определения зна-
     чения домена символьного типа или наоборот, приводит к выра-
     ботке диагностического сообщения.



                              - 1 -








AAPPPPEENNDD((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        AAPPPPEENNDD((QQUUEELL))


ООШШИИББККИИ
     Дублированные кортежи, присоединенные к отношению, хранимому
     как ''paged heap'' ("листованная куча"), не удаляются.



















































                              - 2 -








CCOOPPYY((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          CCOOPPYY((QQUUEELL))



ИИММЯЯ
     copy - копировать данные в/из отношения из/в файл ДЕМОС.

ФФООРРММААТТ
     ccooppyy имя_отн (имя_домена = формат {, имя_домена = формат })
               направление "имя_файла"

ООППИИССААННИИЕЕ
     _C_o_p_y перемещает данные между отношениями РУБИН  и  стандарт-
     ными  файлами  ДЕМОС.  _И_м_я__о_т_н это имя существующего отноше-
     ния.  В общем случае _и_м_я__д_о_м_е_н_а идентифицирует домен в отно-
     шении _и_м_я__о_т_н.  _Ф_о_р_м_а_т указывает формат файла ДЕМОС, который
     должен соответствовать каждому домену в отношении.   _Н_а_п_р_а_в_-
     _л_е_н_и_е
      - либо iinnttoo либо ffrroomm..  _И_м_я__ф_а_й_л_а - это  полное  имя  файла
     ДЕМОС.

     В копии ffrroomm из файла в отношение, отношение не должно иметь
     вторичного индекса.  Вы должны его присвоить сами, и он дол-
     жен быть обновляемым.

     _Н_е_л_ь_з_я производить копирование отношения,  которое  является
     виртуальным  (view).   Для  копии  iinnttoo  (в  файл ДЕМОС), вы
     должны быть либо владельцем отношения, либо отношение должно
     иметь  разрешение  на поиск для всех пользователей, либо все
     разрешения для всех пользователей.

     Форматы, разрешаемые при копировании :

     ii11,,ii22,,ii44 - данные хранятся как целые числа длиной 1, 2,  или
          4 байта в файле ДЕМОС.

     ff44,,ff88 - данные хранятся как числа с плавающей  точкой  (либо
          одинарной, либо удвоенной точности) в файле ДЕМОС.

     cc11,,cc22,,......,,cc225555 - данные хранятся как строка символов  фикси-
          рованной длины.

     cc00 - символьная строка переменной длины.

     dd00,,dd11,,......,,dd225555 - фиктивный домен.

     Соответствующие домены в отношении и файле ДЕМОС не  обязаны
     быть одного и того же типа или длины.  _C_o_p_y будет преобразо-
     вывать их  при  необходимости.   При  любом  преобразовании,
     кроме символа в символ, _c_o_p_y производит проверку на перепол-
     нение.  При преобразовании из символа в символ _c_o_p_y, при не-
     обходимости,  будет  заполнять  пробелами или усекать справа
     строку.

     В списке_объектов домены должны быть упорядочены таким обра-


                              - 1 -








CCOOPPYY((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          CCOOPPYY((QQUUEELL))


     зом, как они должны располагаться в файле ДЕМОС. Домены сог-
     ласуются по именам, таким образом порядок доменов в  отноше-
     нии и в файле ДЕМОС не обязан быть одним и тем же.

     _C_o_p_y также предусматривается для строк  переменной  длины  и
     фиктивных  доменов.   Предпринимаемые  действия  зависят  от
     того, производится ли копирование iinnttoo или копирование ffrroomm..
     Разделители для строк переменной длины и для фиктивных доме-
     нов могут быть выбраны из следующего списка:

         nnll - символ новой строки
         ttaabb - символ табулирования
         sspp - интервал
         nnuull или nnuullll - байт с кодом ноль
         ccoommmmaa - запятая
         ccoolloonn - двоеточие
         ddaasshh - тире
         llppaarreenn - левая скобка
         rrppaarreenn - правая скобка
         _x - любой единичный символ 'x'

     Специальное значение любого разделителя может быть  отменено
     предшествующим ему знаком `\'.  Спецификатор типа может быть
     в кавычках ("c0delim").  Это полезно, если  вы  желаете  ис-
     пользовать в качестве разделителя символ, который имеет спе-
     циальное значение для синтаксического анализатора QUEL.

     Когда _н_а_п_р_а_в_л_е_н_и_е - froм, _c_o_p_y присоединяет данные в отноше-
     ние  иизз  файла ДЕМОС.  Доменам в отношении РУБИН, которым не
     приписаны значения из файла ДЕМОС, приписываются значения по
     умолчанию:  ноль для численных доменов и пробел для символь-
     ных доменов.  Если производится копирование в этом направле-
     нии, то применимы следующие специальные значения:

     cc00_d_e_l_i_m - Данные в файле ДЕМОС - это символьная строка пере-
          менной длины, заканчивающаяся разделителем _d_e_l_i_m.  Если
          _d_e_l_i_m пропущен, то первая запятая, символ табуляции или
          символ  новой строки будет означать конец строки.  Раз-
          делитель не копируется.

          Например:
               pnum=c0 - строка,заканчивающаяся запятой, tab  или
               nl.
               pnum=c0nl - строка, заканчивающаяся nl.
               pnum=c0sp - строка, заканчивающаяся интервалом.
               pnum=c0z - строка, заканчивающаяся символом `z'.
               pnum="c0%" - строка, заканчивающаяся символом `%'.

          Разделитель может быть пропущен, если ему  предшествует
          символ  `\'.   Например,  при  использовании nnaammee == cc00,
          строка ``Blow\, Joe,'' будет  воспринята,  как  ``Blow,
          Joe''.


                              - 2 -








CCOOPPYY((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          CCOOPPYY((QQUUEELL))


     dd00_d_e_l_i_m - Данные в файле ДЕМОС - это символьная строка пере-
          менной  длины, разделяемая _d_e_l_i_m.  Строка считывается и
          отбрасывается.  Правила разделителя идентичны  правилам
          для cc00 и dd00..  Имя домена игнорируется.

     dd11,,dd22,,......,,dd225555 - Данные  в  файле  ДЕМОС  -  это  символьная
          строка фиксированной длины.  Цепочка считывается и отб-
          расывается.  Имя домена игнорируется.

     Когда используется направление iinnttoo,,  _c_o_p_y  передает  данные
     iinnttoo  в  файл ДЕМОС из отношения.  Если файл уже существует,
     он обнуляется перед началом копирования.  Когда  копирование
     производится  в этом направлении, применимы следующие специ-
     альные значения:

     cc00 - Значение домена преобразуется в символьную строку  фик-
          сированной длины и записывается в файл ДЕМОС.  Для сим-
          вольных доменов длина строки будет той же самой, что  и
          длина  домена.  Для численных доменов будут иметь место
          стандартные преобразования РУБИН,  как  это  определено
          флагами   `--dd',   `--tt',   `--ii',   `--ff',   и  '--cc'  (см.
          rubin(демос)).

     cc00_d_e_l_i_m - Домен будет преобразован согласно  указанным  выше
          правилам для cc00 .  Односимвольый разделитель будет вве-
          ден сразу же после домена.

     dd11,,dd22,,......,,dd225555 - Взятое имя домена должно быть именем разде-
          лителя.   Он  записывается в файл ДЕМОС 1 раз для dd11,, 2
          раза для dd22,, и т.д..

     dd00 - Этот формат игнорируется в копии iinnttoo..

     dd00_d_e_l_i_m _d_e_l_i_m - разделитель записывается в файл.  Имя домена
          игнорируется.


     Если в команде копирования не указываются домены (т.е. копи-
     руется имя_отн () в/из "имя_файла") тогда _c_o_p_y автоматически
     производит общую копию всех  доменов,  используя  порядок  и
     формат  доменов  в отношении.  Это предусмотрено как удобная
     стенографическая запись  для  копирования  и  восстановления
     полных отношений.

     Для того, чтобы произвести _c_o_p_y в отношение, вы должны  быть
     его  владельцем  или же все пользователи должны иметь полный
     набор разрешений.  Соответственно, для  того,  чтобы  произ-
     вести _c_o_p_y из отношения, вы должны быть владельцем отношения
     или же все пользователи должны иметь,по крайней мере, разре-
     шение на поиск отношения.  Кроме того, вы не можете произво-
     дить _c_o_p_y виртуального отношения.



                              - 3 -








CCOOPPYY((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          CCOOPPYY((QQUUEELL))


ППРРИИММЕЕРР::
     /* Скопировать данные в отношение emp */
        copy emp (name=c10,sal=f4,bdate=i2,mgr=c10,xxx=d1)
                   from "/mnt/me/myfile"

     /* Скопировать имена служащих и их оклад в файл*/
        copy emp (name=c0,comma=d1,sal=c0,nl=d1)
                     into "/mnt/you/yourfile"

     /* Произвести полное копирование отношения emp в файл*/
        copy emp ()
                     into "/mnt/ours/ourfile"

     /* Полное копирование отношения emp из файла */
        copy emp ()
                     from "/mnt/thy/thyfile"

ЗЗААММЕЕЧЧААННИИЯЯ

     При преобразовании текстовых данных в или из ttiimmee  или  ddaattee
     используются   шаблоны,   определенные   по  умолчанию  (см.
     date(QUEL), rubin(DEMOS), ключи -d... и -t...).

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     append(quel),   create(quel),   quel(quel),    permit(quel),
     view(quel), rubin(демос)

ООШШИИББККИИ
     _C_o_p_y прекращает работу при первой ошибке.

     При указании _п_о_л_н_о_г_о__и_м_е_н_и__ф_а_й_л_а, должно быть указано полное
     имя  каталога ДЕМОС, поскольку РУБИН функционирует с катало-
     гом, отличным от рабочего каталога  пользователя,  во  время
     вызова РУБИН.




















                              - 4 -








CCRREEAATTEE((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        CCRREEAATTEE((QQUUEELL))



ИИММЯЯ
     create - создать новое отношение

ФФООРРММААТТ
     ccrreeaattee имя_отн (имя_домена_1 = формат {, имя_домена_2 = формат
     })

ООППИИССААННИИЕЕ
     _C_r_e_a_t_e введет новое отношение в базу данных.  Отношение  бу-
     дет  принадлежать создавшему его пользователю, и будет уста-
     новлено, что оно должно храниться в системе семь дней.  Имя,
     под которым отношение будет храниться в системе, это _и_м_я__о_т_н
     , а имена доменов: _и_м_я__д_о_м_е_н_а_1, _и_м_я__д_о_м_е_н_а_2, и  т.д..   Типы
     доменов  определяются в предложении _ф_о_р_м_а_т.  Допустимые фор-
     маты данных описываются в секции quel(quel) руководства: ii11,,
     ii22,, ii44,, ff44,, ff88,, ddaattee,, ttiimmee,, cc11 -- cc225566.

     Первоначально отношение создается со структурой "листованная
     куча", данных в нем нет.

     В отношении может быть не более 49  доменов.   Отношение  не
     может иметь то же имя, что и системное отношение.

ППРРИИММЕЕРР::
     /* Создать отношение emp (служащие)с доменами name(имя),*/
     /* sal(зар.плата) и bdate(дата рожд.)*/
        create emp (name = c10, salary = f4, bdate = i2)

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     append(quel), copy(quel), destroy(quel), save(quel)























                              - 1 -








DDAATTEE((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QUEL          DDAATTEE((QQUUEELL))



ИИММЯЯ
     ddaattee - работа с данными в форматах ddaattee и ttiimmee

ФФООРРММААТТ
      ddaattee - тип данных для хранения дат;
      ttiimmee - тип данных для хранения времени;

ООППИИССААННИИЕЕ
     В СУБД Рубин имеется два специальных формата данных, которые
     предназначены  для  хранения  даты  и  времени.  Формат ddaattee
     предназначен для хранения дат.  Даты  записываются  в  форме
     длинного  целого числа (i4) и и содержат число дней, прошед-
     ших с 1 января 0 года (новой эры). Формат ttiimmee  предназначен
     для  хранения времени. Время записывается в системе в секун-
     дах и также хранится в длинных целых переменных.

     Для создания переменных типа ddaattee и ttiimmee в операторе  ccrreeaattee
     нужно указать тип ddaattee или ttiimmee:

      ccrreeaattee _n_a_m_e(..., _d_n_a_m_e=ddaattee, ..., _d_n_a_m_e=ttiimmee)

     В арифметических операторах дата и время ведут  себя  анало-
     гично  целым числам.  При смешивании в одном операторе пере-
     менных типа дата, время, и целое результат  получается  типа
     ddaattee,  если  есть такие элементы выражения, или ttiimmee, если в
     выражении есть элементы типа ttiimmee.  Разность двух дат в цис-
     ленном  виде  представляет  собой просто число дней, которые
     разделяют эти даты. Для преобразования дат и времени сущест-
     вует  много разных функций; в их основе лежит шаблонное пре-
     образование.


ШШааббллооннннооее ппррееооббррааззооввааннииее

     Преобразование даты и времени в текстовую  форму  и  обратно
     осуществляется  по  шаблону  (либо  заданному  явно, либо по
     умолчанию). Для преобразования даты  в  текстовую  форму  по
     шаблону используется функция:

      ffrroomm__ddaattee(_д_а_т_а, _ш_а_б_л_о_н)

     Для преобразования времени в текст по  шаблону  используется
     аналогичная функция:

      ffrroomm__ttiimmee(_в_р_е_м_я,_ш_а_б_л_о_н)

     _д_а_т_а и _в_р_е_м_я - выражения типа date или time (или любого  це-
     лочисленного  типа). _ш_а_б_л_о_н - текстовая строка, которая опи-
     сывает правила преобразования и представляет собой по  внеш-
     нему виду просто шаблон преобразования.



                              - 1 -








DDAATTEE((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QUEL          DDAATTEE((QQUUEELL))


     Преобразования текста в дату осуществляется функцией:

      ttoo__ddaattee(_т_е_к_с_т,_ш_а_б_л_о_н)

     результат получается типа "ddaattee". Преобразование  текста  во
     время осуществляет функция:

      ttoo__ttiimmee(_т_е_к_с_т,_ш_а_б_л_о_н)

     результат получается типа "ttiimmee".

     В шаблон  могут  входить  символы  пунктуации,  произвольный
     текст в одиночных кавычках, и идентификаторы преобразования.
     При  выводе символы пунктуации и текст в кавычках просто пе-
     реписываются  в выходную строку, а идентификаторы преобразо-
     вания заменяются на соответствующее значение.  При вводе  по
     шаблону символы шаблона должны совпадать с символами входной
     строки, а на месте идентификаторов преобразования ищутся со-
     ответствующие  значения.  Единственное исключение состовляет
     символ "??": он означает ппррооииззввооллььнныыйй символ входной  строки.
     Идентификаторы  преобразования  записываются прописными бук-
     вами без разделителей и  распознаются  по  наиболее  длинной
     последовательности.   При преобразовании дат существуют сле-
     дующие идентификаторы преобразования:

     DDDD -      день месяца (1-31);
     MMMM -      номер месяца (1-12);
     YYYY -      две последние цифры года (при  выводе);  последние
               цифры 19XX года (при вводе);
     YYYYYYYY -    четыре цифры года;
     WW -       номер дня недели (0 - воскресенье, 6 - суббота);
     HH -       (русское Н) - то же самое;
     MMOONN -     английское сокращенное название месяца: JJaann,,  FFeebb,,
               MMaarr,, AApprr,, MMaayy,, JJuunn,, JJuull,, AAuugg,, SSeepp,, OOcctt,, NNoovv,, DDeecc..
     MMOONNTTHH -   Английское полное название месяца.
     ММЕЕСС -     Русское сокращенное  название  месяца:  ЯЯннвв,,  ФФеевв,,
               ММаарр,, ...
     ММЕЕССЯЯЦЦ -   Русское полное название месяца в именительном  па-
               деже: ЯЯннввааррьь,, ФФеевврраалляя...
     ММЕЕССЯЯЦЦАА -  То же самое в родительном падеже.
     DDAAYY -     Сокращенное английское название дня  недели:  SSaann,,
               MMoonn,, TTuuee,, WWeenn,, TThhuu,, FFrrii,,SSaatt.
     DDAAYYWWEEEEKK - Полное английское название дня недели.
     ДДЕЕНН -     Сокращенное русское название дня недели: ВВоосс,, ППоонн,,
               ВВттоо,, ССррее,, ЧЧеетт, ППяятт,, ССуубб.
     ДДЕЕННЬЬННЕЕДД - Полное русское название дня недели.

               Преобразование времени намного проще:

     HHHH -      Число часов;
     MMII -      Число минут;
     SSSS -      Число секунд.


                              - 2 -








DDAATTEE((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QUEL          DDAATTEE((QQUUEELL))



     Примеры:

     Предположим, что выражение dddd имеет тип ddaattee  и значение  1122
     ммааяя 11998899 ггооддаа.  Выражение tttt типа ttiimmee имеет значение 1122 ччаа--
     ссоовв 2255 ммииннуутт 1100 ссееккуунндд.
     Функция - Результат

     ffrroomm__ddaattee((dddd,,""DDDD..MMMM..YYYY"")) -12.05.89
     ffrroomm__ddaattee((dddd,,""DDDD--ММЕЕССЯЯЦЦАА--YYYYYYYY"")) -12-Мая-1989
     ffrroomm__ddaattee((dddd,,""''РРооддииллссяя'' DDDD ММеессяяццаа YYYYYYYY ''ггооддаа вв  ''  ДДЕЕННЬЬННЕЕДД""))
               -Родился 12 Мая 1989 года в четверг
     ttoo__ddaattee((""1122--ММааяя--11998899"",,""DDDD--MMOONN--YYYYYYYY"")) -Значение 12.05.89
     ffrroomm__ttiimmee((tttt,,""HHHH::MMII"")) -12:25
     ttoo__ttiimmee((""1122::1100::0000"",,""HHHH::MMII::SSSS"")) -значение функции  соответст-
               вует времени 12:10:00.
     Следует обратить внимание на то, что при вводе  по  шаблону,
     которому соответствует название месяца, поле ввода сравнива-
     ется со всеми возможными названиями месяца - русскими и анг-
     лийскими  в  любых  падежах.   Для получения правильной даты
     нужно указать число, месяц и либо год полностью,  либо  пос-
     ледние две цифры (идентификатор YYYY).


ППррееооббррааззооввааннииее ппоо ууммооллччааннииюю

     В системе существуют шаблоны для ввода и вывода даты и  вре-
     мени  по  умолчанию,  без указания шаблона. Для ввода/вывода
     даты используется шаблон: "DDDD--MMOONN--YYYYYYYY", для времени -  шаб-
     лон  "HHHH::MMII::SSSS".  Эти шаблоны могут быть изменены при вызове
     системы, если  указан  ключ  "--dd_ш_а_б_л_о_н"  для  даты  либо  "--
     tt_ш_а_б_л_о_н"  для времени.  Преобразования по шаблонам умолчания
     осуществляется следующими функциями:

     aasscciiii((_d)) -преобразует свой аргумент к текстовой форме.  Если
               аргумент имеет тип "ddaattee" или "ttiimmee", используется
               преобразование по  шаблону  умолчания.   Результат
               всегда получается текстового типа.
     ddaattee44((_d)) -Преобразует аргумент к типу "ddaattee". Если  аргумент
               имеет численный тип, то он преобразуется к формату
               ii44 и затем получает тип "ddaattee". Если тип аргумента
               текстовый,  производится преобразование по формату
               умолчания.
     ttiimmee44((_t)) -Аналогично "ddaattee44", но преобразование идет к  типу
               "ttiimmee".

     Кроме того, преобразование из текста в  дату/время  произво-
     дится в константах типа "ddaattee//ttiimmee". Такие константы записы-
     ваются в форме:

      ''_т_е_к_с_т''



                              - 3 -








DDAATTEE((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QUEL          DDAATTEE((QQUUEELL))


     причем признаком константы типа "ttiimmee" является символ "::" в
     тексте  константы. Преобразование константы в дату или время
     производится по шаблону умолчания.  Если  строка  текста  не
     соответствует  шаблону,  диагностируется ошибка преобразова-
     ния.

     При выводе в операторах "rreettrriieevvee" или "pprriinntt" значения типа
     "ddaattee"  и  "ttiimmee"  также преобразуются в текстовый формат по
     шаблону умолчания.

ППррееооббррааззооввааннииее ттииппоовв

     В выражениях переменные типа "ddaattee" и "ttiimmee" ведут себя  по-
     добно переменным формата "ii44".  Тип результата целочисленной
     операции с разнотипными операндами определяется в таком слу-
     чае по следующему правилу: 1.   Если один из операндов имеет
     тип "ddaattee", результат будет типа "ddaattee".  2.   Если предыду-
     щее  условие  не  выполняется, и один из операндов имеет тип
     "ttiimmee", результат будет типа "ttiimmee".
     Если нужен целый результат (например, нужно  вычислить  воз-
     раст человека в днях), нужно использовать явное преобразова-
     ние в целое значение: "iinntt22" или "iinntt44".

ССииссттееммнныыее ккооннссттааннттыы

     В языке QUEL  имеется 2 встроенные константы, которые содер-
     жат  текущие  дату и время: ssyyssddaattee содержит дату, а ssyyssttiimmee
     время. Время и дата относятся к началу  выполнения  текущего
     оператора запроса и согласованы между собой.

ППррииммееррыы

     Приведем примеры операторов QQUUEELL с использованием новых  ти-
     пов данных.

      create bsd(имя=c12,деньр=date,начр=date,приход=time)
      append     to     bsd(имя="Иванов      И.И.",деньр='12-Apr-
     1965',начр='10-Jan-1974',
      приход='09:00:00')
      retrieve ( Имя=bsd.имя,
      Род=from_date(bsd.деньр,
      "'родился ' DD МЕСЯЦА YY 'года'"),
      Стаж=int4((sysdate-bsd.начр)/365) )


ППррииммееччааннииее

     В языке EEQQUUEELL констант типа ddaattee//ttiimmee нет, не  происходит  и
     автоматического  преобразования  даты  и времени в текстовый
     вид при выводе. Однако в добавление к функциям  преобразова-
     ния языка QQUUEELL в EEQQUUEELL добавлены библиотечные функции преоб-
     разования даты и времени.  Эти функции описаны в руководстве


                              - 4 -








DDAATTEE((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QUEL          DDAATTEE((QQUUEELL))


     по программированию на EEQQUUEELL.

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ

      qquueell((qquueell)) - преобразования типов;
      ррууббиинн((ддееммоосс)) - установка шаблонов умолчания.
















































                              - 5 -








DDEEFFIINNEE((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        DDEEFFIINNEE((QQUUEELL))



ИИММЯЯ
     define - определить подсхему на отношении

ФФООРРММААТТ
     ddeeffiinnee vviieeww имя (список_объектов) [ wwhheerree условие ]
     ddeeffiinnee ppeerrmmiitt список_операций { oonn | ooff | ttoo } переменная  [
          (список_атрибутов)  ]  ttoo  имя  [  aatt терминал ] [ ffrroomm
          время ttoo время ] [ oonn день_нед ttoo день_нед  ]  [  wwhheerree
          условие ]
     ddeeffiinnee iinntteeggrriittyy oonn переменная iiss условие
     ddeeffiinnee имя_переменной == значение

ООППИИССААННИИЕЕ
     Оператор _d_e_f_i_n_e определяет заданные  подсхемы  на  указанном
     отношении.  Полное описание этих команд смотри в перечислен-
     ных ниже секциях руководства.

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     integrity(quel), permit(quel), view(quel) serial(quel)


































                              - 1 -








DDEELLEETTEE((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        DDEELLEETTEE((QQUUEELL))



ИИММЯЯ
     delete - удалить кортежи из отношения

ФФООРРММААТТ
     ddeelleettee кортеж_переменная [wwhheerree условие]

ООППИИССААННИИЕЕ
     _D_e_l_e_t_e удаляет кортежи, которые удовлетворяют _у_с_л_о_в_и_ю из от-
     ношения, которому они принадлежат.  _К_о_р_т_е_ж-_п_е_р_е_м_е_н_н_а_я должна
     быть объявлена над существующим отношением в предыдущем опе-
     раторе  _r_a_n_g_e _D_e_l_e_t_e не имеет _с_п_и_с_к_а__о_б_ъ_е_к_т_о_в Команда _d_e_l_e_t_e
     требует переменной кортежа из оператора _r_a_n_g_e и  не  требует
     действительного  имени  отношения.  Если квалификация не да-
     ется, то это приводит к удалению содержимого всех кортежей в
     отношении.   Результат  операции  - пустое отношение, но это
     правильный результат.

     Для того, чтобы использовать _d_e_l_e_t_e для удаления кортежей из
     отношения,  вы должны быть владельцем отношения или же иметь
     разрешение _d_e_l_e_t_e на данное отношение.

ППРРИИММЕЕРР
     /* Удалить всех служащих, у которых оклад свыше $30,000 */
        range of e is emp
        delete e where e.sal > 30000

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     destroy(quel), permit(quel), quel(quel), range(quel)

























                              - 1 -








DDEESSTTRROOYY((QQUUEELL))      ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL       DDEESSTTRROOYY((QQUUEELL))



ИИММЯЯ
     destroy - уничтожить существующее отношение(я)

ФФООРРММААТТ
     ddeessttrrooyy имя_отн { , имя_отн }  ddeessttrrooyy  имя_переменной  {  ,
     имя_переменной }
     ddeessttrrooyy [ ppeerrmmiitt | iinntteeggrriittyy ] rимя_отн [ integer  {  ,  in-
     teger } | aallll ]

ООППИИССААННИИЕЕ
     _D_e_s_t_r_o_y удаляет отношение из базы данных,  а  также  удаляет
     ограничения   или  разрешения,  определенные  на  отношении.
     Только владелец отношения  может  уничтожить  отношение  или
     свои  разрешения и ограничения по целостности.  В отличие от
     _d_e_s_t_r_o_y , oператоры modify и delete могут  удалять  кортежи,
     но при этом исходное отношение не разрушается.

     Если уничтоженное отношение имеет вторичные индексы, то вто-
     ричные  индексы  также разрушаются.  Уничтожение только вто-
     ричного индекса не влияет на первичное отношение, которое он
     индексирует.

     Чтобы уничтожить отдельные разрешения  или  ограничения  для
     отношения,  аргументы  _i_n_t_e_g_e_r  должны  соответствовать hheellpp
     ppeerrmmiitt (для ddeessttrrooyy ppeerrmmiitt) или hheellpp iinntteeggrriittyy (для  ddeessttrrooyy
     iinntteeggrriittyy)  на том же самом отношении.  Чтобы уничтожить все
     ограничения или разрешения, может быть  использовано  вместо
     отдельных  целых  чисел  ключевое слово aallll Чтобы уничтожить
     ограничение или разрешение, должны  быть  представлены  либо
     аргументы _i_n_t_e_g_e_r , либо ключевое слово aallll

ППРРИИММЕЕРР
     /* Уничтожить отношение emp */
         destroy emp
         destroy emp, parts

     /* Уничтожить некоторые разрешения на parts (зап.части) и все
      * ограничения целостности на служащих
      */
        destroy permit parts 0, 4, 5
        detroy integrity employee

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     create(quel),   delete(quel),    help(quel),    index(quel),
     modify(quel)








                              - 1 -








HHEELLPP((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          HHEELLPP((QQUUEELL))



ИИММЯЯ
     help - получить справочную информацию о командах  РУБИН  или
     об отношениях в базе данных.

ФФООРРММААТТ
     hheellpp [short] [my]  [real]  [  имя_отн  ]  [  "секция"  ]  {,
     имя_отн}{, "секция"}
     hheellpp vviieeww имя_отн {, имя_отн}
     hheellpp ppeerrmmiitt имя_отн {, имя_отн}
     hheellpp iinntteeggrriittyy имя_отн {, имя_отн}

ООППИИССААННИИЕЕ
     _H_e_l_p может быть использована для  получения  секций  данного
     руководства,  информации  о  содержимом текущей базы данных,
     информации об отношениях в базе данных, определениях  вирту-
     альных отношений или же об ограничениях на отношениях по за-
     щите и целостности.  Правильными формами являются следующие:

     hheellpp ""_с_е_к_ц_и_я "" - Вырабатывает копию  укзанной  секции  руко-
          водства программиста РУБИН и печатает ее на стандартном
          устройстве вывода.
     hheellpp -  Предоставляет информацию обо всех отношениях,  кото-
          рые существуют в текущей базе данных.
     hheellpp sshhoorrtt -  Предоставляет в  компактной  форме  информацию
          обо  всех отношениях, которые существуют в текущей базе
          данных, кроме системных.  В стартовом файле для данного
          оператора определен псевдоним: _l_s .
     hheellpp mmyy -  Предоставляет информацию обо всех личных  отноше-
          ниях данного пользователя, которые существуют в текущей
          базе данных.  В стартовом файле для  данного  оператора
          определен псевдоним: _l_m .
     hheellpp rreeaall -  Предоставляет информацию  обо  всех  регулярных
          (не  VIEW  или  INDEX) отношениях, которые существуют в
          текущей базе  данных,  кроме  системных.   В  стартовом
          файле для данного оператора определен псевдоним: _l_r .
     hheellpp _и_м_я__о_т_н {, _и_м_я__о_т_н} - Предоставляет информацию об  ука-
          занных отношениях.
     hheellpp """" - Выдает список команд РУБИН.
     hheellpp vviieeww _и_м_я__о_т_н {, _и_м_я__о_т_н} - Печатает определения  вирту-
          альных отношений.
     hheellpp ppeerrmmiitt _и_м_я__о_т_н {, _и_м_я__о_т_н}  -  Печатает  разрешения  на
          указанных отношениях.
     hheellpp iinntteeggrriittyy _и_м_я__о_т_н {, _и_м_я__о_т_н} - Печатает ограничения по
          целостности для указанных отношений.

     В формах ppeerrmmiitt и iinntteeggrriittyy печатаются уникальные  идентифи-
     каторы  для  каждого  ограничения.  Эти идентификаторы могут
     использоваться для удаления ограничений в операторе _d_e_s_t_r_o_y





                              - 1 -








HHEELLPP((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          HHEELLPP((QQUUEELL))


ППРРИИММЕЕРР
     help
     help "help"  /* печатает данную страницу руководства*/
     help "quel"
     help emp
     help emp, parts, "help", supply
     help view overp_view
     help permit parts, employee
     help integrity parts, employee

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     destroy(quel)

ООШШИИББККИИ
     Для того, чтобы присутствующие  в  имени  секции  алфавитные
     знаки  воспринимались, они должны быть представлены в нижнем
     регистре.





































                              - 2 -








IINNDDEEXX((QQUUEELL))        ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL         IINNDDEEXX((QQUUEELL))



ИИММЯЯ
     index - создать вторичный индекс на существующем отношении

ФФООРРММААТТ
      iinnddeexx oonn  _и_м_я__о_т_н iiss _и_м_я__и_н_д_е_к_с_а((_д_о_м_е_н_1 {,, _д_о_м_е_н_2}))

ООППИИССААННИИЕЕ
     IInnddeexx используется для создания вторичных  индексов  на  су-
     ществующих  отношениях,  чтобы  более эффективно производить
     поиск и обновление  по  вторичным  ключам.   Вторичный  ключ
     конструируется  из  доменов 1, 2,...,6 заданного отношения в
     порядке их указания в запросе.  Создавать вторичные  индексы
     на отношении позволяется только владельцу отношения.

     Чтобы поддерживать  целостность  индекса,  пользователям  не
     разрешаeтся  непосредственно  обновлять  вторичные  индексы.
     Однако, в тех случаях, когда первичное отношение было  изме-
     нено, его вторичные индексы автоматически обновляются систе-
     мой.  Вторичные индексы могут модифицироваться с целью даль-
     нейшего  увеличения эффективности доступа к первичному отно-
     шению.  Если индекс создается впервые, он автоматически  мо-
     дифицируется по всем своим областям к структуре памяти isam.
     Если эта структура нежелательна, то пользователь может  про-
     игнорировать задаваемую по умолчанию структуру isam, исполь-
     зуя переключатель --nn (см. rubin(демос)), или команду mmooddiiffyy..

     Если команда mmooddiiffyy или ddeessttrrooyy используется  для  отношения
     _и_м_я__о_т_н, все вторичные индексы на _и_м_я__о_т_н уничтожаются.

     Вторичные индексы на других индексах или на системных  отно-
     шениях запрещены.

ППРРИИММЕЕРР
     /* Создать вторичный индекс, называeмый ``x'' на отношении ``emp'' */
        index on emp is x(mgr,sal)

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     copy(quel), destroy(quel), modify(quel)

ООШШИИББККИИ
     В ключе могут присутствовать самое большее 6 областей.

     Команду ccooppyy нельзя использовать для копирования  в  отноше-
     ние, которое имеет вторичные индексы.

     Структура isam, принимаемая по умолчанию, не  лучшая  струк-
     тура для индекса, если у вас большой диапазон поиска.






                              - 1 -








IINNTTEEGGRRIITTYY((QQUUEELL))    ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL     IINNTTEEGGRRIITTYY((QQUUEELL))



ИИММЯЯ
     integrity - определить ограничения целостности

ФФООРРММААТТ
     ddeeffiinnee iinntteeggrriittyy oonn _п_е_р_е_м_е_н_н_а_я iiss _у_с_л_о_в_и_е

ООППИИССААННИИЕЕ
     Оператор iinntteeggrriittyy добавляет ограничения по целостности  для
     отношения,  определенного в _п_е_р_е_м_е_н_н_о_й.  После того, как ог-
     раничение установлено, все  обновления  в  отношении  должны
     удовлетворять  _у_с_л_о_в_и_ю.   _У_с_л_о_в_и_е  должно принимать значение
     "истина", в противном случае вырабатывается  диагностическое
     сообщение и оператор игнорируется.

     В текущей версии системы о существующих ограничениях по  це-
     лостности не сообщается, изменения, нарушающие установленную
     целостность, просто (и без всякого сигнала) не выполняются.

     _У_с_л_о_в_и_е должно иметь одну переменную и  может  не  содержать
     никаких агрегатов.


     Оператор iinntteeggrriittyy может  использоваться  только  владельцем
     отношения.

ППРРИИММЕЕРР
     /* Гарантировать, что все служащие имеют положительную зарп-
     лату */
       range of e is employee
       define integrity on e is e.salary > 0

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     destroy(quel)




















                              - 1 -








MMOODDIIFFYY((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        MMOODDIIFFYY((QQUUEELL))



ИИММЯЯ
     modify - изменение структуры памяти отношений.

ФФООРРММААТТ
     mmooddiiffyy имя_отн ttoo структ_памяти [ oonn ключ1 [ :  _п_о_р_я_д_о_к__с_о_р_т
          ]  [  {  ,  ключ2  [  :  _п_о_р_я_д_о_к__с_о_р_т ] } ] ] [ wwhheerree [
          ffiillllffaaccttoorr == _n ] [ ,, ttuupplleess == _n ] [ ,, uuffaaccttoorr == _n ] [ ,,
          mmiinnppaaggeess == _n ] [ ,, mmaaxxppaaggeess == _n ] ]

ООППИИССААННИИЕЕ
     _О_т_н_о_ш_е_н_и_е преобразовывается  в  указанную  структуру  памяти
     _с_т_р_у_к_т__п_а_м_я_т_и.   Только владелец отношения может его модифи-
     цировать.  Эта команда используется для повышения  эффектив-
     ности при использовании больших или часто используемых отно-
     шений.  Структуры памяти определяются следующим образом:

    iissaamm      - индексно-последовательная структура
    cciissaamm     - сжатая isam
    hhaasshh      - хэш-структура
    cchhaasshh     - сжатая hash
    sshhaasshh     - "последовательная" хэш-структура (соседние значе-
                ния ключа пишутся подряд)
    ccsshhaasshh    - сжатая "последовательная" hash-структура
    hheeaapp      - структура куча
    cchheeaapp     - сжатая heap
    hheeaappssoorrtt  - heap с отсортированными  кортежами  и  удаленными
                повторяющимися кортежами
    cchheeaappssoorrtt - сжатая heapsort
    ttrruunnccaatteedd - heap со всеми удаленными кортежами

     Документ ``ССооззддааннииее ии ппооддддеерржжккаа ббаазз ддаанннныыхх сс  ииссппооллььззооввааннииеемм
     РРУУББИИНН''  описывает, как выбирать эти структуры в зависимости
     от использования отношений.

     Алгоритм сжатия только удаляет последние пробелы в  символь-
     ных  полях.  Может существовать более эффективная схема сжа-
     тия, но разница между принятым алгоритмом и более  эффектив-
     ным, но медленным алгоритмом сжатия не очевидна.

     Если фраза oonn опущена при модификации в  isam,  cisam,  hash
     или  chash,  по умолчанию ключем сортировки считается первый
     домен.  Когда модифицируется в heap или cheap, фраза oonn  мо-
     жет  быть  опущена.   Также и при модификации в heapsort или
     cheapsort, фраза oonn необязательна.

     Когда отношение сортируется (isam, cisam, heapsort и  cheap-
     sort),  предпочтение  отдается тем ключам, которые были ука-
     заны во фразе oonn (если их несколько).  Отношение сортируется
     по  ключам  в  том  порядке, в котором они указаны в запросе
     после фразы oonn Домены, не указанные в запросе будут  исполь-
     зоваться как наименее значащие ключи сортировки в последова-


                              - 1 -








MMOODDIIFFYY((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        MMOODDIIFFYY((QQUUEELL))


     тельности номеров доменов.

     Когда  отношение  модифицируется  в  heap  или   cheap,   то
     _п_о_р_я_д_о_к__с_о_р_т  может быть указан как aasscceennddiinngg или ddeesscceennddiinngg
     В остальных случаях всегда aasscceennddiinngg Каждый  ключ  указанный
     во фразе oonn может быть указан как:

          _к_л_ю_ч::ddeesscceennddiinngg

     что будет означать, что  сортировка  по  этому  ключу  будет
     иметь  нисходящий порядок.  aasscceennddiinngg тоже может быть указан
     после двоеточия (`:'), хотя это не обязательно ,  т.к.   это
     является  действием  по  умолчанию.   DDeesscceennddiinngg  может быть
     обозначен символом `dd' и,  соответственно,  aasscceennddiinngg  может
     быть обозначен символом `aa'.

     _F_i_l_l_f_a_c_t_o_r указывет в процентах (от 1 до 100) размер  запол-
     ненной области первичной страницы данных при идеальных усло-
     виях.  _F_i_l_l_f_a_c_t_o_r может быть использован в isam, cisam, hash
     и chash.  При использовании больших факторов полноты наличие
     ключей при распределении кортежей по страницам будет  причи-
     ной  их  переполнения, и, тем самым, ухудшения характеристик
     доступа.

     _t_u_p_l_e_s указывает предполагаемое число  записей  в  отношении
     при  модификации в структуру hash или chash (а также shash и
     cshash).  _u_f_a_c_t_o_r при модификации в hash  (chash)  указывает
     предполагаемое  среднее  число записей с одинаковым ключом в
     отношении. Например, ufactor=1  означает,  что  каждый  ключ
     уникален.   Структура shash представляет собой просто hash с
     ufactor=1.  _M_i_n_p_a_g_e_s  (старый  ключ)  указывает  минимальное
     число  первичных  страниц при модификации отношений в струк-
     туру hash или chash.  _M_a_x_p_a_g_e_s (старый ключ) указывает  мак-
     симальное  число первичных страниц при модификации отношения
     в структуру hash или chash.  Из _m_i_n_p_a_g_e_s и _t_u_p_l_e_s может при-
     сутствовать  только один.  Если присутствуют mmiinnppaaggeess и mmaaxx--
     ppaaggeess,, то mmiinnppaaggeess не должен превышать mmaaxxppaaggeess..

     Значение по умолчанию для ffiillllffaaccttoorr, mmiinnppaaggeess,  и  mmaaxxppaaggeess
     следующие:

                 _F_I_L_L_F_A_C_T_O_R      _M_I_N_P_A_G_E_S        _M_A_X_P_A_G_E_S

          hash   50           10        не ограничен
          chash  75           1         не ограничен
          isam   80           NA        NA
          cisam  100          NA        NA







                              - 2 -








MMOODDIIFFYY((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        MMOODDIIFFYY((QQUUEELL))


ППРРИИММЕЕРРЫЫ
/* Преобразовать отношение emp в индекснопоследовательную
        структуру памяти с ключевым доменом "name" */

modify emp to isam on name

/* Если "name" первый домен отношения emp,
        то этот же результат будет достигнут и
        следующей командой */

modify emp to isam

/* проделаем это же преобразование но потребуем 60%
        использования всех первичных страниц */

modify emp to isam on name where fillfactor = 60

/* Преобразуем отношение supply в сжатую hash-структуру
        с ключевими доменами "num" и "quan" */

modify supply to chash on num, quan

/* Проделаем то же самое, но также укажем, что нужно
        отвести место под 1000
        записей, а ключ (num, quan) уникален */

modify supply to chash on num, quan
        where tuples=1000, ufactor=1

/* Снова сделаем то же самое, но только потребуем минимум
         16 первичных страниц */

modify supply to chash on num, quan
        where minpages = 16

/* Преобразовать отношение parts в heap-структуру */

modify parts to heap

/* Преобразовать отношение parts снова в
        heap-структуру, но имеющиеся
        кортежи сортировать по домену
        "pnum" и все повторяющиеся кортежи удалить */

modify parts to heapsort on pnum

/* Преобразовать отношение employee в нисходящем
        порядке по управляющему,
        в восходящем порядке по зарплате и
повторяющиеся кортежи
        удалить */



                              - 3 -








MMOODDIIFFYY((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        MMOODDIIFFYY((QQUUEELL))


modify employee to heapsort on manager, salary:descending

ССММ..ТТААККЖЖЕЕ
     sysmod(unix)

ЗЗААММЕЕЧЧААННИИЯЯ


     В версиях РРУУББИИНН 22..1155 и старше при  модификации  в  структуру
     hhaasshh  (или  sshhaasshh, cchhaasshh, ...) система не записывает на диск
     те листы отношения, которые не содержат информации. При этом
     образуются  файлы,  имеющие  небольшой физический размер при
     большом логическом размере (за счет появления "дырок").  Это
     позволяет создавать отношения, расчитанные на "рост" без по-
     тери эффективности доступа, физический размер которых  будет
     расти  по  мере  заполнения  (если  указано  ttuupplleess== намного
     больше текущего количества  записей).   Такие  базы  нежела-
     тельно копировать командой "tar", так как при этом все неза-
     нятые листы будут записаны  на  ленту  и  физический  размер
     файла  после считывания с ленты резко возрастет (за счет за-
     полнения "дырок").


     Указание "uuffaaccttoorr" при модификации в hash  позволяет  значи-
     тельно  соптимизировать использование памяти на диске в слу-
     чае, если значения ключа в  среднем  изменяются  непрерывно.
     При  ufactor=1  и  использовании в качестве ключа переменной
     типа i2 или i4 записи с соседними  значениями  ключей  будут
     располагаться рядом, что заметно ускоряет заполнение отноше-
     ния (по командам append и copy) в случае, если записи  зано-
     сятся  в  порядке возрастания ключа, а также уменьшает физи-
     ческий размер  файла  при  частичном  заполнении  отношения.
     Особенно  рекомендуется использовать "ufactor=1", если в ка-
     честве ключа используется какой-либо уникальный номер,  воз-
     растающий по мере накопления информации.



















                              - 4 -








MMOONNIITTOORR((QQUUEELL))      ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL       MMOONNIITTOORR((QQUUEELL))



ИИММЯЯ
     monitor - интерактивный терминальный монитор

ООППИИССААННИИЕЕ
     Интерактивный терминальный монитор является основным средст-
     вом  взаимодействия  с  РУБИН.   Он обеспечивает возможность
     формулировать запрос и просматривать его перед передачей  на
     обработку  РУБИН.  Если необходимо внести какие-либо измене-
     ния, для редактирования буфера запроса нужно воспользоваться
     одним из текстовых редакторов ДЕМОС.

     ССооооббщщеенниияя ии ппооддссккааззккии..

     Терминальный монитор информирует  пользователя  о  состоянии
     монитора и буфера запросов.

     При регистрации пользователя печатается  соответствующее со-
     общение.   В  нем  обычно  приводится номер версии системы и
     время регистрации.  Далее, из ddaayyffiillee  выдается  информация,
     предназнченная для пользователей.

     Когда РУБИН готова к работе,  печатается  сообщение  ``_g_o''.
     Это  означает, что буфер запросов пуст.  Сообщение ``_c_o_n_t_i_n_-
     _u_e'' означает, что в  буфере  запросов  имеется  информация.
     После  подачи  команды \\ggoo, если начинается ввод нового зап-
     роса, содержимое буфера запросов автоматически стирается, за
     исключением того случая, когда первой помещаемой в буфер ко-
     мандой  является  команда,  действующая  на  буфер  запроса.
     Этими  командами  являются:  \\aappppeenndd,  \\eeddiitt, \\pprriinntt, \\lliisstt,
     \\eevvaall, и \\ggoo.  Например, если напечатать
             help parts
             \go
             print parts
     то в буфере запросов будет находиться
     print parts
     тогда как, если напечатать
             help parts
             \go
             \print
             print parts
     буфер запросов будет содержать
             help parts
             print parts
     Когда монитор ждет ввода запроса, в начале каждой строки пе-
     чатается звездочка.

     ККооммааннддыы

     Существует ряд команд, которые пользователь может  использо-
     вать  для  управления буфером запросов или своим окружением.
     Все эти команды должны начинаться с символа  обратная  косая


                              - 1 -








MMOONNIITTOORR((QQUUEELL))      ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL       MMOONNIITTOORR((QQUUEELL))


     черта  (`\\'),  и  все  они  выполняются немедленно, (а не во
     время выполнения, как например запросы).

     Некоторые команды требуют задания имени файла, которое опре-
     деляется  как  первый  значащий символ после конца самой ко-
     манды и до конца вводимой строки.  Помещать на одной  строке
     вместе  с  этими  командами другие команды нельзя.  Команды,
     которым не нужно задавать имени файла,  могут  располагаться
     вместе на одной строке; например
             \date\go\date
     выдают время до и после выполнения текущего буфера запосов.

          \\rr
          \\rreesseett    Стереть вводимый запрос (стереть буфер запро-
                    сов).  Прежнее содержимое буфера теряется.

          \\pp
          \\pprriinntt    Напечатать текущий запрос.  Содержимое буфера
                    выдается на терминал пользователя.

          \\ll
          \\lliisstt     Напечатать текущий запрос, в таком виде,  ка-
                    кой  он  примет  после макрообработки.  Проя-
                    вятся все эффекты  макрообработки,  например,
                    все макрокоманды будут определены.

          \\eevvaall     Макропроцессор обрабатывает буфер запросов  и
                    заменяет его на результат обрaботки.  Эта ко-
                    манда в точности совпадает с командой  \\lliisstt,
                    за  исключением того, что результат заносится
                    в буфер запросов, а не выводится на терминал.

          \\ee
          \\eedd
          \\eeddiitt
          \\eeddiittoorr   Вызов редактора текстов ДЕМОС (см. ED, RED  в
                    "РРууккооввооддссттввее  ппррооггррааммммииссттаа ДДЕЕММООСС"); для возв-
                    рата в монитор РУБИН используется команда вы-
                    хода  из  редактора. При использовании редак-
                    тора ED с указаным именем  файла,  редактиру-
                    ется  содержимое этого файла, а не буфер зап-
                    росов.  Если определен  макрос  ``{_e_d_i_t_o_r}'',
                    то  он  используется в качестве полного имени
                    редактора, в  противном  случае  используется
                    вызов ``/_b_i_n/_e_d''.

          \\gg
          \\ggoo       Обработать текущий запрос.  Содержимое буфера
                    обрабатывается  макропроцессором,  передается
                    РУБИН, и выполняется.

          \\aa


                              - 2 -








MMOONNIITTOORR((QQUUEELL))      ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL       MMOONNIITTOORR((QQUUEELL))


          \\aappppeenndd   Дописать в буфер запросов.  При вводе команды
                    \a после завершения запроса отключается авто-
                    очистка и гарантируется, что  буфер  запросов
                    не будет сброшен.

          \\ttiimmee
          \\ddaattee     Выдать текущее время дня.

          \\ss
          \\sshh
          \\sshheellll    Выйти в shell.  CCTTRRLL--DD обеспечивает окончание
                    работы  в  shell  и  возврат в монитор РУБИН.
                    Если при команде \\sshheellll указано имя файла, то
                    оно  воспринимается как командный файл shell,
                    который запускается с буфером запроса  в  ка-
                    честве  параметра  ``$_1''.  Если имя файла не
                    задано, то shell порождает процесс.  Если оп-
                    ределен  макрос  ``{_s_h_e_l_l}'', то он использу-
                    ется как полное имя shell; в противном случае
                    используется ``/_b_i_n/_s_h''.

          \\!!_к_о_м_а_н_д_а _п_а_р_а_м_е_т_р_ы
                    Выполнить _к_о_м_а_н_д_у операционной системы и  за-
                    тем  вернуться в монитор. Команда выполняется
                    тем же интерпретатором, который вызывается по
                    команде \\sshheellll.

          \\qq
          \\qquuiitt     Выйти из РУБИН.

          \\ccdd
          \\cchhddiirr    Изменить рабочий каталог монитора на  указан-
                    ный каталог.

          \\ii
          \\iinncclluuddee
          \\rreeaadd     Переключиться на ввод  из  указанного  файла.
                    Символы  "\\"  в файле будут обрабатываться по
                    мере считывания.

          \\ww
          \\wwrriittee    Дописать содержимое буфера запросов в указан-
                    ный файл.

          \\bbrraanncchh   Передать управление в файл, считанный в буфер
                    командой  \\iinncclluuddee.  См. также раздел о пере-
                    ходах.

          \\mmaarrkk     Установить метку для \\bbrraanncchh.

          \\<_л_ю_б_о_й _д_р_у_г_о_й _с_и_м_в_о_л>
                    Игнорировать любое возможное специальное зна-


                              - 3 -








MMOONNIITTOORR((QQUUEELL))      ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL       MMOONNIITTOORR((QQUUEELL))


                    чение символа, следующего за '\\'.  Это позво-
                    ляет использовать '\\' в качестве литерального
                    символа.   (См.также  quel(quel)  -  строки).
                    Важно заметить, что  экранируемые  \\  символы
                    иногда  от'едаются  макропроцессором; в общем
                    случае, если вам нужно ввести \,  нужно  вво-
                    дить  два символа \\ (наиболее простой путь -
                    попытаться не использовать этих символов  во-
                    обще).

     ММааккррооккооммааннддыы

     Макрокоманды описываются в разделе macros(quel).

     ППееррееххооддыы

     Команды \\bbrraanncchh и \\mmaarrkk предоставляют возможность делать лю-
     бые  переходы в пределах файлов, включенных в буфер командой
     \include.  (Подобно командам ``_g_o_t_o'' и ``:'' в shell).   За
     \\mmaarrkk должна идти метка.  За \\bbrraanncchh должна идти либо метка,
     означающая безусловный переход, либо выражение, перед  кото-
     рым  стоит знак вопроса с последующей меткой, означающее ус-
     ловный переход.  Переход осуществляется в том  случае,  если
     значение выражения больше нуля.  Например,
               \branch ?{tuplecount}<=0 notups
     переходит по метке ``_n_o_t_u_p_s''  если  результат  макрокоманды
     ``{_t_u_p_l_e_c_o_u_n_t}'' меньше или равен нулю.

     Выражения, используемые в операторах \branch имеют ограниче-
     ния.   Операторы  +, -, *, /, <=, >=, <, >, = и != определя-
     ются общепринятым способом.  Левый унарный оператор !!  может
     использоваться  и для указания логического отрицания.  В вы-
     ражениях не должно  быть  пробелов,  т.к.   пробел  означает
     окончание выражения.

     ИИннииццииааллииззаацциияя

     Во время  входа  в  РУБИН  проводится  ряд  инициализирующих
     действий.   Во-первых,  определяется макрокоманда называемая
     {{ppaatthhnnaammee}}, значение которой определяет полное имя поддерева
     РУБИН;  оно  используется такими системными программами, как
     ddeemmooddbb.   Во-   вторых,   считывается   файл   инициализации
     ......//ffiilleess//ssttaarrttuupp.   Этот файл предназначается для определе-
     ния системнозависимых  параметров,  таких,  как  редактор  и
     shell.   В-третьих, считывается и выполняется файл инициали-
     зации пользователя, указанный в соответствующем поле регист-
     рационного  файла  пользователей  "users".   Это обычно файл
     ``._r_u_b_i_n'' в домашнем каталоге пользователя.  Файл инициали-
     зации  может  применяться для определения некоторых макроко-
     манд, выполнение часто используемых операторов указания диа-
     пазона  и  т.д.   Наконец, управление передается на терминал
     пользователя.


                              - 4 -








MMOONNIITTOORR((QQUUEELL))      ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL       MMOONNIITTOORR((QQUUEELL))


     Прерывание выполнения любого из файлов инициализации вызовет
     повторное выполнение данного шага.

     ККллююччии

     В командой строке могут быть заданы ключи для РУБИН,  влияю-
     щие на режим работы терминального монитора. Ключ --aa отменяет
     функцию автоочистки.  Это означает, что буфер  запросов  ни-
     когда  не  будет  стираться  автоматически; это эквивалентно
     тому, что после каждого \\ggoo вводится команда  \\aappppeenndd.   Это
     означает,  что пользователь должен явным образом очищать бу-
     фер запросов командой \\rreesseett после каждого запроса.  --dd отк-
     лючает  печать  ddaayyffiillee.  --ss отключает печать всех сообщений
     (за исключением сообщений об ошибках) монитора, включая  ре-
     гистрационные  и  выходные  сообщения,  ddaayyffiillee и подсказки.
     Этот режим используется для выполнения запросов,  направляе-
     мых из файлов.

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     ingres(демос), quel(quel), macros(quel)

ДДИИААГГННООССТТИИККАА
          ggoo
                    Вы можете печатать новый запрос

          ccoonnttiinnuuee  Предыдущий запрос окончен и  вы  вернулись  в
                    монитор.

          EExxeeccuuttiinngg
                    Запрос обрабатывается РУБИН.

          >>>>eedd      Вы вошли в текстовый редактор ДЕМОС.

          >>>>sshh      Вы вышли на  интерпретатор  командного  языка
                    системы ДЕМОС.

          ННееддооппууссттииммыыйй ссииммввоолл nnnnnn ппррееооббррааззууееттссяя вв ппррооббеелл
                    РУБИН отображает непечатаемые символы ASCII в
                    пробелы;  это  сообщение указывает на то, что
                    только что имело место
                     одно такое преобразование.













                              - 5 -








PPEERRMMIITT((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        PPEERRMMIITT((QQUUEELL))



ИИММЯЯ
     permit - добавить права доступа к отношению

ФФООРРММААТТ
     ddeeffiinnee ppeerrmmiitt список_разрешений { oonn | ooff | ttoo }  переменная
     [ (список_объектов) ]
          ttoo имя [ aatt терминал ] [ ffrroomm время ttoo время ]
          [ oonn день_нед ttoo день_нед ] [ wwhheerree условие ]

ООППИИССААННИИЕЕ
     Оператор _p_e_r_m_i_t распространяет текущие права доступа на  от-
     ношение,       определенное      параметром      _п_е_р_е_м_е_н_н_а_я.
     _С_п_и_с_о_к__р_а_з_р_е_ш_е_н_и_й это список возможных операций, разделенных
     запятыми,  которыми  могут  быть: rreettrriieevvee, rreeppllaaccee, ddeelleettee,
     aappppeenndd, или aallll; _a_l_l является специальным случаем,  означаю-
     щим разрешение всех прав.  _И_м_я это регистрационное имя поль-
     зователя или слово aallll.  _Т_е_р_м_и_н_а_л это имя терминального уст-
     ройства  в форме `tty_x' или ключевое слово aallll; пропуск этой
     фразы эквивалентно спецификации _a_l_l.  _В_р_е_м_я должно быть ука-
     зано  в форме `hh:mm' на двадцатичетырехчасовой шкале, кото-
     рое ограничивает время дня, во время которого действуют ука-
     занные  разрешения.   _Д_е_н_ь__н_е_дэто трехбуквенная аббревиатура
     дня недели.   _У_с_л_о_в_и_е  добавляется  к  квалификации  запроса
     когда он выполняется.

     Отдельные части единственного оператора  _p_e_r_m_i_t  объеиняются
     (как  логическое AND).  Несколько операторов _p_e_r_m_i_t разъеди-
     няются (как логическое OR).  Например, если вы используете

             . . . to eric at tty4 . . .

     ,то _p_e_r_m_i_t применяется только к eric, когда он зарегистриро-
     ван на tty4, но если вы используете два оператора _p_e_r_m_i_t,

             . . . to eric at all . . .
             . . . to all at tty4 . . .

     тогда, когда eric зарегистрирутся на tty4, он получит  общие
     разрешения, определенное этими двумя опереторами.  Если eric
     зарегистрируется на ttyd он получит только разрешения  уста-
     навливаемые  первым  оператором _p_e_r_m_i_t, а если bob войдет на
     tty4, то он получит только разрешения, устанавливаемые  вто-
     рым оператором _p_e_r_m_i_t.

     Использование команды _p_e_r_m_i_t разрешено только владельцу  от-
     ношения.   Хотя  пользователь, не являющийся DBA может попы-
     таться выполнить команду _p_e_r_m_i_t но это  будет  бессмысленно,
     т.к.  он не имеет к ним доступа.

     Ограничения, заданные командой _p_e_r_m_i_t не распространяются на
     владельцев отношений.


                              - 1 -








PPEERRMMIITT((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        PPEERRMMIITT((QQUUEELL))


     Операторы

             define permit all on x to all
             define permit retrieve of x to all

     без задания _у_с_л_о_в_и_й рассматриваются как специальные случаи и
     являются, таким образом, особенно эффективными.

ППРРИИММЕЕРРЫЫ
       range of e is employee
       define permit retrieve of e (name, sal) to marc
            at ttyd from 8:00 to 17:00
            on Mon to Fri
            where e.mgr = "marc"

       range of p is parts
       define permit retrieve of e to all

ССММ..ТТААККЖЖЕЕ
     destroy(quel)


































                              - 2 -








PPRRIINNTT((QQUUEELL))        ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL         PPRRIINNTT((QQUUEELL))



ИИММЯЯ
     print - печать отношения(ий)

ФФООРРММААТТ
      pprriinntt _и_м_я__о_т_н {,, _и_м_я__о_т_н}

ООППИИССААННИИЕЕ
     PPrriinntt показывает содержимое каждого указанного отношения  на
     терминале (стандартном выводе).  Форматы для различных типов
     доменов должны быть такими, какиe использует rruubbiinn..  Имя до-
     мена изменяется таким образом, чтобы соответствовать указан-
     ной ширине.

     Для печати отношения надо быть или его владельцем или  отно-
     шение  должно иметь разрешения ``retrieve to all'' или ``all
     to all''.

     См. rubin(quel) для уточнения детелей.

ППРРИИММЕЕРР..
     /* Печать отношения emp */
        print emp
     /* Печать отношений emp, parts */
        print emp, parts

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     permit(quel),  retrieve(quel),   rubin(демос)   используемые
     длинные строки - обрезаются

     _P_r_i_n_t будет иметь более развитый формат для удобства чтения.

     _P_r_i_n_t будет иметь возможность печати на АЦПУ.





















                              - 1 -








RRAANNGGEE((QQUUEELL))        ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL         RRAANNGGEE((QQUUEELL))



ИИММЯЯ
     range - объявляет переменную, действующую на отношении.

ФФООРРММААТТ
       rraannggee ooff _п_е_р_е_м_е_н_н_а_я iiss _и_м_я__о_т_н_о_ш_е_н_и_я

ООППИИССААННИИЕЕ
     RRaannggee используется для объявления переменных, которые  будут
     использоваться  в  последующих  операторах QUEL.  _П_е_р_е_м_е_н_н_а_я
     связывается с указанным отношением с помощью  _и_м_я__о_т_н_о_ш_е_н_и_я.
     Когда  _п_е_р_е_м_е_н_н_а_я используется в последующих операторах, она
     будет  относиться  к  кортежу  в  поименованном   отношении.
     Об'явление  диапазона варьирования остается в силе в течение
     всего сеанса РУБИН (до выхода из РУБИН), до  тех  пор,  пока
     переменная  не  объявляется  заново  последующим  оператором
     range,или отношение не разрушается с  помощью  команды  des-
     troy.   Существует ппррааввииллоо ууммооллччаанниияя - если в операторе QUEL
     встречается неопределенная переменная, и существует  отноше-
     ние  с  таким же именем, как и у этой переменной, переменная
     связывается с указанным отношением.

ППРРИИММЕЕРР
     /* Об'явить переменную кортежа е изменяющуюся на отношении emp */
        range of e is emp

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     quel(quel), destroy(quel)

ЗЗААММЕЕЧЧААННИИЯЯ
     В любой момент времени могут быть  задействованы  только  10
     описаний переменных.  После 10 оператора range переменная на
     которую делалась последняя ссылка  используется  заново  для
     следующего оператора range.




















                              - 1 -








RREEPPLLAACCEE((QQUUEELL))      ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL       RREEPPLLAACCEE((QQUUEELL))



ИИММЯЯ
     replace - заменить значение доменов в отношении

ФФООРРММААТТ
      rreeppllaaccee _к_о_р_т_е_ж-_п_е_р_е_м_е_н_н_а_я ((_с_п_и_с_о_к__о_б_ъ_е_к_т_о_в)) [wwhheerree _у_с_л_о_в_и_е]

ООППИИССААННИИЕЕ
     RReeppllaaccee   изменяет   значение   доменов    определенных    в
     _с_п_и_с_к_е__о_б_ъ_е_к_т_о_в для всех кортежей, которые удовлетворяют _у_с_-
     _л_о_в_и_ю.  Должна быть объявлена _к_о_р_т_е_ж__п_е_р_е_м_е_н_н_а_я, которая из-
     меняется в модифицируемом отношении.  Заметим, что требуется
     ккооррттеежж--ппееррееммееннннааяя, а не  имя  отношения.   В  _с_п_и_с_к_е__о_б_ъ_е_к_о_в
     должны присутствовать только те домены, которые подлежат мо-
     дификации.   Эти   домены   должны   быть   определены   как
     имя_результата в _с_п_и_с_к_е__о_б_ъ_е_к_т_о_в в явном виде, либо по умол-
     чанию (см. quel(quel)).

     Числовые домены могут быть заменены на значения любого  чис-
     лового  типа (за исключением отмеченных ниже).  Значения за-
     мены будут преобразовываться в тип результирующего домена.

     Замену может производить только владелец отношения или поль-
     зователь, имеющий разрешение на замену.

     Если  обновление кортежа может нарушить ограничение  целост-
     ности (см. integrity(quel)), то оно не производится.

ППРРИИММЕЕРР
     /* Всем служащим, которые работают на Смита,
            дать 10% надбавку                         */
        range of e is emp
        replace e(sal = 1.1 * e.sal) where e.mgr = "Smith"

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     integrity(quel), permit(quel), quel(quel), range(quel)

ДДИИААГГННООССТТИИККИИ
     Использование выражения числового  типа  для  замены  домена
     символьного  типа или наоборот повлечет выдачу диагностичес-
     ких сообщений.













                              - 1 -








RREETTRRIIEEVVEE((QQUUEELL))     ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL      RREETTRRIIEEVVEE((QQUUEELL))



ИИММЯЯ
     retrieve - получить кортежи из отношения.

ФФООРРММААТТ
      rreettrriieevvee [[iinnttoo] _и_м_я__о_т_н_о_ш_е_н_и_я] ((_ц_е_л_е_в_о_й__с_п_и_с_о_к)) [wwhheerree _у_с_-
     _л_о_в_и_е]
      rreettrriieevvee uunniiqquuee ((_ц_е_л_е_в_о_й__с_п_и_с_о_к)) [wwhheerree _у_с_л_о_в_и_е]

ООППИИССААННИИЕЕ
     RReettrriieevvee будет выбирать все кортежи,  которые  удовлетворяют
     условию  и  либо отображать их на терминале( стандартном вы-
     воде ), либо запоминать в новом отношении.

     Если _и_м_я__о_т_н_о_ш_е_н_и_я определено, то  результат  запроса  будет
     запоминаться  в новом отношении с указанным именем.  Отноше-
     ние с таким именем не должно существовать. Текущий пользова-
     тель  будет  владельцем  нового  отношения.  Отношение будет
     иметь   имена   доменов,   определенных   в   _ц_е_л_е_в_о_м    как
     _и_м_я__р_е_з_у_л_ь_т_а_т_а.  Новое отношение будет сохраняться в системе
     в течение 7 дней, если пользователь  не  указывает  в  явном
     виде более позднюю дату и не является хозяином базы данных.

     Если указано ключевое слово uunniiqquuee,,  то  перед  отображением
     кортежи  будут рассортированы по первому домену, а дублирую-
     щиеся кортежи удалены.

     Если требуется получить все домены, то может быть  использо-
     вано ключевое слово aallll..

     Если нет значения _и_м_е_н_и__о_т_н_о_ш_е_н_и_я, то в этом случае  резуль-
     тат запроса отображается на терминале и не сохраняется.  При
     отображении результата на терминале,  повторяющиеся  кортежи
     не удаляются.

     Формат, в котором распечатываются домены, может быть опреде-
     лен при вызове rubin (см. rubin(демос)).

     Если указано результирующее отношение, то по  умолчанию  оно
     будет модифицироватся в структуру памяти типа cheapsort, при
     которой дублирующиеся кортежи удаляются.  Это может  заметно
     замедлить работу, особенно если в дальнейшем в созданных от-
     ношениях производятся замены  оператором  rreeppllaaccee.   Правило
     умолчания для модификации вновь созданных отношений отключа-
     ется при вызове  РУБИН с ключом --rr (см. rubin(демос)).  Нап-
     ример:

      в _Q_U_E_L:

      rubin -rheap base1

      в _E_Q_U_E_L:


                              - 1 -








RREETTRRIIEEVVEE((QQUUEELL))     ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL      RREETTRRIIEEVVEE((QQUUEELL))


      ## rubin "-rheap" baza1


     Только владелец отношения и пользователи  с  разрешением  на
     выполнение оператора rreettrriieevvee над этим отношением могут осу-
     ществлять выбор кортежей из этого отношения.

ППРРИИММЕЕРР
     /* Найти всех служащих, которые получают  */
     /*         больше, чем их руководитель                 */
        range of e is emp
        range of m is emp
        retrieve (e.name) where e.mgr = m.name
                 and e.sal > m.sal
     /* Выбрать все домены для тех служащих, кто получает */
             заработную плату больше средней                  */
        retrieve into temp (e.all) where e.sal > avg(e.sal)
     /* Выбрать отсортированные имена служащих */
        retrieve unique (e.name)

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     modify(quel),   permit(quel),    quel(quel),    range(quel),
     save(quel), rubin(демос)































                              - 2 -








SSAAVVEE((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          SSAAVVEE((QQUUEELL))



ИИММЯЯ
     save - сохранять отношение до определенной даты

ФФООРРММААТТ
      ssaavvee _r_e_l_n_a_m_e uunnttiill _m_o_n_t_h _d_a_y _y_e_a_r

ООППИИССААННИИЕЕ
     SSaavvee используется для того, чтобы сохранять отношения  свыше
     его семидневного жизненного цикла.

     _M_o_n_t_h может быть целым числом  от 1 до 12 или названием  ме-
     сяца, сокращенным либо мнемоническим.

     _d_a_y _y_e_a_r - целые числа, обозначающие день месяца  и  год..s3
     Только владелец отношения может дать команду _s_a_v_e для сохра-
     нения данного отношения.  Существует процесс РУБИН,  который
     специально удаляет отношение сразу же после истечения срока,
     помеченного указанной датой.

     Фактически, программа, которая уничтожает отношения  называ-
     ется  чисткой ( purge ).  При удалении отношений принимается
     локальное решение.

     Системные отношения не имеют даты окончания хранения.  Отно-
     шения,  которые создает администратор базы данных, также по-
     лучают бесконечный срок хранения.

ППРРИИММЕЕРР
     /* Сохранить отношение emp до конца февраля 1987 */
        save emp until feb 28 1987

ССММ..ТТААККЖЖЕЕ
     create(quel), retrieve(quel), purge(unix)




















                              - 1 -








SSEERRIIAALL((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        SSEERRIIAALL((QQUUEELL))



ИИММЯЯ
     sseerriiaall - работа с глобальными переменными в языке QUEL.

ФФООРРММААТТ
      ddeeffiinnee _и_м_я==_з_н_а_ч_е_н_и_е - создание переменной;
      ddeessttrrooyy _и_м_я - уничтожение переменной;
      функция sseerr__nneexxtt((""_и_м_я"")) - операция v++;
      функция sseerr__llaasstt((""_и_м_я"")) - дай предыдущее значение;
      функция sseerr__sseett((""_и_м_я"",,_з_н_а_ч_е_н_и_е)) - инициализация.

ООППИИССААННИИЕЕ
     Глобальные переменные языка QUEL  предназначены  в  основном
     для  получения уникальных номеров при занесении информации в
     базу данных.  Они представляют собой числа формата ii44, кото-
     рые  хранятся  в базе данных под заданными именами (образуе-
     мыми по таким же правилам, как и имена отношений) и с  кото-
     рыми можно делать следующие операции:

     1. Создать переменную:

      ddeeffiinnee _и_м_я==_з_н_а_ч_е_н_и_е

     Оператор создает новую глобальную переменную под именем  _и_м_я
     и  присваивает ей начальное значение _з_н_а_ч_е_н_и_е. В базе данных
     не должно существовать отношений или переменных под заданным
     _и_м_е_н_е_м;  _з_н_а_ч_е_н_и_е  должно  быть  целой  константой (возможна
     константа типа ddaattee или ttiimmee).  _и_м_я - идентификатор, состоя-
     щий  не более чем из 8-ми букв и цифр и начинающийся с буквы
     (символ __ считается буквой),  причем  строчные  и  прописные
     буквы считаются эквивалентными:

     2. Получить текущее значение переменной, увеличив затем зна-
     чение  переменной  на  1 (аналогично операции vv++++ языка Си),
     можно с помощью функции языка QUEL (функция может  быть  ис-
     пользована в любом выражении в операторах QUEL):

      sseerr__nneexxtt((""_и_м_я""))

     Значением этой функции является текущее значение  переменной
     "_и_м_я",  причем значение переменной после каждого обращения к
     функции увеличивается на 1 неразделяемым образом (гарантиру-
     ется, что при параллельной работе нескольких запросов к базе
     данных каждое обращение  к  sseerr__nneexxtt  выработает  уникальное
     значение).   Эта функция используется для выработки уникаль-
     ных чисел.

     3. Получить снова значение переменной, которое  было  выдано
     при последнем обращении к sseerr__nneexxtt или sseerr__sseett:

      sseerr__llaasstt((""_и_м_я""))



                              - 1 -








SSEERRIIAALL((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        SSEERRIIAALL((QQUUEELL))


     Функция может быть вызвана, только если в текущем сеансе ра-
     боты  с  базой данных были обращения к функциям sseerr__nneexxtt или
     sseerr__sseett с данным именем переменной. Она выдает значение  пе-
     ременной,  полученное  из  базы  данных в последний раз. Эта
     функция  позволяет,  получив  уникальное  значение  функцией
     sseerr__nneexxtt,  затем  использовать  его несколько раз (например,
     получив номер очередной книги для записи новой книги в  базу
     данных, на него затем можно ссылаться с помощью данной функ-
     ции).

     4. Можно инициализировать переменную с помощью функции:

      sseerr__sseett((""_и_м_я"",, _з_н_а_ч_е_н_и_е))

     Переменная должна уже существовать.  Эта  функция  позволяет
     инициализировать  переменную  значением, полученным в опера-
     торе QUEL, в отличие от оператора ddeeffiinnee, в котором значение
     переменной  задается  константой.  Функция выдает в качестве
     результата значение переменной, которое та имела до  инициа-
     лизации.

     5. Уничтожить переменную можно оператором ddeessttrrooyy.

      ddeessttrrooyy _и_м_я__п_е_р_е_м_е_н_н_о_й

ППРРИИММЕЕРР

     Допустим, у нас есть три отношения,  в  которые  записывются
     результаты  экспериментов:  эксперимент  -  описания условий
     эксперимента, значения - описание результатов  эксперимента,
     коммент  -  комментарии к экспериментам. Для связи их друг с
     другом служит уникальный номер эксперимента (номер).   Заве-
     дем  в  базе  данных переменную с очередным номером экспери-
     мента:

      ddeeffiinnee mmaaxx__nnuumm==11

     Теперь для записи информации об очередном эксперименте нужно
     будет выполнить следующие операторы QUEL:

      aappppeenndd ttoo ээккссппееррииммееннтт
        ((ннооммеерр==sseerr__nneexxtt((""mmaaxx__nnuumm"")),,
        ....ппррииссввааииввааннииее ооссттааллььнныыхх ззннааччеенниийй.... ))
      aappppeenndd ttoo ззннааччеенниияя
        ((ннооммеерр==sseerr__llaasstt((""mmaaxx__nnuumm"")),,
        ....ппррииссввааииввааннииее ооссттааллььнныыхх ззннааччеенниийй.... ))
      aappppeenndd ttoo ккооммммееннтт
        ((ннооммеерр==sseerr__llaasstt((""mmaaxx__nnuumm"")),,
        ....ппррииссввааииввааннииее ооссттааллььнныыхх ззннааччеенниийй.... ))





                              - 2 -








SSEERRIIAALL((QQUUEELL))       ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL        SSEERRIIAALL((QQUUEELL))


ППРРИИММЕЕЧЧААННИИЯЯ

     Посмотреть значение переменной  можно  с  помощью  оператора
     hheellpp.   Переменные  хранятся в системном отношении rreellaattiioonnss
     как особый тип отношения,  значение  переменной  хранится  в
     поле длины кортежа.
















































                              - 3 -








VVIIEEWW((QQUUEELL))         ССУУББДД РРУУББИИНН.. ООППЕЕРРААТТООРРЫЫ QQUUEELL          VVIIEEWW((QQUUEELL))



ИИММЯЯ
     view - определить виртуальное отношение

ФФООРРММААТТ
      ddeeffiinnee vviieeww _и_м_я ((_с_п_и_с_о_к__о_б_ъ_е_к_т_о_в))[wwhheerree _у_с_л_о_в_и_е]

ООППИИССААННИИЕЕ
     Синтаксис оператора vviieeww почти идентичен оператору  rreettrriieevvee
     iinnttoo;;  однако,  при  этом данные не выбираются. Вместо этого
     запоминается определение.  Когда  впоследствии  используется
     отношение  _и_м_я, запрос преобразуется т.о., чтобы оперировать
     на отношениях, указанных в _с_п_и_с_к_е__о_б_ъ_е_к_т_о_в.

     Осуществляется полная поддержка всех видов поиска на  вирту-
     альном  отношении, однако поддерживается только ограниченный
     набор обновлений, что связано с возможностью повреждения ис-
     ходных  отношений,  на  которых  задано виртуальное.  Нельзя
     производить изменения виртуальных отношений, заданных более,
     чем на одном отношении.  Не поддерживаются обновления, кото-
     рые влияют на домены в  определении  виртуального  отношения
     или, которые влияют на домены не переводимые в простой атри-
     бут.  Для виртуальных отношений не определен  псевдо-атрибут
     ttiidd..

     В основном, обновление поддерживается в том и только  в  том
     случае, когда можно гарантировать (без просмотра фактических
     данных), что  результат  обновления  виртуального  отношения
     идентичен  результату  обновления соответствующего реального
     отношения.

     Пользователь, который определяет виртуальное отношение, дол-
     жен быть владельцем всех отношений, на которых строится вир-
     туальное отношение.

ППРРИИММЕЕРР
     range of e is employee
     range of d is dept
     define view empdpt (ename = e.name, e.sal, dname = d.name)
             where e.mgr = d.mgr

ДДООППООЛЛННИИТТЕЕЛЛЬЬННЫЫЕЕ ССССЫЫЛЛККИИ
     retrieve(quel), destroy(quel)











                              - 1 -




