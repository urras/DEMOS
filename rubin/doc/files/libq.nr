.th LIBQ FILES "СУБД \*(RU. СТРУКТУРА ФАЙЛОВ"
.sh ИМЯ
libq \- библиотека поддержки EQUEL на фазе  выполнения.
.sh ФОРМАТ
 /* \fB Файлы вставок\fR
 # include <rubin.equel.h>
 # include <rubin/datetime.h>

 /* \fBРабота со строками и преобразование\fR   */
 IIatoi(s,i)  char *s; int *i;
 IIbmove(s,d,l)  char *s, *d; int l;
 char *IIconcatv(buf, s1, s2, ..., NULL)
 char *buf, *s1, *s2 ...;

 char *IIitos(i) int i;
 int IIlength(s) char *s;
 int IIsequal(s1, s2) char *s1, *s2;

 /* \fB Преобразования дата-время<->текст  \fR  */
 EQ_date char_date(in, ss) char *in, *ss;
 EQ_time char_time(in,ss) char *in; char *ss;

 char *date_char(date,ss) EQ_date date; char *ss;
 char *time_char(time,ss) EQ_time time; char *ss;

 int date_len(ss) char *s;
 int time_len(ss) char *s;

 /* \fBСтруктуры распакованной даты и времени \fR  */
 /* \fBОписаны в rubin/datetime.h \fR*/
 struct cd_date {
  int cd_year, cd_month, cd_day, cd_2year, cd_week;}
 struct cd_time {
  int cd_hh, cd_mm, cd_ss; }

 /* \fB Распаковка в структуру \fR */
 date_cd(date,pcd) EQ_date date;struct cd_date *pcd;
 time_cd(time,pcd) EQ_time time;struct cd_time *pcd;

 /* \fB Запаковка из структуры \fR  */
 EQ_date cd_date(pcd) struct cd_date *pcd;
 EQ_time cd_time(pcd) struct cd_time *pcd;

 d = get_date() - текущая дата
 t = get_time() - текущее время


 /* \fBМакро управления диагностикой ошибок \fR*/
 EQ_ONERR - включить
 EQ_OFFERR - выключить
 EQ_ERR - 1, если была ошибка, 0 - если нет.

 /* \fBПеременные (описаны в rubin/equel.h) \fR*/
 extern int (*IIinterupt)();  - прерывание
 extern int (*IIprint_err)(); - вызов по ошибке
 extern int (*IIout_err)(); - печать строки сообщения
 extern int (*IIabort)(); - пришла системная ошибка
 extern int IIerrflag; - код ошибки
 extern int IItupcnt;  - число полученных/измененных кортежей
 extern char *IImainpr; - имя программы `rubin'

 /* \fBВызов системной ошибки \fR */
 IIsyserr(form, p1, ...) char *form;


.sh ОПИСАНИЕ
Библиотека libq содержит служебные подпрограммы языка Equel и
ряд подпрограмм и переменных, полезных пользователю Equel.
Для работы с ними необходимо в программу на Equel или на Си
включить файл вставок:

 # include <rubin/equel.h>

Для работы с подпрограммами преобразования даты и времени
необходимо добавить:

 # include <rubin/datetime.h>

.sh "1. Переменные Equel"
Они позволяют управлять обработкой ошибок и прерываний,
и опрашивать результат выполнения операторов.
Переменная \fBIIinterupt\fR позволяет указать адрес
функции, которую нужно вызвать в случае прерывания задачи с,
терминала (функция \fBsignal\fR для такого указания не
годится, поскольку прерывание сначала должно быть правильно
обработано системной Equel). После обработки прерывания Equel
вызывает указанную функцию:

 if ( IIinterupt) (*IIinterupt)(-1);

Переменная \fBIIabort\fR указывает на функцию обработки фатальных
ошибок. При появлении такой ошибки Equel после выдачи сообщения
осуществляет вызов:

 if ( IIabort) (*IIabort)(-1);
 exit(1);

Переменные \fBIIprint_err\fR и \fBIIout_err\fR позволяют
управлять печатью сообщений об ошибках. При приходе ошибки
или предупредительного сообщения Equel сначала вызывает
функцию, указанную в \fBIIprint_err\fR:

 ko= (*IIprint_err)(код_ошибки);

Затем, если код ответа \fIko\fR отличен от 0, вызывается программа
печати диагностического сообщения об ошибке, номер которой берется из
полученного кода ответа. Программа печати извлекает строки
сообщения из файла диагностик, делает все необходимые подстановки
и затем для каждой строки сообщения вызывает функцию печати по
адресу, указанному в \fBIIout_err\fR:

 for ( для каждой строки сообщения )
 (*IIout_err)(строка_сообщения);

Имеются два макро, которые позволяют включить и
выключить печать сообщений об ошибках:

 \fBEQ_ONERR\fR - включить печать;
 \fBEQ_OFFERR\fR - выключить печать;

Они просто засылают в \fBIIprint_err\fR адреса стандартных
подпрограмм Equel \fBIIret_err\fR и \fBIIno_err\fR, возвращающих
код ошибки и 0 соответственно.

Переменная \fBIIerrflag\fR содержит код завершения очередного
оператора Equel: \fB0\fR означает успешное завершения оператора,
иначе переменная содержит код последней ошибки. После выполнения
операторов манипулирования данными или выборки данных
в переменную \fBIItupcnt\fR засылается число кортежей, выбранных
в операторе выборки либо изменившихся после операторов \fBappend\fR,
\fBreplace\fR или исключенных в операторе \fBdelete\fR.
(Нужно иметь в виду, что считаются только кортежи, изменившие свое
содержание, оператор `replace a(name=a.name)' не приведет ни к
каким реальным изменения кортежей и \fBIItupcnt\fR будет равен 0).

Для опроса ошибок служит макро \fBEQ_ERR\fR, например:

 ## replace ....
 if (EQ_ERR) сообщение об ошибке;

Переменная \fBIImainpr\fR содержит имя команды управления базой
данных; по умолчанию это "rubin". Эта переменная служит в
основном для отладки.

.sh "2. Вспомогательные функции"
.i0
.s2
.if n .ta 10 25 35
.if n .in 24
.if t .ta 1.0i 2.5i 3.5i
.if t .in 2.5i
.de xx
.lp +10 5
\fB\\$1\fR(\\$2)\ \\$3
.br
..
.xx IIatoi s,i "char *s;int *i;
преобразование строки \fIs\fR в целую переменную \fI*i\fR.
Код ответа: 0 - хорошо, 1 - переполнение, -1 - ошибка.
.xx IIbmove s,d,l "char *s, *d; int l;
перепись из \fIs\fR в массив \fId\fR
массива длиной \fIl\fR байт.
.xx "char\ *IIconcatv" buf,s1,s2,...,NULL "char\ *buf,*s1,*s2,...;
Все строки \fIs1,s2,...\fR сливаются вместе и переписываются в \fIbuf\fR.
Код ответа - указатель на конец полученной строки.
.xx "char *IItos" i "int i;
Преобразование целого в текстовый вид. Возвращается указатель на
статическую область память, которая портится при следующем обращении
к этой функции.
.xx IIlength s "char *s;"
Возврашает длину строки, если она не превышает 255, иначе 255.
.xx IIsequal s1,s2 "char *s1,*s2;"
Возвращает 0, если строки не равны, и 1, если равны.
.xx IIsyserr "form,p1,p2,..." "char *form;"
Печать сообщения о системной ошибке с последующим
завершением программы. Параметры аналогичны \fBprintf\fR.
.i0
.dt
.sh "3. Преобразование даты и времени"
Для использования функций, описанных в этом разделе, в программу
нужно добавить файл вставок:

 # include <rubin/datetime.h>

В Equel дата и время представляются в виде длинных целых чисел.
Переменные типа date и time могут быть описаны как \fBEQ_DATE\fR
и \fBEQ_TIME\fR соответственно.
Для их преобразования в текстовый формат и обратно служат
следующие функции:
.i0
.if n .ta 10 25 35
.if n .in 24
.if t .ta 1.0i 2.5i 3.5i
.if t .in 2.5i
.xx "EQ_DATE char_date in,ss "char *in, *ss;"
.ns
.xx "EQ_TIME time_date in,ss "char *in, *ss;"
Эти функции преобразуют строку \fIin\fR в дату (время)
по формату \fIss\fR либо по формату умолчания, если ss==NULL.
Описания форматов даны в разделе date(quel).
Если строка \fIin\fR не соответствует формату \fIss\fR либо формат
содержит ошибки, возвращается отрицательное значение.
.xx "char *date_char" date,ss "EQ_date date;char *ss;"
.ns
.xx "char *time_char" time,ss "EQ_time time;char *ss;"
Эти функции преобразуют дату (время) в текстовый вид и
возвращают указатель на статический буфер.
NULL означает ошибку в формате.
.xx "date_len ss "char *ss;"
.ns
.xx "time_len ss "char *ss;"
Возвращают длину даты (времени)
в текстовом виде, которые будут получаться по шаблону \fIss\fR.
0 означает ошибку в шаблоне.
.i0
.sh "4. Распаковка/запаковка даты и времени"
Дата или время могут быть представлены не только в компактной
или текстовой форме, но и в виде структуры

 struct cd_date {
 int cd_year;  /* Год */
 int cd_month; /* Месяц 1-12 */
 int cd_day;   /* День месяца */
 int cd_2year; /* Год % 100 */
 int cd_week;  /* День недели, 1-7 */
 } - ДАТА

 struct cd_time {
 int cd_hh;    /* Часов */
 int cd_mm;    /* Минут */
 int cd_ss;    /* Секунд*/
 } - ВРЕМЯ

Для преобразования служат функции:
.xx date_cd date,pcd "EQ_date date;struct cd_date *pcd;"
.ns
.xx time_cd time,pcd "EQ_time time;struct cd_time *pcd;"
Преобразование даты (времени) в структуру.
.xx "EQ_date cd_date" pcd "struct cd_date *pcd;"
.ns
.xx "EQ_time cd_time" pcd "struct cd_time *pcd;"
Обратное преобразование.

.i0
.sh "5. Запрос даты и времени"
.xx get_date ""
.ns
.xx get_time ""
Это не функции, а макро. Они дают текущую дату или время при
первом обращении, а затем повторяют ответ. Для обновления текущих
даты и времени нужно вызвать макро \fBnew_datime\fR.
Между вызовами этой функции \fBget_date\fR и \fBget_time\fR
дают согласованный ответ (время первого вызова или последнего
вызова \fBnew_datime\fR).
.sh "ДОПОЛНИТЕЛЬНЫЕ ССЫЛКИ"
 Equel(quel) - описание языка Equel
 equel(demos) - описание прекомпилятора
 "Программирование на языке Equel" - подробное руководство.

