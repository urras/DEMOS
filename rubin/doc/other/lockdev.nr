.de @f
'sp 3
'tl 'Как устанавливать устройство разделяемого доступа''Стр %'
'bp
..
.t0
Инструкция по установке \*(RU
с разделяемым доступом в ОС \*(DM
.t1
.sp 3
В \*(RU полностью используется механизм управления
одновременным доступом.
Система \*(RU устанавливает и снимает блокировки с помощью
записей на устройство, называемое "/dev/lock".
Если это устройство не может быть открыто на запись,
\*(RU запускается без какой бы то ни было поддержки
одновременного доступа.

Первоначально целесообразно запустить
\*(RU без управления одновременным доступом.
Если планируемое использование
\*(RU требует одновременного доступа,
то в вашей системе \*(DM должно быть
установлено устройство
"/dev/lock".

Этот документ описывает процедуру установки драйвера
для устройства
"/dev/lock" в системе \*(DM.

.ul
.sh 1
Вход в систему (под именем root).
.br
.ul
.sh 1
Компиляция устройства разделяемого доступа.
.br
.PS
.dn
Копирование исходных текстов и файлов.
.PS
Устройство разделяемого доступа состоит из
двух файлов:
.../source/support/ildr.c
и .../source/support/ilock.h

Переименуйте исходный файл в
/usr/sys/dmr/ildr.c,
а файл /source/support/ilock.h в
/usr/sys/dmr/ilock.h

.nf

	mv .../source/support/ildr.c /usr/sys/ildr.c
	mv .../source/support/ilock.h /usr/sys/ilock.h

.fi
.ul
.sh "Параметры для установки."
.br
.PS
Различные параметры, определяемые в
ildr.h должны определяться пользователем.
Это включает:

.nf
	NLOCKS - число блокировок
	PLOCKS - блокировку страницы
	RLOCKS - блокировку отношения
	DLOCKS - блокировку базы данных

.fi
NLOCKS \- максимальное число разрешенных блокировок.
Он определяет размер таблицы блокировок.
PLOCKS \- максимальное число заблокированных
страниц, отношений и баз данных.
RLOCKS \- максимальное число блокированных отношений и
баз данных.
DLOCKS \- максимальное число блокированных баз данных.
Только DLOCKS могут использоваться одновременно.

Следующие условия должны обеспечивать защиту от
"блокировки насмерть" при переполнении таблицы блокировок:

.nf
	NLOCKS > PLOCKS > RLOCKS > DLOCKS + 6

.fi
Такое число RLOCKS, удовлетворящих этому порядку необходимо для
запуска запросов с 6-ю переменными.
Мы рекомендуем сначала установить
DLOCKS, а затем уже остальные параметры, как
это указано ниже:

.nf
	RLOCKS = 2*DLOCKS + 6
	PLOCKS = RLOCKS + 3
	NLOCKS = PLOCKS + 1
.fi


Например, чтобы уменьшить размер таблицы блокировок, надо установить
DLOCKS = 2, RLOCKS = 10, PLOCKS = 13, NLOCKS = 14.
В этом случае, одновременно с \*(RU смогут работать только 2 пользователя.
.sp 1
Другой пример, чтобы позволить
одновременное пользование \*(RU, установим:
DLOCKS = 20, RLOCKS = 46, PLOCKS = 49, NLOCKS = 50.
Такие значения параметров позволяют использовать \*(RU
одновременно 20-и пользователям.

Для драйвера устройствa "/dev/lock" трубуется
1008 байт в текстовом сегменте и
36 + 18 * NLOCKS в сегментах DATA и BSS.

.ul
.sh "Смена каталога."
.br
.PS
Перейдите в каталог, где хранятся драйверы устройств вашей системы.

.nf
	chdir /usr/sys/dmr

.fi
.ul
.sh "Трансляция и обновление библиотеки \*(DM."
.br
.PS
Объектные коды \*(DM поделены на две библиотеки,
lib1 (коды системы)
and lib2 (драйверы устройств).
Оттранслируйте
ildr.c и поместите ее в lib2

.nf
	cc -c -O ildr.c
	ar rv ../lib2 ildr.o
.fi
.ul
.sh "Установка устройства в файловой системе \*(DM."
.br
.PS
Для установки устройства в систему, файл
конфигурации должен быть изменен.
.dn
Редактирование /usr/sys/conf/conf.c ( или c.c )
.PS
Отредактируйте файл конфигурации и добавьте устройство
блокировки в список символов устройств.
На некоторых системах файл конфигурации
называется conf.c, а на некоторых c.c.
Найдите последнее устройство в таблице
"cdevsw[]" и добавьте строку:

.nf
	&nulldev,  &nulldev,  &nulldev,  &ilwrite,  &nodev,

.fi
Номер строки записи об устройстве становится номером устройства.
.ul
Помните, что отсчет ведется с нуля.
.ul
.sh "Трансляция conf.c (или c.c)"
.br
.PS
Оттранслируйте файл конфигурации.

.ti +8
chdir /usr/sys/conf
.ti +8
cc -c conf.c
.ul
.sh "Обновление системного вызова exit()."
.br
.PS
.dn
Редактирование /usr/sys/ken/sys1.c.
.PS
Системный вызов exit должен быть изменен для вызова
устройства разделяемого доступа.
Это необходимо в случаях, когда происходит
ненормальное завершение процессов \*(RU,
например, когда процесс убивают, или когда встречается
ошибка системы.
Должен быть добавлен вызов
"ilrma(q->p_pid)" в
exit() в файле /usr/sys/ken/sys1.c перед меткой
"loop".
Тогда exit будет выглядеть так:

.nf
exit()
{
	register int *q, a;
	register struct proc *p;

	p = u.u_procp;
	p->p_flag =& ~STRC;
	p->p_clktim = 0;
	for(q = &u.u_signal[0]; q < &u.u_signal[NSIG];)
		*q++ = 1;
	for(q = &u.u_ofile[0]; q < &u.u_ofile[NOFILE]; q++)
		if(a = *q) {
			*q = NULL;
			closef(a);
		}
	iput(u.u_cdir);
	xfree();
	a = malloc(swapmap, 1);
	if(a == NULL)
		panic("out of swap");
	p = getblk(swapdev, a);
	bcopy(&u, p->b_addr, 256);
	bwrite(p);
	q = u.u_procp;
	mfree(coremap, q->p_size, q->p_addr);
	q->p_addr = a;
	q->p_stat = SZOMB;
	/*
	 * remove outstanding \*(rN locks for
	 * the dying process
	 */
	ilrma(q->p_pid);

loop:
	for(p = &proc[0]; p < &proc[NPROC]; p++)
	if(q->p_ppid == p->p_pid) {
		wakeup(&proc[1]);
		wakeup(p);
		for(p = &proc[0]; p < &proc[NPROC]; p++)
		if(q->p_pid == p->p_ppid) {
			p->p_ppid  = 1;
			if (p->p_stat == SSTOP)
				setrun(p);
		}
		swtch();
		/* no return */
	}
	q->p_ppid = 1;
	goto loop;
}
.fi

.ul
.sh "Обновление  /usr/sys/lib1"
.br
.PS
Сейчас перетранслируем sys1.c
и обновим lib1:

.nf
	chdir /usr/sys/ken
	cc -c -O sys1.c
	ar rv ../lib1 sys1.o

.fi
.ul
.sh "Перезагрузка \*(DM."
.br
.PS
.dn
Перезагрузка системы.
.PS
Сейчас система готова к перезагрузке.
Следующая процедура для частичной установки.


Убедитесь, что следующие файлы:

.nf
low.o
m45.o ( или m40.o)
conf.o (или c.o)

.fi
имеются в наличии или что процедура загрузки их компилирует.
.ul
.sh "Подготовка к перезагрузке."
.br
.PS
Вы пока не готовы запускать новую систему.
Но т.к. список имен изменился,
вы должны перейти в однопользовательский режим
перед тем как сделать это.
.ul
.sh "Перезагрузка \*(DM."
.br
.PS
Поместите новую систему \*(DM
в каталог, из которого происходит обычная перезагрузка:

.nf
	mv /usr/sys/a.out /unix
.fi

Сейчас перезагрузите систему после команды
sync,
и запустите процедуры, необходимые для нормальной загрузки.

.ul
.sh "Включение устройства в каталог /dev"
.br
.PS
.dn
Создание узла.
.PS
Устройство разделяемого доступа должно быть помещено в
"/dev" после того, как система будет перзагружена.
Выполните команду:

.nf
	/etc/mknod  /dev/lock  c  major  0

.fi
где "major" номер устройства.
Еще раз: номер устройства это позиция устройства
в таблице "cdevsw[]".
Вспомните,  что отсчет начинается с нуля.
.ul
.sh "Установка кодов доступа:"
.br
.PS
Сейчас поменяйте моды устройства на запись
владельцу и установите владельца
\*(RU:

.nf
	chown \*(rN /dev/lock
	chmod 200 /dev/lock
.fi
.ul
.sh "Окончание."
.br
.PS
Теперь \*(RU будет использовать устройство
/dev/lock для обеспечения одновременного доступа пользователей
к базе данных.
Простой способ проверить это, это попытаться запустить
(например) "purge" на какой-то базе данных, пока
кто-то запускает "\*(rN" на этой же базе данных.
