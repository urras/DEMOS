.\" Используется nmacs
.hx
.t0
С О П Р О В О Ж Д Е Н И Е    Б А З   Д А Н Н Ы Х
В    \*(SU
.t1
.ds FE 'СОПРОВОЖДЕНИЕ БАЗ ДАННЫХ В СУБД \*(RU''Стр. %'
.sp 3
.sh 1
ВВЕДЕНИЕ
.sp
В этой статье мы описываем как создавать, структурировать и
поддерживать отношения в \*(RU.
Мы предполагаем, что пользователь знаком с \*(RU,
понимает QUEL - язык запросов \*(RU.
Настоятельно вам советуем для начала прочитать и попробовать на практике
документ
"Учебное введение в \*(RU", и иметь при себе
"Справочное руководство по СУБД \*(RU".
.sp 1
Настоящий документ разделен на шесть разделов.
.in +5
.sp 1
1.  Введение
.sp 1
2.  Создание отношения
.sp 1
3.  Использование команды copy
.sp 1
4.  Структуры памяти
.sp 1
5.  Вторичная индексация
.sp 1
6.  Восстановление и изменение данных
.in -5
.sp 1
Для создания новых данных вы должны быть пользователем
\*(RU и иметь разрешение на
создание базы данных.
Это разрешение дает вам
ingres-суперпользователь.
При выполнении этих двух требований вы можете создавать
базу данных с использованием команды командного языка SHELL
операционной системы \*(DM:
.sp 1
% creatdb mydata
.sp 1
где "mydata" - это имя создаваемой базы данных
(если вы хотите разместить новую базу в своем справочнике, отличном
от стандартного справочника \*(RU, в команде creatdb добавится еще
параметр "-dполное_имя_справочника", подробнее см. раздел "creatdb(\*(dM)"
в справочном руководстве по \*(RU).
Вы становитесь т.н. "администратором базы данных"
("data base administrator" - DBA) для базы данных
mydata.
И уже как DBA, вы имеете некоторые специальные полномочия.

.in +4
.ti -5
1.  Доступ ко всем отношениям базы данных
"mydata" может осуществляться другими пользователями не иначе, как
из нее самой.
Если какой-либо пользователь создает отношение,
оно принадлежит только ему,
и доступ к отношению не имеет права менять
ни DBA, ни любой другой пользователь.

.ti -5
2.  В \*(RU и при печати вы можете использовать ключ "-u".
При этом обеспечивается возможность одновременного использования
базы данных "mydata" совместно с другими пользователями.
Отсылаем вас к руководству пользователя \*(RU к разделам
\*(rN(\*(dM) и users(files) для более детального изучения.

.ti -5
3.  Вы имеете право запускать команды
sysmod, restore и purge на базе данных  "mydata".

.ti -5
4.  По умолчанию база данных создается с возможностью использования
ее в многопользовательском режиме.
Если в каждый момент времени с ней хочет работать
только один пользователь,
администратор базы данных должен отключить управление одновременной
работой пользователей.
Смотрите статью creatdb(\*(dM) в
руководстве пользователя \*(RU.
.in -4
.sp 1
Если база данных была создана, вы можете сразу же запустить команду
.sp 1
% sysmod mydata
.sp 1
Эта программа преобразовывает системные отношения в
структуру, которая обеспечивает наилучшее использование
\*(RU.
sysmod будет рассматриваться подробнее в разделе 4.
.sp 1
Будучи как DBA, так и обычным пользователем, вы
можете создавать и структурировать новые отношения в тех базах
данных, в которых вам это разрешено.
В оставшейся части этого документа мы опишем как это делается.
.bp
.sh 1
СОЗДАНИЕ НОВЫХ ОТНОШЕНИЙ В \*(RU
.sp 4
Существует два пути для создания отношений в \*(RU.
.sp 1
.ti +5
create
.br
.ti +5
retrieve into
.sp 1
"Retrieve into" испольуется для формирования
нового отношения из одного или более существующих отношений.
"Create" используется для создания нового отношения, в котором нет кортежей.
.sp 1
пример 1:
.sp 1
.ti +5
range of p is parts
.ti +5
range of s is supply
.ti +5
retrieve into newsupply(
.ti +19
number = s.snum,
.ti +19
p.pname,
.ti +19
s.shipdate)
.ti +5
where s.pnum = p.pnum
.sp 1
пример 2:
.sp 1
.ti +5
create newsupply(
.ti +12
number = i2,
.ti +12
pname = c20,
.ti +12
shipdate = c8)
.sp 1
В примере 1 \*(RU создает новое отношение,
которое называется
"newsupply", считая, что формат каждого домена известен.
Запрос на создание будет выполнен и отношение будет модифицировано
в структуру "cheapsort".
(Это будет описано более детально в разделе 4).
.sp 1
В примере 2 создается отношение "newsupply",
когда дается имя и формат каждого домена.
Разрешенные форматы это:
.sp 1
.nf
i1             1  байтовое целое
i2             2   "      "
i4     один блок.
.fi
.sp 1
Отношения делятся на страницы по 512 байт.
\*(RU никогда не размещает кортеж между двумя страницами.
Поэтому всегда остается свободное место.
На странице размещаются заголовок в 12 байт плюс
2 байта вспомогательной информации на каждый кортеж на странице.
Формула:
.sp 1
number tuples per page = 500/(tuple width + 2)
.sp 1
wasted space = 500 - number of tuples per page
.ti +1
*(tuple width +2)
.sp 1
В нашем примере это будет так:
.sp 1
22 = 500/(20 + 2)
.sp 1
16 = 500 - 22 * (20 + 2)
.sp 1
22 кортежа на страницу и 16 байт остается незаполненными на
каждой странице.
Такой подсчет верен только для несжатых отношений.
Мы еще вернемся к этому предмету в разделе 4, когда будем обсуждать сжатие.
.sp 1
Если вы забыли имя домена или его формат, используйте команду
"help".
Например, если вы дадите команду
\*(RU:
.sp 1
.ti +5
help newsupply
.sp 1
будет напечатано следующее:
.nf

Отношение:              newsupply
Владелец:               bob
Ширина кортежа:         30
Сохранять до:           Thu Nov 10 16:17:06 1977
Число кортежей:         0
структура пмяти:        paged heap
Тип отношения:          user relation

 имя атрибута      тип   длина    ключ.

 number             i       2
 pname              c      20
 shipdate           c       8

.fi
Отметим, что каждое отношение имеет свое время хранения в системе.
По умолчанию оно устанавливается равным одной неделе
с момента создания.
Команда "save" может быть использована для увеличения времени хранения.
См. "save(quel)" и "purge(\*(dM)" в руководстве пользователя
\*(RU.

.bp
.sh 1
КОПИРОВАНИЕ ДАННЫХ ИЗ/В \*(RU
.sp 4
Если отношение создано, существует два механизма
для занесения новых данных:
.sp
.in +5
команда append
.br
команда copy
.in -5
.sp
append  используется для занесения одного кортежа за одно обращение,
или для заполнения одного отношения из других отношений.
.sp
copy используется для копирования данных из файла \*(DM
в отношение.
Она используется для копирования данных из каких-либо программ,
или для копирования данных из других систем.
А также является наилучшим путем для копирования некоторых данных,
содержащих более одного кортежа.
.sp
давайте начнем с создания простого отношения
и поместим в него данные.
.sp
Пример:
.sp
.nf
create donation (name = c10, amount = f4, ext = i2)
.sp
.fi
Теперь предположим, что мы  хотим занести в отношение записи
о двух людях.
Простейшей процедурой, вероятно, является запуск двух запросов
в \*(RU с использованием команды
append.
.sp
.nf
append to donation (name="frank",amount = 5,
		    ext = 204)
.sp 1
append to donation (name="harry",ext = 209,
		    amount = 4.50)
.fi
.sp
Заметим, что порядок укзания имен доменов не существенен.
\*(RU находит указанные имена атрибутов и не обращает внимания
на порядок их следования в списке.
Теперь отношение "donation"
выглядит следующим образом:
.nf

donation relation

|name      |amount    |ext   |
|----------------------------|
|frank     |5.000     |204   |
|harry     |4.500     |209   |
|----------------------------|
.fi
.sp
Теперь у нас в отношении
donation введены два человека.
Предположим, мы должны ввести еще 50 человек.
Используя команду
append, такая задача становится слишком утомительной, т.к.
для каждого кортежа приходится слишком много печатать.
Команда copy в данном случае больше подходит для решения нашей задачи.
.sp
Copy способна взять данные из обычного файла \*(DM
в различных форматах и добавить их к отношению.
Для использования команды
copy сначала создается файл \*(DM (например с использованием редактора
"ed"), содержащий нужные данные.
.sp
Например, давайте поместим пять новых имен в файл, используя редактор.
.sp
.nf
.tr Z.
% ed
a
bill,3.50,302
sam,10.00,410
susan,,100
sally,.5,305
george,4.00,302
Z
w newdom
68
q
%
.tr ZZ
.sp
.fi
Формат вышеуказанного файла следующий:
сначала имя, за которым следует запятая, за ним следует
размер вклада, запятая, затем расширение и в конце символ новой строки.
Пустое значение заносится, например размер вклада (amount) у
susan, указанием нуля для домена числового типа и указанием пробела
для домена символьного типа.
.sp
Для использования copy мы входим
в \*(RU и подаем команду:
.sp
.in +5
.nf
copy donation (name = c0, amount = c0, ext = c0)
	from "/mnt/bob/newdom"
.fi
.sp
.in -5
Таким образом, как работает команда copy:
.sp
.ti +5
copy relname (list of what to copy) from\ "full\ pathname"
.sp
Для вышеприведенного случая мы запишем:
.sp
.ti +5
copy donation (. . .) from "/mnt/bob/newdom"
.sp
Домены
amount и ext хранятся в отношении как
f4 (вещественное с плавающей точкой) и
и i2 (целое), а в файле \*(DM
они представлены, как символьные данные.
В указанном формате домена
copy  получает:
.sp
.ti +5
домен = формат
.sp
где домен - это имя домена и формат - это формат в файле \*(DM
один из:
.sp
.nf
i1, i2, i4         (целое, размером 1, 2, или 4)
.br
f4, f8             (вещественное с плавающей точкой,
		    размером 4 или 8)
.br
c1, c2, c3,...c255 (символьная строка
		    фиксированной длины)
.br
c0                 (символьная строка переменования
		    данных из каких-либо программ
		    или для копирования данных из
		    других систем.  Это также
		    является наилучшим путем для
		    копирования некоторых данных,
		    содержащих более одного кортежа.
.fi
.sp
Давайте начнем с создания простого отношения
и поместим в него данные.
.sp
Пример:
.sp
.nf
create donation (name = c10, amount = f4,
		 ext = i2)
.sp
.fi
В примере мы используем
.sp
.ti +5
name = c0, amount = c0, extension = c0
.sp
Значения каждого домена нашего отношения хранились в файле
\*(DM как символьные строки переменной длины.
Copy рассматривает первую запятую, символ табуляции или новой строки,
как конец строки данных.
copy преимущественно используется при первоначальном занесении
данных в отношение.
.sp
copy также может быть использована для копирования
данных из отношения в файл \*(DM.
Например:
.sp
.nf
copy donation (name = c10, amount = c10,
     ext = c5) into "/mnt/bob/data"
.fi
.sp
В этом случае будет происходить следующее:
.in +4
.ti -5
.sp 1
1.  Если файл /mnt/bob/data уже существовал, он будет уничтожен.
.ti -5
.sp 1
2.  файл создается с кодами доступа 600 (чтение/запись только владельцу)
.sp 1
.ti -5
3.  Имя будет копироваться как 10-символьное поле,
за которым сразу же следует поле атрибута amount,
за которой сразу же следует поле атрибута ext.
Значение атрибута amount будет преобразовываться в
символьное поле шириной 10 символов.
Значение атрибута ext будет преобразовываться в
символьное поле шириной 5 символов.
.in -4
.sp 1
Файл "/mnt/bob/data"
будет набором символов, выглядящим приблизительно так:

.tr Z
.nf
frankZZZZZZZ5.000ZZ204harryZZZZZZ4.500ZZ209
billZZZZZZZZ3.500ZZ302samZZZZZZZ10.000ZZ410
susanZZZZZZZ0.000ZZ100sallyZZZZZZ0.500ZZ305
georgeZZZZZZ4.000ZZ302
.fi
.tr ZZ

.sp
Вывод будет разбит на четыре строки для удобного размещения на
этой странице.
В настоящее время файл это просто строка.
Другой пример:
.sp
.nf
copy (name = c0, colon = d1, ext = c0,
      comma = d1, amt = c0, nl = d1)
into "/mnt/bob/data"
.fi
.sp
В этом примере
"c0" интерпретируется как "используется подходящий символьный формат".
Для символьных доменов это есть ширина поля домена.
Домены численного типа преобразуются в символьные
в соответствии с принятыми умолчаниями \*(RU.
.sp
Операторы:
.sp
.in +5
двоеточие = d1
.br
запятая = d1
.br
символ новой строки = d1
.in -5
.sp
используются для вставки одного двоеточия, одной запятой
и одного символа перевода каретки в файл.
Формат "d1" интерпретируется как один фиктивный символ.
При копировании в файл \*(DM, выбираемое множество символов может
быть подставлено в файл с использованием спецификации
"фиктивный домен".
Таким образом, файл "/mnt/bob/data" будет выглядеть:

.nf
frank     :   204,     5.000
harry     :   209,     4.500
bill      :   302,     3.500
sam       :   410,    10.000
susan     :   100,     0.000
sally     :   305,     0.500
george    :   302,     4.000

.fi
.sp
Если вы хотите получить файла с двоичным представлением
чисел, вы должны использовать:
.sp
.ti +5
copy (name = c10, amount = f4, ext = i2)
.sp
При этом будет создаваться файл с точной
копией каждого кортежа, следующей одна за другой.
Это очень часто нужно для целей временного хранения,
при этом гарантируется точное значение доменов типа
вещественных с плавающей точкой.
.sp 2
ТИПИЧНЫЕ ОШИБКИ
.sp 1
Имеется 17 различных ошибок, которые возникают
при использовании команды copy.
Сейчас мы обсудим наиболее общие из них.
.sp 1
Предположим, что у нас есть файл:
.sp 1
bill,3.5,302
.br
sam,10,410,
.br
susan,3,100
.sp 1
и мы запускаем команду copy
.sp 1
.nf
copy donation (name = c0, amount = c0,
	       ext = c0)
     from "/mnt/bob/data"
.fi
.sp 1
Вы получите сообщение об ошибке
.sp 1
.nf
5809: COPY: плохая строка на вводе.
Ввод был "susan". Только 2 кортежа
нормально скопировались из
/mnt/bob/data в отношение donation.
.fi
.sp 1
Произошло это из-за того, чо во второй строке
была лишняя запятая.
Первые два кортежа скопировались правильно.
Для следующего кортежа получили:
name = "" (пробел), amount = "susan", and ext = "3".
Однако, "susan" не вещественное  с плавающей точкой,
произошла ошибка и выполнение прекратилось после копирования двух
кортежей.
.sp 1
Если вы пытаетесь скопировать файл, такой как
.sp 1
nancy,5.0,35000
.sp 1
вы также получите диагностическое сообщение
.sp 1
.nf
5809: COPY: плохая строка на вводе для домена ext.
Было введено "35000". При этом ни одного кортежа
не будет скопировано в отношение donation из
/mnt/bob/data.
.fi
.sp 1
Таким образом, т.к. ext является целым доменом
i2,
он не может принимать значение больше чем 32767.
.sp 1
Существуют также еще другие диагностические сообщения,
большинство из них самоочевидны.
.sp 1
Кроме того, существуют три необязательных замечания,
которые могут возникать при копировании "из".
.sp 1
Если вы производите копирование из файла в отношение,
которое имеет структуру
ISAM или хэшировано, появится счетчик числа повторяющихся
кортежей (если таковые имеются).
Такая ситуация не возникает при структуре
"куча" т.к. не применяется проверка на повторяющиеся кортежи.
.sp 1
В \*(RU не разрешено хранить управляющие символы
(такие, как например звонок "CTRL/G", и т.п.)
Если copy читает управляющие символы, он преобразовывает их
в пробелы и сообщает число доменов в которых они
встретились.
.sp 1
Если вы при копировании используете опцию c0,
copy будет выдавать сообщение, если некоторая строка символов
окажется длиннее, чем длина домена, и усекать длину вводимой строки.
.sp 2
СПЕЦИАЛЬНЫЕ ОСОБЕННОСТИ
.sp 1
.ti +3
Существует несколько специальных функций, которые позволяют
осуществлять копирование немного более простым способом
.sp 1
.nr in 6n
.ti -4
1.  Оптовое копирование
.sp 1
Если вы спросите:
.sp 1
.ti +4
copy relname () from "file"
.ti +8
или
.ti +4
copy relname () into "file"
.sp 1
copy будет рассматривать этот оператор следующим образом:
.sp 1
.in +5
копировать каждый домен в их естественном порядке в соотвветствии
с их правильным форматом.
.sp 1
.in -5
Так же, если вы скажете
.sp 1
.ti +4
copy donation () into "/mnt/bob/donation"
.sp 1
это будет то же самое, как если бы вы спросили:
.sp 1
.nf
copy donation (name = c10, amount = f4,
		ext = i2)
     into "/mnt/bob/donation"
.fi
.sp 1
Это обеспечивает более удобный путь для копирования отношения
целиком и полностью из \*(RU.
.sp 1
.ti -4
2.  Фиктивные домены
.sp 1
Если вы копируете данные с другой машины или из программы,
часто бывает так, что нужно некторые данные пропустить.
Это можно сделать, используя фиктивный домен, определенный по форматам:
d0, d1, d2 ... d511.
Например:
.sp 1
.ti +4
.nf
copy rel (dom1 = c5, dummy = d2, dom2 = i4,
	dumb = d0) from "/mnt/me/data"
.fi
.sp 1
Первые 5 символов помещаются в
dom1, следующие 2 символа игнорируются.
Следующие 4 байта являются целым типа i4 и помещаются в
dom2, оставшийся раделитель строки игнорируется.
Имя, данное фиктивному спецификатору, игнорируется.
.sp 1
Как упоминалось выше, фиктивные домены могут использоваться при
копировании в файл \*(DM для вставки специальных символов.
Список зарезервированных имен включает:
.sp 1
.in +5
.nf
nl        символ новой строки
tab       символ табуляции
sp        свободное место
nul       нулевой байт
null      нулевой байт
comma     ,
dash      -
colon     :
lparen    (
rparen    )
.fi
.in -5
.sp 1
.ti -4
3.  Усечение
.sp 1
Не совсе ясно, что делать в случаях возниконовения
такой ошибки, и как правило, приходится начинать сначала.
Простейшиj путь решить это, "усекать" отношение.
Это делается командой:
.sp 1
.ti +4
modify relname to truncated
.sp 1
Происходит эффект удаления всех кортежей в отношении relname,
освобождения дискового пространства, и создания вновь
отношения relname
со структурой хранения "куча".
Т.е. логический эквивалент разрушения с последующим созданием
(но с немного меньшими ограничениями на типы).
.sp 1
Однако и при таких действиях возможны форматные ошибки
при копировании,
т.е. это не является основным удачным приемом для
копирования данных в отношение, которое уже содержит
правильный набор данных.
Наилучшим способом является создание временного отношения с такими же
доменами, как и в существующем отношении.
Данные копируются во временное отношение и добавляются в
реальное отношение.
Например:

.nf
create tempdom(name=c10,amount=f4,ext=i2)

copy tempdom(name=c0,amount=c0,ext=c0)
from "/mnt/bob/data"

range of td is tempdom
append to donation(td.all)
.fi
.sp 1
4.  Определяемые разделители
.sp 1
Иногда желательно определить разделительные символы,
используемые при копировании из файла.
Это может быть сделано определением:

.ti +8
домен = c0delim

где "delim" это разрешенный разделитель,
взятый из списка резервированных имен.
Этот список был полностью приведен на предыдущей странице.
.sp 1
.bp
.sh 1
СТРУКТУРЫ ПАМЯТИ
.sp 4
Займемся обсуждением эффективности.
Если вы уже создали отношение и поместили в него данные
с помощью copy или append,
\*(RU может выполнить некоторый запрос на отношении.
Существует много способов с помощью которых вы
можете достигнуть ускорения выполнения запроса.
.sp
\*(RU может хранить отношение в трех различных внутренних структурах.
Они называются "heap"(куча), "isam"(индексно-последовательная),
"hash"(хэшированная).
Для начала, мы коротко опишем каждую структуру, а позднее
расширим нашу дискуссию.
.sp
HEAP(КУЧА)
.sp 1
При первоначальном создании отношения, оно создается как "куча".
Существуют две важных особенности структуры "heap":
дублирующиеся кортежи не уничтожаются,
ничего не известно о расположении кортежей.
если вы запустили запрос:
.sp 1
.ti +5
range of d is donation
.br
.ti +5
retrieve (d.amount) where d.name = "bill"
.sp 1
\*(RU будет читать каждый кортеж в отношении, просматривая его
на предмет поиска имени
"bill".
Если отношение небольшое - это не имеет серьезного значения.
Но если отношение очень большое, это займет минуты (или даже часы!).
.sp 1
HASH(ХЭШИРОВАННАЯ)
.sp 1
Хэш-структура отношения дает возможность ускорения поиска
по указанным доменам.
(Такие домены обычно называются "ключевыми").
Кроме того, хэшированное отношение не содержит дублирующихся
кортежей.
Наример, предположим, что отношение
donation хранится хэшированным по
домену "name".
Тогда запрос:
.sp 1
.ti +5
retrieve (d.amount) where d.name = "bill"
.sp 1
будет выполняться быстро, т.к.
\*(RU приблизительно знает, где на диске хранятся
нужный кортеж.
На отношении, в котором только несколько кортежей, вы не заметите
разницы между структурами
"heap" и "hash".
Но как только отношение увеличивается, разница становится
все более и более заметна.
.sp 1
ISAM(индексно-последовательная)
.sp 1
Структура isam единственная, при которой отношение сортируется по
одному или более доменам,
(также называемым "ключевыми").
В "isam отношениях" тоже нет дублирующихся кортежей.
Когда добавляются новые кортежи,
они помещаются "приблизительно" в свою отсортированную позицию в
отношении.
("Приблизительность" будет объяснена чуть-чуть позднее).
.sp 1
Предположим, что отношение donation имеет структуру
isam по домену name.
Выполним запрос
.sp 1
.ti +5
retrieve (d.amount) where d.name = "bill"
.sp 1
\*(RU будет определять, где в отсортированном порядке
должно быть имя "bill", и читает только
только ту часть отношения.
.sp 1
Т.к. отношение приблизительно отсортировано,
структура isam будет эффективна и для выполнения такого запроса:
.ti +5
.sp 1
retrieve (d.amount) where d.name >= "b" and d.name < "g"
.sp 1
Такой запрос будет выбирать все имена, начинающиеся
с букв от "b" до "f".
Отношение не будет просматриваться полностью, т.к.
оно упорядочено по именам.
.sp 2
ВЫБОР СТРУКТУР ПАМЯТИ
.sp
Некоторые пользователи, создавшие отношение, могут
изменить его структуру, используя команду
"modify".
Например
.sp
.ti 5
modify donation to hash on name
.br
или
.br
.ti 5
modify donation to isam on name
.sp
или еще
.sp
.ti 5
modify donation to heap
.sp 2
ПЕРВИЧНЫЕ СТРАНИЦЫ И СТРАНИЦЫ ПЕРЕПОЛНЕНИЯ
.sp
На этом этапе необходимо ввести понятие первичных страниц
и страниц переполнения в структурах "hash" и "isam".
Обе эти структуры пользуются соответствием указанного кортежа
указанной странице отношения, основанном на ключевых доменах
кортежа.
Так, каждая страница содержит только определенное подмножество
кортежей отношения.

Когда добавляется новый кортеж в отношение структуры
"hash" или "isam",
\*(RU сначала определяет, какой странице он предназначен,
затем просматривает место на этой странице.
Если там есть место, то кортеж помещается на эту страницу.
Если места нет, то создается "страница переполнения" и
кортеж помещается на нее.

Страница переполнения связывается с исходной страницей.
Исходная страница называется "первичной".
Если заполняется страница переполнения,
то \*(RU будет связывать следующую страницу уже с ней.
Тем самым, мы получим одну первичную страницу,
связанную со страницей переполнения,
связанную, в свою очередь, с другой страницей переполнения.
Страницы переполнения при необходимости динамически создаются.
.sp 2
ОПРЕДЕЛЕНИЕ СВОБОДНОГО МЕСТА
.sp
Команда modify также позволяет вам определить, как
много места будет необходимо отношению по мере его роста.
Как было упомянуто в описании команды "create",
отношение делится на страницы.
"fillfactor" может быть использован для указания как
заполнять каждую первичную страницу.
Это решение будет основываться только на
том, будут ли добавляться еще кортежи к отношению.
Например:
.sp
.nf
modify donation to isam on name where
       fillfactor = 100
.fi
.sp
Этим мы сообщаем команде modify, что каждую страницу
нужно заполнять полностью, насколько это возможно.
.sp
.nf
modify donation to isam on name where
       fillfactor = 25
.fi
.sp
Этот запрос обеспечит заполнение каждой страницы только на 25%,
другими словами, оставит 75% пустого места.
Это мы будем делать, если мы имеем грубо говоря 1/4
заполненных данных и хотим по мере возможности
распределять данные по алфавиту и в дальнейшем.
.sp
Запомните, что если вы не определите fillfactor,
то \*(RU будет осуществлять самый подходящий выбор по умолчанию.
Также, когда страница переполняется, \*(RU
автоматически создает "страницу переполнения",
т.к. не бывает случая, при котором отношение не
способно бы было расширяться.
.sp
Когда отношение модифицируется в хэш-структуру,
должен быть указан добавочный параметр
"minpages" (минимальное количество страниц).
мodify будет гарантировать, что  для
отношения будет выделено
"minpage" следующих
первичных страниц.
.sp
modify подсчитывает сколько первичных страниц будет
необходимо для хранения существующих кортежей по
указанному параметру fillfactor, предполагая, что
не возникнет необходимости выделять страницы переполнения.
Если это число меньше, чем
minpages, то вместо него используется
minpages.
.sp
Например:
.sp
.nf
modify donation to hash on name where
       fillfactor = 50, minpages = 1
.sp 1
modify donation to hash on name where
       minpages = 150
.fi
.sp
В первом случае мы гарантируем, что не будет больше страниц,
чем необходимо для 50% заполнения.
Второй случай это типичный пример модификации пустых или почти пустых
отношений.
Если заранее
известен приблизительный максимальный размер,
minpages может быть использован для гарантии, что
отношение будет иметь свой предполагаемый максимальный размер.
.sp
Есть еще одна опция, употребляемая в хэшированном отношении,
называемая "maxpages".
Ее синтаксис аналогичен minpages.
Она может быть использована для определения максимально
используемого числа первичных страниц.
.sp
СЖАТИЕ
.sp 1
Три структуры памяти
(heap, hash, isam) также могут
использоваться в свей "сжатой" модификации.
Для этого обратитесь к структурам памяти
cheap("сжатая куча"), chash("сжатая хэш") и
cisam("сжатая индексно-последовательная").
Сжатие уменьшает размер области, необходимой для
внутреннего представления каждого кортежа.
Существующий алгоритм сжатия - это подавление
хвостовых пробелов в символьных доменах.
Использование сжатия не требует дополнительного пространства,
экономит дисковое пространство и улучшает применение.
Приведем пример:
.sp 1
.nf
modify donation to cisam on name where
       fillfactor = 100
.fi
.sp 1
С помощью этого запроса отношение
donation модифицируется в структуру "сжатая isam" с
требованием заполнения страниц настолько, насколько это возможно.
При сжатии каждый кортеж может иметь различную длину.
Так число кортежей, которые могут быть расположены на
одной странице будет зависеть от того,
насколько успешно они были сжаты.
Для обновления сжатых отношений могут потребоваться большие расходы.
В частности, если происходит замена
содержимого одного или более доменов, и сжатый кортеж не
длиннее прежней длины,
то \*(RU должен искать новое  место для размещения кортежа.
.sp 2
ДВЕ ВАРИАЦИИ НА ТЕМУ
.sp
Как было замечено, дублирующиеся кортежи не уничтожаются
в отношениях, у которых структура - куча.
Часто желательно удалять повторения и сортировать отношение,
хранимое как куча.
Один путь, реализующий это - модификация отношения в структуру
isam, с определением желаемого порядка сортировки.
Альтернативой этому является использование
"heapsort" или "cheapsort".
Например:
.sp 1
modify donation to heapsort on name, ext
.sp 1
Такая команда обеспечивает сортировку отношения сначала
по домену name, затем по домену ext.
Дальнейшая сортировка кортежей происходит по
оставшимся доменам, в порядке их указания в операторе
create.
Так, в данном случае, отношение будет сортироваться по
значению домена name, затем ext и затем amount.
Дублирующиеся кортежи всегда удаляются.
Отношение было получено из структуры куча.
Heapsort и cheapsort получаются сортировкой временного отношения перед
его печатью и уничтожением.
Это еще более эффективно, чем структура
isam потому, что вместе с такой структурой
\*(RU создает "каталог", содержащий ключевую
информацию о каждой странице.
Отношение НЕ сохраняет порядок сортировки при дальнейших изменениях.
.sp
Пример:
.sp
.nr in 2n
Здесь приводится набор примеров и пояснений,
как эффективно использовать каждый запрос.
Запросы основываются на отношениях:
.(l
parts(pnum, pname, color, weight, qoh)
.br
supply(snum, pnum, jnum, shipdate, quan)
.sp 1
range of p is parts
.br
range of s is supply
.sp 1
modify parts to hash on pnum
.br
modify supply to hash on snum,jnum
.)l
.ti +5
.sp 1
retrieve (p.all) where p.pnum = 10
.sp 1
\*(RU будет
распознавать, что отношение parts является хэшированным
по домену pnum, и обращаться точно к той странице, где хранится
часть с номером 10.
.sp 1
.ti +5
retrieve (p.all) where p.pname = "tape drive"
.sp 1
\*(RU будет читать все отношение, разыскивая подходящие имена pnames.
.sp 1
.ti +5
retrieve (p.all) where p.pnum < 10  and p.pnum > 5
.sp 1
\*(RU будет читать все отношение, потому что
не задано точное значение pnum.
.sp 1
.ti +5
retrieve (s.shipdate) where s.snum = 471 and s.jnum = 1008
.sp 1
\*(RU будет распознавать, что отношение supply хэшированное по
комбинации доменов
snum и jnum, и переходить на верную страницу.
.ti +5
.sp 1
retrieve (s.shipdate) where s.snum = 471
.sp 1
\*(RU будет читать все отношение.
supply хэшировано по доменам
snum и jnum.
Бесполезно задавать \*(RU уникальные значения обоих доменов,
это не имеет преимуществ при использованной структуре памяти.
, что
не задано точное значение pnum.
.sp 1
.ti +5
retrieve (s.shipdate) where s.snum = 471 and s.jnum = 1008
.sp 1
\*(RU будет распознавать, что отношение supply хэшированное по
комбинации доменов
snum и jnum, и переходить на верную страницу.
.ti +5
.sp 1
retrieve (s.shipdate) where s.snum = 471
.sp 1
\*(RU будет читать указанное отношение.
supply хэшировано по доменам
snum и jnum.
Если не задано уникальное значение одного из  ключевых доменов,
то невозмаожно воспользоваться преимуществами
использованной структуры памяти.
.sp 1
.ti +5
retrieve (s.shipdate) where s.snum = 471 and s.jnum = 1008
.sp 1
\*(RU будет распознавать, что отношение supply хэшированное по
комбинации доменов
snum и jnum, и переходить на верную страницу.
.sp 1
.ti +5
retrieve (p.pname, s.shipdate) where
.ti +5
.br
p.pnum = s.pnum and s.snum = 471 and s.jnum = 1008
.sp 1
\*(RU будет использовать преимущества обеих структур памяти.
Сначала она найдет все домены
s.pnum и s.shipdate, где
s.snum = 471 и
s.jnum = 1008.
Потом будет просматривать все домены
p.pname, такие где p.pnum принимает значения, заданные условием.
.sp 1
Этот пример иллюстрирует ту идею, что
часто мысль хэшировать отношение по доменам является удачной,
когда нужно "объединять" его с другим отношением.
Например, в таком случае обычно спрашивают:
for p.pnum = s.pnum
.sp 1
Подведем итог:
.sp 1
Для использования преимущества хэш-структуры
\*(RU должен иметь точное значение для каждого
ключевого домена.
Точное значение всегда подобно:
.ti +5
.sp 1
s.snum = 471
.br
.ti +5
s.pnum = p.pnum
.sp 1
А не:
.sp 1
.ti +5
s.snum >= 471
.br
.ti +5
(s.snum = 10 or s.snum = 20)
.sp 1
Теперь давайте рассмотрим некоторые
случаи использования структуры isam
.sp 1
.in +5
modify supply to isam on snum,shipdate
.br
retrieve (s.all) where s.snum = 471
.br
and s.shipdate > "75-12-31"
.br
and s.shipdate < "77-01-01"
.sp 1
.in -5
Если supply сначала отсортировывается
по домену snum, а затем по домену
shipdate, \*(RU может воспользоваться всеми преимуществами
структуры isam
для размещения частей отношения supply, которые
удовлетворяют запросу.
.sp 1
.ti +5
retrieve (s.all) where s.snum = 47l
.sp 1
в отличие от хэш-структуры, структура
isam остается удобной для использования тогда, когда
задан только один ключ.
.sp 1
.ti +5
retrieve (s.all) where s.snum > 400 and s.snum < 500
.sp 1
Снова \*(RU будет использовать преимущества структуры.
.sp 1
.ti +5
retrieve (s.all) where s.shipdate >= "75-12-31" and
.ti +5
s.shipdate <= "77-01-01"
.sp 1
Здесь \*(RU будет читать полностью заданное отношение.
Это потому, что первый ключ (snum) не задан в запросе.
.sp 1
Подведем итог:
.sp 1
isam может обеспечивать улучшение доступа как
при точных значениях, так и на значениях, заданных неравенствами.
Это полезно, по крайней мере, до тех пор, пока указан первый ключ.
.sp 1
Для распределения кортежей в отношении структуры isam
\*(RU ищет справочник isam для отношения.
Когда отношение модифицируется в структуру isam,
кортежи сначала сортируются, и дублирующиеся кортежи удаляются.
Затем отношение заполняется (в соответствии со значением
fillfactor), начиная со страниц
 0, 1, 2... и т.д. пока есть в них необходимость.
.sp 1
Сейчас такой справочник построен.
Ключевой домен от первого кортежа на каждой странице
выбран и помещен в справочник (хранится в отношении на диске).
Справочник не меняется пока не произойдет следующая модификация.
.sp 1
Всякий раз, когда кортеж добавляется к отношению,
справочник просматривается для поиска
страницы, которой предназначен новый кортеж.
На этой странице кортежи перестают сохранять порядок сортировки.
Остается что-то "приблизительно" отсортированное.
.sp 2
.nr in 0
HEAP v. HASH v. ISAM
.sp 1
Давайте сравним относительные преимущества и недостатки
каждой структуры.
Отношение всегда создается как куча (heap).
Куча является наиболее эффективной структурой для
первоначального заполнения отношения, с использованием команд
copy или append.
.sp 1
Свободное место от удаленных кортежей в куче
будет заново использоваться только на следующей странице.
Проверка наличия дублирующихся кортежей не
происходит в отношении структуры heap.
.sp 1
Хэш-структура наиболее удобна для размещения кортежей
выбираемых по точным значениям квалификаторов.
Первичные страницы для кортежей с указанным значением
могут быть легко подсчитаны.
.sp 1
Структура isam удобна и для точных значений и для
диапазона значений.
Но при такой структуре должен просматриваться справочник,
что не так эффективно, как при хэш-структуре.
.sp 2
СТРАНИЦЫ ПЕРЕПОЛНЕНИЯ
.sp 1
Когда вставляется новый кортеж в отношение, а на первичной странице
нет для него места, то создается страница переполнения.
Если больше кортежей подлежит втавке в отношение,
то страницы переполнения добавляются по мере необходимости.
Страницы переполнения, если необходимо, ускоряют выполнения
выборок и измения отношений.
.sp 1
Например, давайте предположим, что supply
хэшировано по домену snum и имеет 10 первичных страниц.
Предположим, что значение snum = 3 расположено на странице 7.
Для поиска всех snum = 3
требуется, чтобы \*(RU просмотрел 7 первичную страницу и
все ее страницы переполнения (если они есть).
Если добавлено много страниц переполнения, то
время, необходимое для поиска snum = 3 возрастает.
Так как удаляются дублирующиеся кортежи в структурах isam и hash,
этот поиск должен применяться и при добавлении, и при замене
кортежей.
.sp 1
Когда у отношения, структурированного как hash или isam,
есть много страниц переполнения, оно должно быть модифицировано заново
в hash или isam.
Это будет очищать отношение и ликвидировать как можно большее
число страниц переполнения.
.sp 2
УНИКАЛЬНЫЕ КЛЮЧИ
.sp 1
Когда выбираются ключевые домены для отношения,
желательно иметь каждое множество ключевых доменов
уникальным, насколько это возможно.
Например, служащий характеризуется
несколькими, обычно неповторяющимися значениями,
т.к. что-то, похожее на цвет, имеет только несколько различных значений,
а что-то, похожее на пол, имеет, как мы знаем, только два значения.
.sp 1
Если отношение хэшировано по домену sex, то вы можете ожидать,
что все мужчины будут размещены на одной первичной странице и всех ее
страницах переполнения, и
аналогичная ситуация произойдет для всех женщин.
Для хэшированного отношения нет решения этой проблемы.
Обмен должен производиться между наиболее желательными
ключевыми доменами для использования в квалификации,
противоположной уникальности ключевых значений.
.sp 1
Однако, структура isam может быть использована, если
пропускается первый указанный ключ, а выбранные ключевые
домены иногда добавляются для увеличения уникальности.
Например, предположим, что отношение supply
имеет только 10 уникальных номеров поставщиков,
но в тысячах кортежей.
Выбор структуры isam с ключами snum и jnum будет, вероятно,
давать много больше уникальных ключей.
Однако, размер справочника будет больше и,
следовательно, будет возрастать время его просмотра.
Когда указываются дополнительные ключи только
ради увеличения уникальности,
пытайтесь использовать по возможности наименьшее число доменов.
.sp 2
СИСТЕМНЫЕ ОТНОШЕНИЯ
.sp 1
\*(RU использует три отношения
("relation", "attribute" и "indexes") для поддержки
организации базы данных.
Отношение "relation" содержит один кортеж для каждого отношения
в базе данных.
Отношение "attribute" содержит один кортеж для каждого атрибута
в каждом отношении.
Отношение "indexes" содержит один кортеж для каждого вторичного индекса.
.sp 1
Доступ \*(RU к этим отношениям осуществляется
в очень удобной форме.
Программа, называемая
"sysmod", будет использоваться для модификации этих
отношений в хэш-структуру по соответствующим доменам.
Для использования sysmod администратор базы данных
должен печатать:
.sp 1
% sysmod data-base-name
.sp 1
sysmod первоначально запускается после того, как база данных
создана, и затем, когда созданы отношения и база данных растет.
Недостаточно запустить sysmod один раз и забыть о нем.
Перезапуск sysmod должен происходить тогда,когда
системные отношения будут модифицироваться заново.
Это обычно происходит для удаления большинства страниц переполнения и
уменьшения времени ответа системы.
.bp
.sh 1
ВТОРИЧНАЯ ИНДЕКСАЦИЯ
.sp 4
При использовании структур hash и isam
обеспечивается быстрый путь для поиска кортежей
в отношении по данным значениям ключевых доменов.
Иногда этого недостаточно.
Например, предположим, что у нас есть отношение
donation
.sp 1
.ti +5
donation(name, amount, ext)
.sp 1
хэшированное по домену name.
Это будет обеспечивать ускорение доступа при запросе,
когда квалификация не определяет точного значения домена name.
Что, если мы также будем подавать запросы с заданными точными
значениями домена ext?
.sp 1
donation может быть хэшировано как по name, так и по ext,
так что мы будем иметь выбор, который из них более общий,
и хэшировать отношение по этому домену.
Другой домен (скажем ext) будет иметь вторичный индекс.
Вторичный индекс - это отношение, которое содержит каждый
домен "ext" вместе с точным местоположением кортежа в отношении
donation.
.sp 1
Вот как выглядит команда создания вторичного индекса:
.sp 1
.ti +5
index on donation is donext (ext)
.sp 1
Общим форматом будет:
.sp 1
.ti +5
index on relation_name is secondary_index_name (domains)
.sp 1
Здесь мы запрашиваем
\*(RU на создание вторичного индекса
на отношении donation.
Домен, который будет индексироваться - это "ext".
Индексы формируются за три шага:
.sp 1
.in +4
.ti -5
1.  "Donext" создается как структура куча.
.br
.ti -5
2.  Для каждого кортежа в donation,
кортеж, вставляется в
"donext", со значением ext и точным расположением
соответствующего кортежа в отношении donation.
.br
.ti -5
3. По умолчанию, "donext" модифицируется в isam.
.in -4
.sp 1
Сейчас, если вы запустите запрос:
.sp 1
.ti +5
range of d is donation
.ti +5
retrieve(d.amount) where d.ext = 207
.sp 1
\*(RU сначала будет автоматически искать
в "donext" первое вхождение ext = 207.
Когда он его найдет, он обратится прямо к
кортежу в отношении donation.
Т.к. "donext" имеет структуру isam по домену ext,
поиск
ext = 207 будет происходить быстро.
.sp 1
Если вы запустите запрос
.sp 1
.ti 5
retrieve(d.amount) where d.name = "frank"
.sp 1
то \*(RU будет продолжать использовать хэш-структуру
отношения "donation" для размещения указанных кортежей.
.sp 1
Т.к. вторичные индексы представляют собой отношения,
они тоже могут иметь структуры как
hash, isam, chash так и cisam.
Нельзя почуствовать наличие
вторичного индекса, имеющего структуру куча.
.sp 1
Решение, как какую структуру для них выбирать для
включения тех же предложений, которые обсуждались выше:
.sp 1
Можно ли будет ссылаться на домены указанием его точного значения?
.br
Можно ли будет ссылаться на них указанием диапазона значений?
.br
и т.д.
.sp 1
В этом случае на домен "ext" можно будет ссылаться указанием
его точного значения, и т.к. отношение почти заполнено,
мы будем делать:
.sp 1
.ti +5
modify donext to hash on ext where fillfactor = 100
.ti +5
and minpages = 1
.sp 1
Вторичные индексы обеспечивают возможность \*(RU
для доступа к кортежам, основанного на доменах, не являющихся
ключевыми.
Отношение может иметь все номера вторичных индексов и вдобавок
каждый вторичный индекс может быть индексом на свыше, чем 6 доменах
первичного отношения.
.sp 1
Когда кортеж заменяется, удаляется или добавляется
к первичному отношению, вторичный индекс также соответственно
изменяется.
Таким образом, вторичный индекс не является "свободным".
Это увеличивает затраты на изменение первичного отношения,
но может уменьшать затраты на поиски кортежа в первичном отношении.
.sp 1
Будет ли вторичный индекс улучшать использование
или не строго зависеть от уникальности значений индексированных
доменов.
Первая забота это: будет ли просмотр вторичного индекса
более эффективным, чем простое чтение первичного отношения.
В сущности это важно, если число кортежей,
которые удовлетворяют квалификации, меньше, чем общее число страниц
(как первичных, так и страниц переполнения) в первичном отношении
.sp 1
Например, если нам часто бывает желательно найти всех людей,
которые внесли вклад меньше, чем 5 долларов,
рассмотрим создание вторичного индекса
.sp 1
.ti +5
index on donation is donamount (amount)
.sp 1
По умолчанию
donamount будет иметь структуру isam по amount.
Если \*(RU выполняет запрос:
.sp 1
.ti +5
retrieve(d.name) where d.amount < 5.0
.sp 1
он будет располагать
d.amount < 5.0 во вторичный индекс и для каждого кортежа,
который он находит, будет  создаваться двойник соответстующего
кортежа в отношении donation.
Кортежи в donamount сортируются по
amount, а кортежи в отношении donation нет.
Так в общем случае, каждый кортеж-двойник из
donation, в отличие от
donamount будет на другой странице.
Выборка с использованием вторичного индекса, тем самым, может
читать больше страниц, чем простое последовательное чтение всего
отношения donation!
Таким образом, в данном примере это была неверная идея
воспользоваться вторичным индексом.
.bp
.sh 1
ВОССТАНОВЛЕНИЕ И ИЗМЕНЕНИЕ ДАННЫХ
.sp 4
\*(RU имеет удачные структурные решения, направленные на
защиту целостности базы данных от различных классов
системных ошибок.
Чтобы это проделать,
\*(RU выполняет обращение к отношению,
которые мы называем
"отложенные изменения" ("differed update")
или "обновление пакетного файла" ("batch file update").
Вдобавок существуют две программы
\*(RU "restore" и "purge", которые могут быть использованы
для проверки базы данных после системного сбоя.
Сначала мы будем обсуждать как создаются и
выполняются отложенные изменения,
а потом уже использование команд
"purge" и "restore".
.sp 1
ОТЛОЖЕННЫЕ ИЗМЕНЕНИЯ (пакетное обновление)
.in +4
.sp 1
.ti -5
Команды
append, replace или delete запускаются в четыре шага:
.sp 1
.ti -5
1.  Создается пустой файл отложенных изменений.
.ti -5
2.  Команда запускается до завершения,
и каждое полученное результирующее отношение записывается в
файл отложенных изменений.
.ti -5
3.  Читается файл отложенных изменений, и исходное
отношение и его вторичные индексы
(если есть) соответствующим образом изменяются.
.ti -5
4.  Файл отложенных изменений
удаляется и \*(RU возвращается к обслуживанию
пользователя.
.sp 1
.in -4
Отложенные изменения дают отсрочку выполнению
текущих изменений до окончания выполнения запроса.
Существуют три преимущества для такого выполнения.
.sp 1
l.  Обеспечение восстановления после системных сбоев.
.sp 1
Если во время изменения произошел крах системы,
программа восстановления будет решать: запускать ли
изменения полностью или, иначе, возвратиться к первоначальному
содержимому отношения, которое было перед запуском изменений.
.sp 1
2. запрещение бесконечных запросов.
.sp 1
Если отношение "donation" имеет структуру куча и запрос:
.sp 1
.ti +4
range of d is donation
.ti +4
append to donation(d.all)
.sp 1
будет запущен без отложенных изменений,
он будет прекращен только когда ему не хватит свободного места на диске!
Это произойдет потому, что \*(RU будет начинать чтение отношения
сначала и добавлять каждый кортеж в конец.
Вскоре он начнет читать кортежи, которые уже
встречались и такая работа будет продолжаться до
бесконечности "в погоне за хвостом".
.sp 1
На самом деле такой запрос не типичен, приведен он просто
для иллюстрации.
Сущетствуют разнообразные классы запросов,
где проблема заключается в том, что точно не ясно,
КОГДА производить
необходимые текущие изменения.
При отложенных изменениях мы можем гарантировать
содержательный и логичный результат.
.sp 1
3.  Ускорение выполнения вторичных индексов
.sp 1
Вторичные индексы могут обновляться быстрее,
если они обрабатываются по одному, вместо всех за раз.
Это также обеспечивает защиту от вторичных индексов,
ставших бессодержательными относительно своих первичных отношений.
.sp 1
ОТКЛЮЧЕНИЕ ОТЛОЖЕННЫХ ИЗМЕНЕНИЙ
.sp 1
Если вас не убедили все эти аргументы,
\*(RU позволяет вам отключить отложенные изменения!
В самом деле, существуют различные случаи, где
это бывает удобно (хотя, конечно, несущественно)
производить изменения сразу же, т.е. отношение
изменяется в процессе выполнения запроса.
.sp 1
Чтобы использовать такие направленные изменения,
вы должны иметь разрешения, данные вам
суперпользователем \*(RU.
Тогда при вызове \*(RU надо указать ключ "\-\b",
который отключает пакетные изменения.
.sp 1
.ti +4
% ingres mydate -b
.sp 1
\*(RU будет использовать направленные изменения на всех отношениях, кроме
вторичных индексов.
Он все равно будет молча использовать отложенные изменения,
если дело касается отношений, имеющих вторичные индексы.
При использовании ключа "-b" вы приносите в жертву
пунты 1 и 2, указанные выше.
В большинстве случаев вы НЕ МОЖЕТЕ
использовать ключ -b.
.sp 1
Если вы используете \*(RU
для интерактивного ввода или изменения одного кортежа
в один момент времени, то отключение отложенных изменений
здесь не прибавляют особенно эффективности.
Если сбой системы произошел во время производившегося изменения,
то пользователь, вводящий данные, будет осознавать ситуацию и сможет
проверить, был ли изменен кортеж или нет.
.sp 1
ВОССТАНОВЛЕНИЕ
.sp 1
\*(RU имеет средства для восстановления данных после
типичных сбоев системы, которые свойственны файловой системе
\*(DM.
Имеется возможность восстановления  после команд изменния,
создания, удаления, модификации и индексирования.
.sp 1
\*(RU предназначен для хранения данных ("fail safe").
Eсли обнаруживаются некоторые несовместимости или некоторые
сбои, поступающие от \*(DM,
\*(RU будет генерировать сообщение о системной ошибке (SYSERR)
и оканчивать работу.
.sp 1
Всякий раз, когда происходит сбой \*(DM при работе \*(RU,
или всегда, когда \*(RU встречает системную ошибку,
самая лучшая идея в таком случае, чтобы администратор базы данных запустил
команду
.sp 1
.ti +5
% restore data_base_name
.sp 1
Программа восстановления проделывает следующее:
.in +4
.sp 1
.ti -5
1.  Просматривает файлы отложенных изменений.
Если все они найдены, она проверяет целостность каждого из них.
Если системный сбой произошел пока файл отложенных изменений читался,
а база данных изменялась, то восстановление будет
завершать изменение.
С другой стороны,файл отложенных изменений может быть
с нарушенной целостностью или просто разрушенным;
тогда эффект от восстановления будет таким, как-будто запрос вовсе
не был запущен.
.sp 1
.ti -5
2.  Проверяет незаконченность команд модификации.
Этот шаг является решающим.
Он гарантирует, что вы будете иметь отношение в том виде,
в каком оно было до модификации,
или оно будет результатом  полной работы команды modify.
Работа команды modify заключается в том, что создается отношение
с другой структурой. Затем, когда она готова к замене старого
отношения, она загружает новую информацию в файл отложенных изменений
команды modify ("modify batch file").
И это дает возможность процессу восстановления определить состояние
невыполненной команды modify.
.sp 1
.ti -5
3.  Проверка состояния системных отношений.
Такая проверка используется для завершения команд
"destory", остановки команд "create" и для
остановки или завершения команд "index",
которые были прерваны при сбое системы.
.sp 1
.ti -5
4.  Чистка временных отношений и файлов.
Программа восстановления выполняет программу "purge",
которая удаляет временные файлы, созданные системой.
purge будет обсуждаться в деталях чуть позже.
.in -4
.sp 1
restore не может сообщать пользователю, какие запросы были
запущены, а какие нет.
Она может только идентифицировать те запросы, которые были в процессе
выполнения во время сбоя системы.
Когда запускается поток запросов вместе,
хорошей идеей является сохранить вывод в файле.
При наличии мониторной выдачи запроса или
множества запросов, пользователь может позднее определить,
какой запрос был запущен.
.sp 1
restore имеет различные опции, которые улучшают
его использование.
Они определяются указанием ключей.
Опиции включают:
.sp 1
.nf
-a       запрашивать подтверждение
	 на выполнение
-f       для purge. Используется для удаления
	 временных файлов.
-p       для purge. Используется для удаления
	 отношений, у которых истек срок
	 хранения.
no database
	 восстановить все базы данных, для
	 которых вы администратор
.fi
.sp 1
Из этих опций наиболее важная "-a".
При сбое \*(DM может произойти ситуация, при которой
становится некорректной страница системного отношения.
Это может стать причиной разрушения отношения.
Фактически, вы можете "залатать" системное отношение  для
исправления ситуации.
Нет такой программы восстановления, при которой решались бы
все проблемы.
Следовательно, замену разуму придумать трудно.
.sp 1
Если указан ключ "-a",
restore будет сообщать о том, что она сейчас хочет делать
и запрашивать подтверждение на выполнение.
Она читает стандартный ввод и, получив "y", выполняет действие,
при любом другом символе не выполняет.
Например, для того, чтобы restore спрашивал вас перед выполнением
всякого действия:
.sp 1
.ti +5
restore -a mydatabase
.sp 1
Для того, что бы получать "no" на все вопросы
можно дать команду:
.sp 1
.ti +5
restore -a mydatabase </dev/null
.sp 1
Используя ключ -a, restore
сможет спрашивать разрешение для выполнения некоторых
чисток;
например,
если она найдет атрибут,
для которого нет соответствующего отношения,
или вторичный индекс,
для которого нет первичного отношения и т.д.
.sp 1
Нет таких сбоев системы, после которых \*(RU не смог бы
восстановить данные.
Это не означает, что они не будут происходить,
но вы не должны особенно беспокоиться.
Имейте в виду, что восстановление
не является заменой для периодического возврата,
и не применяется как функция.
.sp 1
ЧИСТКА (PURGE)
.sp 1
purge может использоваться для сообщения об отношениях, у которых истек
срок хранения,
разрушения временных системных отношений, удаления посторонних
файлов и удаления отношений, у которых истек срок хранения.
Для использования purge вы должны быть
DBA для данной базы данных.
.sp 1
.ti +5
% purge mydatabase
.sp 1
У команды purge имеется несколько опций, которые определяются путем
указания флагов:
.nr in 4n
.sp 1
.nf
-f   (по умолчанию отключен) удалять все
      посторонние файлы
      О каждом файле сообщать, затем
      удалять. Если ключ "-f" не
      указан, то о таких файлах
      будет только сообщаться.
.sp 1
-p   (по умолчанию отключен) разрушать все
      отношения, у которых истек срок
      хранения. О каждом таком файле
      сообщать, и если ключ "-p" был указан,
      то удалять.
.fi
.nr in 0
.sp 1
purge всегда удаляет отношения и файлы,
которые являются временными файлами \*(RU.
При выполнении мульти-переменных запросов и
запросов с агрегатными функциями,
\*(RU обычно будет создавать временные отношения с
промежуточными результатами.
Такие отношения всегда начинаются с символов
"_SYS".
Другие команды \*(RU создают временные файлы, которые также
начинаются с
"_SYS".
При нормальном выполнении они всегда уничтожаются.
При системном сбое они могут остаться.
Тогда purge обязательно очистит временные системные файлы.
Отношения пользователя он удаляет только в том случае, если его
специально об этом попросят.
