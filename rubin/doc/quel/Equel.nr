.th EQUEL QUEL "СУБД \*(RU. Операторы QUEL \*(DM"
.if n .ds EE EQUEL
.if t .ds EE \s-2EQUEL\s0
.sh ИМЯ
equel \- встроенный в язык C интерфейс с QUEL
.sh ОПИСАНИЕ
.it EQUEL
предоставляет пользователю возможности сопряжения
универсального языка программирования ``C''
с \*(II,
при этом используется
препроцессор
и библиотека
\*(EE.
.s1
Компиляция
осуществляется по команде \fBequel\fR, которая описана в разделе equel(demos)
данного руководства. Здесь будет описан язык EQUEL, встроенные переменные и
библиотечные функции.
.s2
.sh "1. Команды EQUEL"
.s2
Команды
\*(EE
помечаются указанием в начале строки
двух символов "диез"
(``##'').
Остальные строки на Си просто копируются в результирующий файл без изменения.
.s2
Команды \*(EE бывают нескольких типов:

1. Команды, являющиеся по сути просто операторами языка QUEL.
Практически любой оператор языка QUEL, за исключением оператора
выборки на терминал retrieve (без результирующего отношения)
может быть записан в EQUEL путем простого добавления ## с начала
каждой строки. Если в этом операторе не содержится имен переменных,
описанных в описаниях EQUEL, он просто выполняется так, как записан.

Например:

 ## destroy my_name

2. Специфические команды управления базой данных,
которым нет аналога в QUEL.
Это команды вызова СУБД "##\ rubin" и окончания связи с СУБД "##\ exit",
параметрические команды (они позволяют подставлять не описанные в EQUEL
переменные Си в
текст запроса QUEL) и команды выборки (они служат для получения
данных из базы программой на Си). Все эти команды реализуют
различные обращения к базе данных.

3. Описания переменных. По сути это операторы описания данных
языка Си, перед которыми добавляются символы ``##'' (с некоторыми
ограничениями на возможные типы данных). Имена переменных
распознаются прекомпилятором в операторах EQUEL и по
определенным правилам их значения подставляются в запрос либо,
напротив, этим переменным присваиваются значения (в операторах
выборки).

4. Скобки `\fB##{\fR' и `\fB##}\fR'. Они транслируются в
скобки языка Си и одновременно
служат для указания области действия переменных и операторов выборки в
EQUEL.

.sh "2. Базовые элементы языка"
.s2
Команды языка могут включать следующие элементы:
.de xx
.lp +20 15
\fI\\$1\fR \-\t\c
..
.xx "ключевые слова"
.br
Сюда входят все ключевые слова QUEL, а также ключевые слова языка Си
(за незначительными исключениями).
Они не могут использоваться в качестве имен переменных.
.xx "\fB#\fIимена языка QUEL\fR"
.br
имена, перед которыми стоит символ ``\fB#\fR'', считаются именами
оператора QUEL и просто транслируются в результирующий оператор
без изменения. Символ ``\fB#\fR'', таким образом, позволяет при
необходимости указать в запросе любое имя QUEL, даже совпадающее
с именем переменной EQUEL или ключевым словом Си.
.xx "Имена переменных EQUEL"
.br
Если в тексте оператора встречается имя переменной, описанной в
EQUEL, или допустимое (см. ниже) выражение с такой переменной,
то происходит подстановка значения этой переменной в
оператор QUEL.
Правила подстановки описаны ниже.
.xx "Имена, не совпадающие с именами переменных EQUEL"
.br
Такие имена просто передаются дальше в оператор QUEL, аналогично
именам, помеченным символом ``\fB#\fR''.
.xx "Выражения Си"
Там, где допускаются имена переменных EQUEL, могут быть
записаны также некоторые простейшие выражения языка Си,
состоящие из операторов: `\fB[]\fR', `\fB*\fR' (указатель), `\fB.\fR'
(селекция поля),
`\fB->\fR' (селекция поля).
В этом случае осуществляется подстановка данного
выражения.
.xx "Выражения QUEL"
Все остальные арифметические и логические операторы и выражения трактуются
как выражения языка QUEL и передаются в запрос СУБД.
.i0
.s3
.sh "3. Описания переменных EQUEL"
.s2
Операторы описания типов транслируются в программу на Си без изменения
(убирается префикс) и,
кроме того, сообщают препроцессору информацию о переменных (тип, имя, ...).
.s1
Синтаксис оператора описания EQUEL:

 \fB## \fIтип\fR \fIсписок_описаний\fB;\fR

	либо

 \fB## \fIтип список_описаний\fB=\fR
 \fIинициализация\fR\fB;\fR

.s1
\fIТип\fR - один из типов:
\fBchar\fR, \fBshort\fR, \fBint\fR, \fBlong\fR, \fBfloat\fR, \fBdouble\fR, \fIописание_структуры\fR.
В целом имеются следующие ограничения по сравнению с описаниями Си:

\fB1.\fR Допустимы простые переменные (кроме char), массивы, указатели и
структуры. Описания массивов и указателей не могут содержать скобок,
то есть элементы списка описаний должны иметь следующую форму:

 [ \fB*\fR... ] \fIимя\fR [ \fB[\fR [ \fIразмерность\fR ] \fB]\fR ...]

(здесь ... означает возможность повторения этой конструкции).
Не допустимы простые переменные символьного типа, так как
в выражениях символьного типа результатом всегда должен быть
указатель или массив символов.

\fB2.\fR Описания структур не должны быть вложенными.
Они имеют вид:

 \fB## struct \fR[\fIимя структуры\fR] \fB{     \fR
 \fB## \fIописание элементов структуры\fR
 ...
 \fB## } \fIсписок описаний\fB;\fR

Можно использовать отдельное описание типа структуры, если оно
снабжено префиксом `\fB##\fR'.

\fB3.\fR Не допустимы объединения и вложенные структуры.

\fB4.\fR Допустимы описания размещения extern, auto, static. Инициализированные
переменные описываются следующим образом:

 \fB## \fIописание \fB=\fR
 \fIинициализация\fB;\fR

то есть список значений выносится на отдельную строку.

\fB5.\fR Данные типа \fBdate\fR и \fBtime\fR хранятся в переменных типа \fBlong\fR.

Примеры:

 ## char *p, buf[20];
 ## char *my_name =
 "Alex";
 ## struct xx {
 ## short x;
 ## short y;
 ## char *name[2];
 ## } *xy1[MAX], *pxy;


.s3
.sh "4. Область определения переменных"
.s2
Правила для области определения такие же, как и для языка Си,
но учитываются только блоки, ограниченные скобками `\fB##{\fR' и `\fB##}\fR':

 Глобальные определения
 ## {
 Локальные определения
 блок
 ##}


.s3
.sh "5. Правила подстановки"
.s2
Везде, где встречается имя переменной EQUEL (не замаскированное символом
`\fB#\fR'), производится
подстановка значения этой переменной. Можно использовать выражения
с операциями `\fB*\fR' (ссылка), `\fB[]\fR' (выборка из массива), `\fB.\fR' и `\fB->\fR\'
(выборка из структуры) при условии, что выражение не содержит скобок
и результат имеет один из типов: short, int, long, double, float, char* .
Например (см. описание выше):

 *p
 my_name
 xy1[2]->x
 xy1[1]->name

 Недопустимо:

 *(xy1+2).x
 &(xy1[1]->name[1])

Подстановка осуществляется следующим образом (за исключением операторов
быборки, про которые ниже):

1. Если по контексту на месте подстановки может стоять константа или
имя файла в кавычках, то
значение переменной подставляется в качестве константы или имени файла;

2. Если на месте подстановки должно быть имя (какого-либо объекта QUEL)
имя функции
или ключевое слово `\fBinto\fR', `\fBfrom\fR', то переменная (или выражение)
должны быть типа `\fBchar *\fR' и значение подставляется в качестве имени или
ключевого слова.

3. Имя базы данных и ключи в операторе `\fB##rubin\fR' могут быть
заменены на переменную символьного типа.

.sh "6. Управляющие операторы EQUEL"
.s3
1. Начать работу с базойц данныхщ:

 \fB## rubin \fR[\fB"\fIключи\fB"\fR] \fIимя_базы_данных\fR

Ключи могут быть текстовой переменной, имя базы данных - тоже.
При непосредственной записи в строке ключи нужно брать в кавычки.
Этот оператор должен предшествовать любым операторам работы с базой
данных.

2. Окончить работу с базой данных:

 \fB## exit\fR

Одновременно программа может работать только с одной базой данных.
.sh "7. `Обычные' операторы EQUEL"
.s3
Следующие операторы Quel могут быть записаны в EQUEL (с учетом
правил подстановки) и работают точно так же:

.s2
.de xx
.br
\t\fI\\$1\t\\$2\t\\$3\t\\$4\fR
.br
..
.ta 10 22 34 46 58
.xx append copy create define
.xx delete destroy help index
.xx modify print range replace
.xx save "`retriene into'"
.dt
.i0
.s3
Заметим, что оператор retrieve должен в данном случае иметь
результирующее отношение.

.sh "8. Параметрические операторы"
.s2
Параметрические операторы позволяют осуществлять подстановку
произвольных переменных языка Си по форматному списку и списку
адресов переменных, которые могут в этом случае не описываться в
EQUEL. Основой этих операторов является параметрический список вида:

 \fB(\fIform\fB,\fIargv\fB)\fR
 char *form;
 char *argv[];

где \fIform\fR - формат, то есть строка текста;  а \fIargv\fR - массив_адресов, то
есть массив указателей на переменные.
Формат может содержать произвольный текст, который просто переносится в
результирующий оператор QUEL, и ссылки на переменные из массива адресов
вида:

 \fB%\fI<тип><длина>\fR

Допустимые следующие ссылки:
.xx Имя "Тип в языке Си"
.xx %i1 char
.xx %i2 short
.xx %i4 long
.xx %f4 float
.xx %f8 double
.xx %c "(char *)"
.dt
.i0
По формату происходит подстановка очередного значения из списка
argv в результирующий оператор в качестве константы. Особым образом
обрабатывается параметрический список в операторе выборки, см. ниже.
.s3
Параметрическими могут быть следующие операторы (операторы выборки см. ниже):

 \fB## param append \fIимя \fB(\fIform\fB, \fIargv\fB)\fR [\fBwhere \fIусловие\fR]
 \fB## param copy \fIимя_отн\fB(\fIform\fB,\fIargv\fB) \fIнаправление имя_файла \fR
 \fB## param create \fIимя_отн\fB(\fIform\fB,\fIargv\fB)\fR
 \fB## param replace \fIимя \fB(\fIform\fB,\fIargv\fB) \fR[ \fBwhere\fI условие\fR]
 \fB## param retrieve into \fIимя \fB(\fIform\fB,\fIargv\fB)\fR [\fBwhere \fIусловие\fR]
 \fB## param define view \fIимя \fB(\fIform\fB,\fIargv\fB)\fR [\fBwhere\fI условие\fR]

В параметрических операторах \fBcopy\fR и \fBcreate\fR подстановка по формату \fBне
имеет смысла\fR, так как в них не бывает текстовых констант.
Параметрическая форма оператора позволяет в них
сформировать объектный список или список атрибутов заранее в текстовом
виде и использовать его в операторе.

Пример:

 char *form="name=%c, bdate=%i4, staj=%i2";
 char name[32];
 long bdate;
 short staj;
 char *av[]= {
 (char *)&name[0],
 (char *)&bdate,
 (char *)&staj };

 ...
 ## param append to users(form,av)

.sh "8. Условие WHERE"
В EQUEL можно использовать три формы условия `where ...'.
Первая форма совпадает с QUEL с тем отличием, что
производится подстановки EQUEL-переменных.

 \fB## where \fIвыражение_QUEL\fR

Вторая имеет форму:

 \fB## where \fIтекстовая_переменная\fR

В этом случае условие берется целиком из текстовой переменной.

Третия форма имеет вид:

 \fB## where param(\fIform\fB,\fI argv\fB)\fR

Производится подстановка по правилам параметрических операторов.
.sh "9. Операторы выборки данных"
Эти операторы позволяют программе на Си получить данные из базы
по запросу QUEL. Обычный
оператор выборки имеет формат:

 \fB## retrieve (\fIимя\fB=\fIвыражение\fB,\fR ...\fB) \fR[ \fBwhere \fIусловие\fR]
 \fB##{\fR
 \fIСи-блок\fR
 \fB##}\fR

Где \fIимя\fR - имя EQUEL-переменной, \fIвыражение\fR - обычное выражение,
допустимое в правой части оператора QUEL с учетом правил подстановки
EQUEL.

Оператор выборки работает так. Сначала \fBформируется запрос\fR
к базе данных, при этом производится подстановка переменных в
правых частях выражений и в условии выборки. Затем \fBдля каждого\fR
найденного кортежа найденные значения \fBприсваиваются переменным\fR,
которые стоят в левых частях результирующего списка, и \fBвыполняется
Си-блок\fR с этими подставленными значениями.

Си-блок не должен содержать операторов EQUEL. Выход из Си-блока возможен
либо при исчерпании найденных кортежей, либо по оператору `\fBbreak\fR'.
Оператор выборки транслируется в цикл выборки кортежей, за которым
следует обращение к программе пропуска оставшихся кортежей на случай
преждевременного выхода их этого цикла.

Параметрический оператор выборки позволяет не описывать переменные в EQUEL.
Он выглядит так:

 \fB## param retrieve (\fIform\fB,\fIargv\fB) \fR[\fBwhere\fI условие\fR]
 \fB## {\fR
 \fIСи-блок\fR
 \fB## }\fR

Отличие в том, что список выборки задается параметрически, причем
формат должен иметь вид:

 \fB"%\fI<формат>\fB=\fIвыражение\fR, ...\fB"\fR

Каждый элемент результирующего списка начинается с формата
очередной переменной в массиве аргументов и означает, что значение
выражения будет присваиваться этой переменной в соответствии с указанным
форматом.
В остальном оператор аналогичен предыдущему.

Пример:

 char *av[] = { &long_var,
	&name[0],
	&flt };
 char *form="%i4=rel.num, %c=rel.name, %f4=rel.val";
 ...
 ## param retrieve (form, av) where rel.count > 10
 ##{
 printf("Num=%ld\tname=%s\tval=%g\n", long_var, name, flt);
 ##}

В результате для каждой найденной записи из отношения `rel' будут напечатаны
поля `num', `name', `val'.
.sh "10. Библиотека и переменные EQUEL"
При трансляции программы, полученной прекомпилятором EQUEL, ее
необходимо собирать с библиотекой `libq.a' (то есть с ключом `-lq').
Для использования этой библиотеки непосредственно из операторов Си
(а не только через операторы EQUEL) необходимо подключить файл вставок:

 # include <rubin/equel.h>

При этом становятся доступными служебные подпрограммы EQUEL, управляющие
взаимодействием с базой данных, и ряд специальных переменных EQUEL.

Основные переменные:

.de xx
.lp +20 15
\fB\\$1\fR \-\t\c
..

.xx IIerrflag
Признак ошибки (0 - ошибки в последнем операторе не было);
.xx IItupcnt
Число считанных или изменившихся в последнем операторе кортежей;
.xx IIinterupt
.xx IIabort
Адрес пользовательских программ реакции на прерывание и на системную
ошибку;
.xx IIprint_err
.xx IIout_err
адреса пользовательских программ печати ошибки и печати очередной
строки сообщения об ошибке;
.dt
.s2
.i0
Кроме того, в библиотеку входят программы преобразования
дынных (в особенности даты и времени) и программы работы со строками.
Подробное описание см. в разделе \fBlibq(files)\fR справочного руководства.
.sh "11. Сигналы и прерывания"
Прерывания при работе программы на EQUEL должны либо обрабатываться
самой системой EQUEL, либо игнорироваться. Перехват реакции на
прерывания программой с помощью функции `\fBsignal\fR' может привести к
фатальным последствиям. Программа может выполнить свою реакцию на
прерывание, установив адрес соответствующей функции в переменную

 extern int (*IIinterupt)();

Единственным исключением является случай, когда программа
закрывает прерывания перед выполнением оператора `\fB## rubin\fR',
а затем устанавливает свою реакцию на прерывания. В этом случае
работа базы данных прерываться не будет, и перехват прерываний не скажется
на правильности функционирования системы (если не
нарушается требование об выходе из оператора выборки через оператор `\fBbreak\fR').
.sh "ДОПОЛНИТЕЛЬНЫЕ ССЫЛКИ"

 libq(files), equel(demos), "\fBРуководство по программированию на EQUEL\fR".
